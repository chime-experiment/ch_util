

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ch_util.andata &mdash; ch_util 25.3.1.post7+git.a3fec444 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/katex-math.css?v=05624691" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1d928e64"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/katex.min.js?v=5cc8ed51"></script>
      <script src="../../_static/auto-render.min.js?v=af98beb9"></script>
      <script src="../../_static/katex_autorenderer.js?v=bebc588a"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ch_util
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ch_util</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ch_util.andata</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ch_util.andata</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Analysis data format&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os</span><span class="w"> </span><span class="kn">import</span> <span class="n">path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">posixpath</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bitshuffle</span><span class="w"> </span><span class="kn">import</span> <span class="n">h5</span> <span class="k">as</span> <span class="n">h5</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">memh5</span><span class="p">,</span> <span class="n">tod</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">caput.time</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ctime</span>


<span class="c1"># Datasets in the Acq files whose shape is the same as the visibilities.</span>
<span class="c1"># Variable only used for legacy archive version 1.</span>
<span class="n">ACQ_VIS_SHAPE_DATASETS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;vis_flag&quot;</span><span class="p">,</span> <span class="s2">&quot;vis_weight&quot;</span><span class="p">)</span>

<span class="c1"># Datasets in the Acq files that are visibilities or gated visibilities</span>
<span class="n">ACQ_VIS_DATASETS</span> <span class="o">=</span> <span class="s2">&quot;^vis$|^gated_vis[0-9]$&quot;</span>

<span class="c1"># Datasets in the HK files that are data.</span>
<span class="n">HK_DATASET_NAMES</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;^mux[0-9]</span><span class="si">{2}</span><span class="s2">$&quot;</span><span class="p">)</span>

<span class="c1"># List of axes over which we can concatenate datasets.  To be concatenated, all</span>
<span class="c1"># datasets must have one and only one of these in their &#39;axes&#39; attribute.</span>
<span class="n">CONCATENATION_AXES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gated_time0&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gated_time1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gated_time2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gated_time3&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gated_time4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;snapshot&quot;</span><span class="p">,</span>
    <span class="s2">&quot;update_time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;station_time_blockhouse&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">ANDATA_VERSION</span> <span class="o">=</span> <span class="s2">&quot;3.1.0&quot;</span>


<span class="c1"># Main Class Definition</span>
<span class="c1"># ---------------------</span>


<div class="viewcode-block" id="BaseData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseData</span><span class="p">(</span><span class="n">tod</span><span class="o">.</span><span class="n">TOData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CHIME data in analysis format.</span>

<span class="sd">    Inherits from :class:`caput.memh5.BasicCont`.</span>

<span class="sd">    This is intended to be the main data class for the post</span>
<span class="sd">    acquisition/real-time analysis parts of the pipeline. This class is laid</span>
<span class="sd">    out very similarly to how the data is stored in analysis format hdf5 files</span>
<span class="sd">    and the data in this class can be optionally stored in such an hdf5 file</span>
<span class="sd">    instead of in memory.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_data : h5py.Group, memh5.MemGroup or hdf5 filename, optional</span>
<span class="sd">        Underlying h5py like data container where data will be stored. If not</span>
<span class="sd">        provided a new :class:`caput.memh5.MemGroup` instance will be created.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time_axes</span> <span class="o">=</span> <span class="n">CONCATENATION_AXES</span>

    <span class="c1"># Convert strings to/from unicode on load and save</span>
    <span class="n">convert_attribute_strings</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">convert_dataset_strings</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">h5_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used to pick which subclass to instantiate based on attributes in</span>
<span class="sd">        data.&quot;&quot;&quot;</span>

        <span class="n">new_cls</span> <span class="o">=</span> <span class="n">subclass_from_obj</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">h5_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">new_cls</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">h5_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;r+&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;cal&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;flags&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;reverse_map&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;andata_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ANDATA_VERSION</span>

    <span class="c1"># - The main interface - #</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stores hdf5 datasets holding all data.</span>

<span class="sd">        Each dataset can reference a calibration scheme in</span>
<span class="sd">        ``datasets[name].attrs[&#39;cal&#39;]`` which refers to an entry in</span>
<span class="sd">        :attr:`~BaseData.cal`.</span>

<span class="sd">        Do not try to add a new dataset by assigning to an item of this</span>
<span class="sd">        property. Use `create_dataset` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        datasets : read only dictionary</span>
<span class="sd">            Entries are :mod:`h5py` or :mod:`caput.memh5` datasets.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Datasets representing flags and data weights.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flags : read only dictionary</span>
<span class="sd">            Entries are :mod:`h5py` or :mod:`caput.memh5` datasets.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">({})</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stores calibration schemes for the datasets.</span>

<span class="sd">        Each entry is a calibration scheme which itself is a dict storing</span>
<span class="sd">        meta-data about calibration.</span>

<span class="sd">        Do not try to add a new entry by assigning to an element of this</span>
<span class="sd">        property. Use :meth:`~BaseData.create_cal` instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cal : read only dictionary</span>
<span class="sd">            Calibration schemes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">return</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># - Methods used by base class to control container structure. - #</span>

<div class="viewcode-block" id="BaseData.dataset_name_allowed">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.dataset_name_allowed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dataset_name_allowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Permits datasets in the root and &#39;flags&#39; groups.&quot;&quot;&quot;</span>

        <span class="n">parent_name</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">posixpath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">parent_name</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span> <span class="ow">or</span> <span class="n">parent_name</span> <span class="o">==</span> <span class="s2">&quot;/flags&quot;</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BaseData.group_name_allowed">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.group_name_allowed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_name_allowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Permits only the &quot;flags&quot; group.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;/flags&quot;</span> <span class="k">else</span> <span class="kc">False</span></div>


    <span class="c1"># - Methods for manipulating and building the class. - #</span>

<div class="viewcode-block" id="BaseData.create_cal">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.create_cal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_cal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new cal entry.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">cal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cal</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cal</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="BaseData.create_flag">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.create_flag">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new flags dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;flags/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseData.create_reverse_map">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.create_reverse_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_reverse_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">reverse_map</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new reverse map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;reverse_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">reverse_map</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseData.del_reverse_map">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.del_reverse_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">del_reverse_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete a reverse map.&quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;reverse_map&quot;</span><span class="p">][</span><span class="n">axis_name</span><span class="p">]</span></div>


    <span class="c1"># - These describe the various data axes. - #</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ntime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the time axis of the visibilities.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The &#39;time&#39; axis centres as Unix/POSIX time.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">):</span>
            <span class="c1"># Already a calculated timestamp.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:]</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">_timestamp_from_fpga_cpu</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;ctime&quot;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_attrs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alignment&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alignment</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">alignment</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">time</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>
        <span class="c1"># Save a reference to the first file to get index map information for</span>
        <span class="c1"># later.</span>
        <span class="n">f_first</span> <span class="o">=</span> <span class="n">acq_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">andata_objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="n">andata_objs</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f_first</span><span class="p">[</span><span class="s2">&quot;index_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="BaseData.from_acq_h5">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.from_acq_h5">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_acq_h5</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert acquisition format hdf5 data to analysis data object.</span>

<span class="sd">        Reads hdf5 data produced by the acquisition system and converts it to</span>
<span class="sd">        analysis format in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acq_files : filename, `h5py.File` or list there-of or filename pattern</span>
<span class="sd">            Files to convert from acquisition format to analysis format.</span>
<span class="sd">            Filename patterns with wild cards (e.g. &quot;foo*.h5&quot;) are supported.</span>
<span class="sd">        start : integer, optional</span>
<span class="sd">            What frame to start at in the full set of files.</span>
<span class="sd">        stop : integer, optional</span>
<span class="sd">            What frame to stop at in the full set of files.</span>
<span class="sd">        datasets : list of strings</span>
<span class="sd">            Names of datasets to include from acquisition files. Default is to</span>
<span class="sd">            include all datasets found in the acquisition files.</span>
<span class="sd">        out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">            Underlying hdf5 like container that will store the data for the</span>
<span class="sd">            BaseData instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Examples are analogous to those of :meth:`CorrData.from_acq_h5`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make sure the input is a sequence and that we have at least one file.</span>
        <span class="n">acq_files</span> <span class="o">=</span> <span class="n">tod</span><span class="o">.</span><span class="n">ensure_file_list</span><span class="p">(</span><span class="n">acq_files</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">acq_files</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acquisition file list is empty.&quot;</span><span class="p">)</span>

        <span class="n">to_close</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_files</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Open the files while keeping track of this so that we can close</span>
            <span class="c1"># them later.</span>
            <span class="n">_open_files</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="n">to_close</span><span class="p">)</span>

            <span class="c1"># Now read them in: the functionality here is provided by the</span>
            <span class="c1"># overloaded method in the inherited class. If this method is</span>
            <span class="c1"># called on this base class, an exception will be raised.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_interpret_and_read</span><span class="p">(</span>
                <span class="n">acq_files</span><span class="o">=</span><span class="n">acq_files</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
                <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Set an attribute on the time axis specifying alignment</span>
            <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">index_attrs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;alignment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Close any files opened in this function.</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">acq_files</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_close</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ii</span> <span class="ow">and</span> <span class="n">to_close</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                    <span class="n">acq_files</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deprecated name for :attr:`~BaseData.time`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>

<div class="viewcode-block" id="BaseData.convert_time">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseData.convert_time">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">time</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CorrData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrData</span><span class="p">(</span><span class="n">BaseData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseData` for correlation data.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to the visibilities array.</span>

<span class="sd">        Equivalent to `self.datasets[&#39;vis&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to the gain dataset.</span>

<span class="sd">        Equivalent to `self.datasets[&#39;gain&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to the visibility weight array.</span>

<span class="sd">        Equivalent to `self.flags[&#39;vis_weight&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to the input flags dataset.</span>

<span class="sd">        Equivalent to `self.flags[&#39;inputs&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dataset_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Access dataset id dataset in unicode format.&quot;&quot;&quot;</span>
        <span class="n">dsid</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ensure_unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">][:])</span>
        <span class="n">dsid</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">dsid</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nprod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the prod axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The correlation product axis as channel pairs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the freq axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The spectral frequency axis as bin centres in MHz.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ninput</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nstack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The correlation product axis as channel pairs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prodstack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A pair of input indices representative of those in the stack.</span>

<span class="sd">        Note, these are correctly conjugated on return, and so calculations</span>
<span class="sd">        of the baseline and polarisation can be done without additionally</span>
<span class="sd">        looking up the stack conjugation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stacked</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>

        <span class="n">prodmap</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">conj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span>
        <span class="n">prodmap</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">])</span>
        <span class="n">prodmap</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">prodmap</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_stacked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;stack&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">acq_files</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">datasets</span><span class="p">,</span>
        <span class="n">out_group</span><span class="p">,</span>
        <span class="n">stack_sel</span><span class="p">,</span>
        <span class="n">prod_sel</span><span class="p">,</span>
        <span class="n">input_sel</span><span class="p">,</span>
        <span class="n">freq_sel</span><span class="p">,</span>
        <span class="n">apply_gain</span><span class="p">,</span>
        <span class="n">renormalize</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Selection defaults.</span>
        <span class="n">freq_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">)</span>
        <span class="c1"># If calculating the &#39;gain&#39; dataset, ensure prerequisite datasets</span>
        <span class="c1"># are loaded.</span>
        <span class="k">if</span> <span class="n">datasets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;vis&quot;</span> <span class="ow">in</span> <span class="n">datasets</span> <span class="ow">and</span> <span class="n">apply_gain</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;gain&quot;</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">datasets</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;gain&quot;</span><span class="p">,</span> <span class="s2">&quot;gain_exp&quot;</span><span class="p">,</span> <span class="s2">&quot;gain_coeff&quot;</span><span class="p">)</span>
        <span class="c1"># Always load packet loss dataset if available, so we can normalized</span>
        <span class="c1"># for it.</span>
        <span class="k">if</span> <span class="n">datasets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">norm_dsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">datasets</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ACQ_VIS_DATASETS</span><span class="p">,</span> <span class="n">d</span><span class="p">)]</span>
            <span class="k">if</span> <span class="s2">&quot;vis_weight&quot;</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
                <span class="n">norm_dsets</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">norm_dsets</span><span class="p">):</span>
                <span class="n">datasets</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;flags/lost_packet_count&quot;</span><span class="p">,)</span>

        <span class="c1"># Inspect the header of the first file for version information.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">acq_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">archive_version</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;archive_version&quot;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">archive_version</span> <span class="o">=</span> <span class="s2">&quot;1.0.0&quot;</span>

        <span class="c1"># Transform the dataset according to the version.</span>
        <span class="k">if</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.0.0&quot;</span><span class="p">):</span>
            <span class="c1"># Nothing to do for input_sel as there is not input axis.</span>
            <span class="k">if</span> <span class="n">input_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;*input_sel* specified for archive version&quot;</span>
                    <span class="s2">&quot; 1.0 data which has no input axis.&quot;</span>
                <span class="p">)</span>
            <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">andata_from_acq1</span><span class="p">(</span>
                <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">freq_sel</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span>
            <span class="p">)</span>
            <span class="n">input_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">input_sel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.0.0&quot;</span><span class="p">):</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">input_sel</span> <span class="o">=</span> <span class="n">andata_from_archive2</span><span class="p">(</span>
                <span class="bp">cls</span><span class="p">,</span>
                <span class="n">acq_files</span><span class="p">,</span>
                <span class="n">start</span><span class="p">,</span>
                <span class="n">stop</span><span class="p">,</span>
                <span class="n">stack_sel</span><span class="p">,</span>
                <span class="n">prod_sel</span><span class="p">,</span>
                <span class="n">input_sel</span><span class="p">,</span>
                <span class="n">freq_sel</span><span class="p">,</span>
                <span class="n">datasets</span><span class="p">,</span>
                <span class="n">out_group</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Generate the correct index_map/input for older files</span>
        <span class="k">if</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.1.0&quot;</span><span class="p">):</span>
            <span class="n">_remap_inputs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Insert the gain dataset if requested, or datasets is not specified</span>
        <span class="c1"># For version 3.0.0 we don&#39;t need to do any of this</span>
        <span class="k">if</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;3.0.0&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">datasets</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s2">&quot;gain&quot;</span> <span class="ow">in</span> <span class="n">datasets</span>
        <span class="p">):</span>
            <span class="n">_insert_gains</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">input_sel</span><span class="p">)</span>

            <span class="c1"># Remove the FPGA applied gains (need to invert them first).</span>
            <span class="k">if</span> <span class="n">apply_gain</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ACQ_VIS_DATASETS</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span>
            <span class="p">):</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">ch_util</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span>

                <span class="n">gain</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span>

                <span class="c1"># Create an array of safe-inverse gains.</span>
                <span class="n">gain_inv</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">gain</span><span class="p">)</span>

                <span class="c1"># Loop over datasets and apply inverse gains where appropriate</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ACQ_VIS_DATASETS</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span>
                    <span class="p">):</span>
                        <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span>
                            <span class="n">dset</span><span class="p">[:],</span>
                            <span class="n">gain_inv</span><span class="p">,</span>
                            <span class="n">out</span><span class="o">=</span><span class="n">dset</span><span class="p">[:],</span>
                            <span class="n">prod_map</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">],</span>
                        <span class="p">)</span>

        <span class="c1"># Fix up wrapping of FPGA counts</span>
        <span class="k">if</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.4.0&quot;</span><span class="p">):</span>
            <span class="n">_unwrap_fpga_counts</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Renormalize for dropped packets</span>
        <span class="c1"># Not needed for &gt; 3.0</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;3.0.0&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">renormalize</span>
            <span class="ow">and</span> <span class="s2">&quot;lost_packet_count&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span>
        <span class="p">):</span>
            <span class="n">_renormalize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="CorrData.from_acq_h5">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrData.from_acq_h5">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_acq_h5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert acquisition format hdf5 data to analysis data object.</span>

<span class="sd">        This method overloads the one in BaseData.</span>

<span class="sd">        Changed Jan. 22, 2016: input arguments are now ``(acq_files, start,</span>
<span class="sd">        stop, **kwargs)`` instead of ``(acq_files, start, stop, prod_sel,</span>
<span class="sd">        freq_sel, datasets, out_group)``.</span>

<span class="sd">        Reads hdf5 data produced by the acquisition system and converts it to</span>
<span class="sd">        analysis format in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acq_files : filename, `h5py.File` or list there-of or filename pattern</span>
<span class="sd">            Files to convert from acquisition format to analysis format.</span>
<span class="sd">            Filename patterns with wild cards (e.g. &quot;foo*.h5&quot;) are supported.</span>
<span class="sd">        start : integer, optional</span>
<span class="sd">            What frame to start at in the full set of files.</span>
<span class="sd">        stop : integer, optional</span>
<span class="sd">            What frame to stop at in the full set of files.</span>
<span class="sd">        stack_sel : valid numpy index</span>
<span class="sd">            Used to select a subset of the stacked correlation products.</span>
<span class="sd">            Only one of *stack_sel*, *prod_sel*, and *input_sel* may be</span>
<span class="sd">            specified, with *prod_sel* preferred over *input_sel* and</span>
<span class="sd">            *stack_sel* proferred over both.</span>
<span class="sd">            :mod:`h5py` fancy indexing supported but to be used with caution</span>
<span class="sd">            due to poor reading performance.</span>
<span class="sd">        prod_sel : valid numpy index</span>
<span class="sd">            Used to select a subset of correlation products.</span>
<span class="sd">            Only one of *stack_sel*, *prod_sel*, and *input_sel* may be</span>
<span class="sd">            specified, with *prod_sel* preferred over *input_sel* and</span>
<span class="sd">            *stack_sel* proferred over both.</span>
<span class="sd">            :mod:`h5py` fancy indexing supported but to be used with caution</span>
<span class="sd">            due to poor reading performance.</span>
<span class="sd">        input_sel : valid numpy index</span>
<span class="sd">            Used to select a subset of correlator inputs.</span>
<span class="sd">            Only one of *stack_sel*, *prod_sel*, and *input_sel* may be</span>
<span class="sd">            specified, with *prod_sel* preferred over *input_sel* and</span>
<span class="sd">            *stack_sel* proferred over both.</span>
<span class="sd">            :mod:`h5py` fancy indexing supported but to be used with caution</span>
<span class="sd">            due to poor reading performance.</span>
<span class="sd">        freq_sel : valid numpy index</span>
<span class="sd">            Used to select a subset of frequencies.</span>
<span class="sd">            :mod:`h5py` fancy indexing supported but to be used with caution</span>
<span class="sd">            due to poor reading performance.</span>
<span class="sd">        datasets : list of strings</span>
<span class="sd">            Names of datasets to include from acquisition files. Default is to</span>
<span class="sd">            include all datasets found in the acquisition files.</span>
<span class="sd">        out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">            Underlying hdf5 like container that will store the data for the</span>
<span class="sd">            BaseData instance.</span>
<span class="sd">        apply_gain : boolean, optional</span>
<span class="sd">            Whether to apply the inverse gains to the visibility datasets.</span>
<span class="sd">        renormalize : boolean, optional</span>
<span class="sd">            Whether to renormalize for dropped packets.</span>
<span class="sd">        distributed : boolean, optional</span>
<span class="sd">            Load data into a distributed dataset.</span>
<span class="sd">        comm : MPI.Comm</span>
<span class="sd">            Communicator to distributed over. Use MPI.COMM_WORLD if not set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : CorrData</span>
<span class="sd">            Loaded data object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Suppose we have two acquisition format files (this test data is</span>
<span class="sd">        included in the ch_util repository):</span>

<span class="sd">        &gt;&gt;&gt; import os</span>
<span class="sd">        &gt;&gt;&gt; import glob</span>
<span class="sd">        &gt;&gt;&gt; from . import test_andata</span>
<span class="sd">        &gt;&gt;&gt; os.chdir(test_andata.data_path)</span>
<span class="sd">        &gt;&gt;&gt; print(glob.glob(&#39;test_acq.h5*&#39;))</span>
<span class="sd">        [&#39;test_acq.h5.0001&#39;, &#39;test_acq.h5.0002&#39;]</span>

<span class="sd">        These can be converted into one big analysis format data object:</span>

<span class="sd">        &gt;&gt;&gt; data = CorrData.from_acq_h5(&#39;test_acq.h5*&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(data.vis.shape)</span>
<span class="sd">        (1024, 36, 31)</span>

<span class="sd">        If we only want a subset of the total frames (time bins) in these files</span>
<span class="sd">        we can supply start and stop indices.</span>

<span class="sd">        &gt;&gt;&gt; data = CorrData.from_acq_h5(&#39;test_acq.h5*&#39;, start=5, stop=-3)</span>
<span class="sd">        &gt;&gt;&gt; print(data.vis.shape)</span>
<span class="sd">        (1024, 36, 23)</span>

<span class="sd">        If we want a subset of the correlation products or spectral</span>
<span class="sd">        frequencies, specify the *prod_sel* or *freq_sel* respectively:</span>

<span class="sd">        &gt;&gt;&gt; data = CorrData.from_acq_h5(</span>
<span class="sd">        ...     &#39;test_acq.h5*&#39;,</span>
<span class="sd">        ...     prod_sel=[0, 8, 15, 21],</span>
<span class="sd">        ...     freq_sel=slice(5, 15),</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; print(data.vis.shape)</span>
<span class="sd">        (10, 4, 31)</span>
<span class="sd">        &gt;&gt;&gt; data = CorrData.from_acq_h5(&#39;test_acq.h5*&#39;, prod_sel=1,</span>
<span class="sd">        ...                           freq_sel=slice(None, None, 10))</span>
<span class="sd">        &gt;&gt;&gt; print(data.vis.shape)</span>
<span class="sd">        (103, 1, 31)</span>

<span class="sd">        The underlying hdf5-like container that holds the *analysis format*</span>
<span class="sd">        data can also be specified.</span>

<span class="sd">        &gt;&gt;&gt; group = memh5.MemGroup()</span>
<span class="sd">        &gt;&gt;&gt; data = CorrData.from_acq_h5(&#39;test_acq.h5*&#39;, out_group=group)</span>
<span class="sd">        &gt;&gt;&gt; print(group[&#39;vis&#39;].shape)</span>
<span class="sd">        (1024, 36, 31)</span>
<span class="sd">        &gt;&gt;&gt; group[&#39;vis&#39;] is data.vis</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stack_sel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;stack_sel&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prod_sel&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">input_sel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;input_sel&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">freq_sel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;freq_sel&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;datasets&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">out_group</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;out_group&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">apply_gain</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;apply_gain&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">renormalize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;renormalize&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">distributed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;distributed&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;comm&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received unknown keyword arguments </span><span class="si">{</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># If want a distributed file, just pass straight off to a private method</span>
        <span class="k">if</span> <span class="n">distributed</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_acq_h5_distributed</span><span class="p">(</span>
                <span class="n">acq_files</span><span class="o">=</span><span class="n">acq_files</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
                <span class="n">stack_sel</span><span class="o">=</span><span class="n">stack_sel</span><span class="p">,</span>
                <span class="n">prod_sel</span><span class="o">=</span><span class="n">prod_sel</span><span class="p">,</span>
                <span class="n">input_sel</span><span class="o">=</span><span class="n">input_sel</span><span class="p">,</span>
                <span class="n">freq_sel</span><span class="o">=</span><span class="n">freq_sel</span><span class="p">,</span>
                <span class="n">apply_gain</span><span class="o">=</span><span class="n">apply_gain</span><span class="p">,</span>
                <span class="n">renormalize</span><span class="o">=</span><span class="n">renormalize</span><span class="p">,</span>
                <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="n">acq_files</span><span class="o">=</span><span class="n">acq_files</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
            <span class="n">stack_sel</span><span class="o">=</span><span class="n">stack_sel</span><span class="p">,</span>
            <span class="n">prod_sel</span><span class="o">=</span><span class="n">prod_sel</span><span class="p">,</span>
            <span class="n">input_sel</span><span class="o">=</span><span class="n">input_sel</span><span class="p">,</span>
            <span class="n">freq_sel</span><span class="o">=</span><span class="n">freq_sel</span><span class="p">,</span>
            <span class="n">apply_gain</span><span class="o">=</span><span class="n">apply_gain</span><span class="p">,</span>
            <span class="n">renormalize</span><span class="o">=</span><span class="n">renormalize</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_acq_h5_distributed</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">acq_files</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">,</span>
        <span class="n">stack_sel</span><span class="p">,</span>
        <span class="n">prod_sel</span><span class="p">,</span>
        <span class="n">input_sel</span><span class="p">,</span>
        <span class="n">freq_sel</span><span class="p">,</span>
        <span class="n">datasets</span><span class="p">,</span>
        <span class="n">apply_gain</span><span class="p">,</span>
        <span class="n">renormalize</span><span class="p">,</span>
        <span class="n">comm</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">mpiutil</span><span class="p">,</span> <span class="n">mpiarray</span><span class="p">,</span> <span class="n">memh5</span>

        <span class="c1"># Turn into actual list of files</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">tod</span><span class="o">.</span><span class="n">ensure_file_list</span><span class="p">(</span><span class="n">acq_files</span><span class="p">)</span>

        <span class="c1"># Construct communicator to use.</span>
        <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>

        <span class="c1"># Determine the total number of frequencies</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;index_map/freq&quot;</span><span class="p">][:])</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Calculate the global frequency selection</span>
        <span class="n">freq_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">freq_sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">freq_sel</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)))</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">)</span>

        <span class="c1"># Calculate the local frequency selection</span>
        <span class="n">n_local</span><span class="p">,</span> <span class="n">f_start</span><span class="p">,</span> <span class="n">f_end</span> <span class="o">=</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">split_local</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
        <span class="n">local_freq_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span>
            <span class="n">_convert_to_slice</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">[</span><span class="n">f_start</span><span class="p">:</span><span class="n">f_end</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="c1"># Load just the local part of the data.</span>
        <span class="n">local_data</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="n">acq_files</span><span class="o">=</span><span class="n">acq_files</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stack_sel</span><span class="o">=</span><span class="n">stack_sel</span><span class="p">,</span>
            <span class="n">prod_sel</span><span class="o">=</span><span class="n">prod_sel</span><span class="p">,</span>
            <span class="n">input_sel</span><span class="o">=</span><span class="n">input_sel</span><span class="p">,</span>
            <span class="n">freq_sel</span><span class="o">=</span><span class="n">local_freq_sel</span><span class="p">,</span>
            <span class="n">apply_gain</span><span class="o">=</span><span class="n">apply_gain</span><span class="p">,</span>
            <span class="n">renormalize</span><span class="o">=</span><span class="n">renormalize</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Datasets that we should convert into distribute ones</span>
        <span class="n">_DIST_DSETS</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;vis&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vis_flag&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vis_weight&quot;</span><span class="p">,</span>
            <span class="s2">&quot;gain&quot;</span><span class="p">,</span>
            <span class="s2">&quot;gain_coeff&quot;</span><span class="p">,</span>
            <span class="s2">&quot;frac_lost&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dataset_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;eval&quot;</span><span class="p">,</span>
            <span class="s2">&quot;evec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;erms&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Initialise distributed container</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">CorrData</span><span class="p">(</span><span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="c1"># Copy over the attributes</span>
        <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span>
            <span class="n">local_data</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">convert_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span>
        <span class="p">)</span>

        <span class="c1"># Iterate over the datasets and copy them over</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">old_dset</span> <span class="ow">in</span> <span class="n">local_data</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># If this should be distributed, extract the sections and turn them</span>
            <span class="c1"># into an MPIArray</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_DIST_DSETS</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">old_dset</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise just copy out the old dataset</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">old_dset</span><span class="p">[:]</span>

            <span class="c1"># Create the new dataset and copy over attributes</span>
            <span class="n">new_dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">array</span><span class="p">)</span>
            <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span>
                <span class="n">old_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                <span class="n">new_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                <span class="n">convert_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Iterate over the flags and copy them over</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">old_dset</span> <span class="ow">in</span> <span class="n">local_data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># If this should be distributed, extract the sections and turn them</span>
            <span class="c1"># into an MPIArray</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_DIST_DSETS</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">old_dset</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise just copy out the old dataset</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">old_dset</span><span class="p">[:]</span>

            <span class="c1"># Create the new dataset and copy over attributes</span>
            <span class="n">new_dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">array</span><span class="p">)</span>
            <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span>
                <span class="n">old_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                <span class="n">new_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                <span class="n">convert_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Copy over index maps</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index_map</span> <span class="ow">in</span> <span class="n">local_data</span><span class="o">.</span><span class="n">index_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get reference to actual array</span>
            <span class="n">index_map</span> <span class="o">=</span> <span class="n">index_map</span><span class="p">[:]</span>

            <span class="c1"># We need to explicitly stitch the frequency map back together</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span><span class="p">:</span>
                <span class="c1"># Gather all frequencies onto all nodes and stich together</span>
                <span class="n">freq_gather</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">index_map</span><span class="p">)</span>
                <span class="n">index_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">freq_gather</span><span class="p">)</span>

            <span class="c1"># Create index map</span>
            <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">index_map</span><span class="p">)</span>
            <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span><span class="n">local_data</span><span class="o">.</span><span class="n">index_attrs</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">index_attrs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="c1"># Copy over reverse maps</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">reverse_map</span> <span class="ow">in</span> <span class="n">local_data</span><span class="o">.</span><span class="n">reverse_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get reference to actual array</span>
            <span class="n">reverse_map</span> <span class="o">=</span> <span class="n">reverse_map</span><span class="p">[:]</span>

            <span class="c1"># Create index map</span>
            <span class="n">data</span><span class="o">.</span><span class="n">create_reverse_map</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">reverse_map</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="CorrData.from_acq_h5_fast">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrData.from_acq_h5_fast">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_acq_h5_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Efficiently read a CorrData file in a distributed fashion.</span>

<span class="sd">        This reads a single file from disk into a distributed container. In</span>
<span class="sd">        contrast to to `CorrData.from_acq_h5` it is more restrictive,</span>
<span class="sd">        allowing only contiguous slices of the frequency and time axes,</span>
<span class="sd">        and no down selection of the input/product/stack axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            File name to read. Only supports one file at a time.</span>
<span class="sd">        comm : MPI.Comm, optional</span>
<span class="sd">            MPI communicator to distribute over. By default this will</span>
<span class="sd">            use `MPI.COMM_WORLD`.</span>
<span class="sd">        freq_sel : slice, optional</span>
<span class="sd">            A selection over the frequency axis. Only `slice` objects</span>
<span class="sd">            are supported. If not set, read all frequencies.</span>
<span class="sd">        start, stop : int, optional</span>
<span class="sd">            Start and stop indexes of the time selection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : andata.CorrData</span>
<span class="sd">            The CorrData container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">misc</span><span class="p">,</span> <span class="n">mpiarray</span><span class="p">,</span> <span class="n">memh5</span>

        <span class="c1">## Datasets to read, if it&#39;s not listed here, it&#39;s not read at all</span>
        <span class="c1"># Datasets read by andata (should be small)</span>
        <span class="n">DSET_CORE</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;flags/inputs&quot;</span><span class="p">,</span> <span class="s2">&quot;flags/frac_lost&quot;</span><span class="p">,</span> <span class="s2">&quot;flags/dataset_id&quot;</span><span class="p">]</span>
        <span class="c1"># Datasets read directly and then inserted after the fact</span>
        <span class="c1"># (should have an input/product/stack axis, as axis=1)</span>
        <span class="n">DSETS_DIRECT</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;gain&quot;</span><span class="p">,</span> <span class="s2">&quot;flags/vis_weight&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>

        <span class="c1"># Check the frequency selection</span>
        <span class="k">if</span> <span class="n">freq_sel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq_sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;freq_sel must be a slice object, not &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">))</span>

        <span class="c1"># Create the time selection</span>
        <span class="n">time_sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

        <span class="c1"># Read the core dataset directly</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="n">fname</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">DSET_CORE</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">freq_sel</span><span class="o">=</span><span class="n">freq_sel</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">archive_version</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;archive_version&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;3.0.0&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fast read not supported for files with version &lt; 3.0.0&quot;</span><span class="p">)</span>

        <span class="c1"># Specify the selection to read from the file</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_sel</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">time_sel</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">misc</span><span class="o">.</span><span class="n">open_h5py_mpi</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ds_name</span> <span class="ow">in</span> <span class="n">DSETS_DIRECT</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ds_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fh</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Read dataset directly (distributed over input/product/stack axis) and</span>
                <span class="c1"># add to container</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">from_hdf5</span><span class="p">(</span>
                    <span class="n">fh</span><span class="p">,</span> <span class="n">ds_name</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="n">sel</span>
                <span class="p">)</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">ds_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">arr</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Copy over the attributes</span>
                <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span>
                    <span class="n">fh</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                    <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                    <span class="n">convert_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">ad</span></div>
</div>



<span class="c1"># For backwards compatibility.</span>
<span class="n">AnData</span> <span class="o">=</span> <span class="n">CorrData</span>


<div class="viewcode-block" id="HKData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HKData</span><span class="p">(</span><span class="n">BaseData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseData` for housekeeping data.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">atmel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the ATMEL board that took these data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        comp : :obj:`layout.component`</span>
<span class="sd">            The ATMEL component that took these data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">layout</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">layout</span>

        <span class="n">sn</span> <span class="o">=</span> <span class="s2">&quot;ATMEGA&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;atmel_id&quot;</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">layout</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sn</span><span class="o">=</span><span class="n">sn</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the list of muxes in the data.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mux</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mux</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;mux_address&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mux</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mux</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nmux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of muxes in the data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mux</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_mux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mux</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;mux_address&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">mux</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">d</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No dataset with mux = </span><span class="si">{</span><span class="n">mux</span><span class="si">}</span><span class="s2"> is present.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HKData.chan">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKData.chan">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mux</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to the list of channels in a given mux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mux : int</span>
<span class="sd">            A mux number. For housekeeping files with no multiplexing (e.g.,</span>
<span class="sd">            FLA&#39;s), leave this as ``-1``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : list</span>
<span class="sd">            The channels numbers.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`ValueError`</span>
<span class="sd">            Raised if **mux** does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chan</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chan</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chan</span><span class="p">[</span><span class="n">mux</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_mux</span><span class="p">(</span><span class="n">mux</span><span class="p">)</span>
            <span class="c1"># chan_map = ds.attrs[&quot;axis&quot;][0]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chan</span><span class="p">[</span><span class="n">mux</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chan</span><span class="p">[</span><span class="n">mux</span><span class="p">]</span></div>


<div class="viewcode-block" id="HKData.nchan">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKData.nchan">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nchan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mux</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to the number of channels in a given mux.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mux : int</span>
<span class="sd">            A mux number. For housekeeping files with no multiplexing (e.g.,</span>
<span class="sd">            FLA&#39;s), leave this as ``-1``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : int</span>
<span class="sd">            The number of channels</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`ValueError`</span>
<span class="sd">            Raised if **mux** does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chan</span><span class="p">(</span><span class="n">mux</span><span class="p">))</span></div>


<div class="viewcode-block" id="HKData.tod">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKData.tod">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">mux</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convenience access to a single time-ordered datastream (TOD).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan : int</span>
<span class="sd">            A channel number. (Generally, they should be in the range 0--7 for</span>
<span class="sd">            non-multiplexed data and 0--15 for multiplexed data.)</span>
<span class="sd">        mux : int</span>
<span class="sd">            A mux number. For housekeeping files with no multiplexing (e.g.,</span>
<span class="sd">            FLA&#39;s), leave this as ``-1``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tod : :obj:`numpy.array`</span>
<span class="sd">            A 1D array of values for the requested channel/mux combination. Note</span>
<span class="sd">            that a reference to the data in the dataset is returned; this method</span>
<span class="sd">            does not make a copy.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`ValueError`</span>
<span class="sd">            Raised if one of **chan** or **mux** is not present in any dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_mux</span><span class="p">(</span><span class="n">mux</span><span class="p">)</span>
        <span class="n">chan_map</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">chan_map</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No channel </span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s2"> exists for mux </span><span class="si">{</span><span class="n">mux</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Return the data.</span>
        <span class="k">return</span> <span class="n">ds</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>
        <span class="c1"># Save a reference to the first file to get index map information for</span>
        <span class="c1"># later.</span>
        <span class="n">f_first</span> <span class="o">=</span> <span class="n">acq_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Define dataset filter to do the transpose.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">dset_filter</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="n">HK_DATASET_NAMES</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">),</span> <span class="n">name</span><span class="p">):</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="c1"># Do the transpose.</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">MemDatasetCommon</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span>
                <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">convert_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span>
            <span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="n">andata_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKData</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="n">andata_objs</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">dataset_filter</span><span class="o">=</span><span class="n">dset_filter</span><span class="p">,</span>
            <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Some index maps saved as attributes, so convert to datasets.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f_first</span><span class="p">[</span><span class="s2">&quot;index_map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="HKData.from_acq_h5">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKData.from_acq_h5">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_acq_h5</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_group</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert acquisition format hdf5 data to analysis data object.</span>

<span class="sd">        This method overloads the one in BaseData.</span>

<span class="sd">        Reads hdf5 data produced by the acquisition system and converts it to</span>
<span class="sd">        analysis format in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acq_files : filename, `h5py.File` or list there-of or filename pattern</span>
<span class="sd">            Files to convert from acquisition format to analysis format.</span>
<span class="sd">            Filename patterns with wild cards (e.g. &quot;foo*.h5&quot;) are supported.</span>
<span class="sd">        start : integer, optional</span>
<span class="sd">            What frame to start at in the full set of files.</span>
<span class="sd">        stop : integer, optional</span>
<span class="sd">            What frame to stop at in the full set of files.</span>
<span class="sd">        datasets : list of strings</span>
<span class="sd">            Names of datasets to include from acquisition files. Default is to</span>
<span class="sd">            include all datasets found in the acquisition files.</span>
<span class="sd">        out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">            Underlying hdf5 like container that will store the data for the</span>
<span class="sd">            BaseData instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Examples are analogous to those of :meth:`CorrData.from_acq_h5`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="n">acq_files</span><span class="o">=</span><span class="n">acq_files</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="HKPData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKPData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HKPData</span><span class="p">(</span><span class="n">memh5</span><span class="o">.</span><span class="n">MemDiskGroup</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseData` for housekeeping data.&quot;&quot;&quot;</span>

    <span class="c1"># Convert strings to/from unicode on load and save</span>
    <span class="n">convert_attribute_strings</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">convert_dataset_strings</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="HKPData.metrics">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKPData.metrics">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metrics</span><span class="p">(</span><span class="n">acq_files</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the names of the metrics contained within the files.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acq_files: list</span>
<span class="sd">            List of acquisition filenames.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metrics : list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

        <span class="n">metric_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">acq_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">acq_files</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">metric_names</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">metric_names</span></div>


<div class="viewcode-block" id="HKPData.from_acq_h5">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKPData.from_acq_h5">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_acq_h5</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load in the housekeeping files.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acq_files : list</span>
<span class="sd">            List of files to load.</span>
<span class="sd">        start, stop : datetime or float, optional</span>
<span class="sd">            Start and stop times for the range of data to load. Default is all.</span>
<span class="sd">        metrics : list</span>
<span class="sd">            Names of metrics to load. Default is all.</span>
<span class="sd">        datasets : list</span>
<span class="sd">            Synonym for metrics (the value of metrics will take precedence).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : HKPData</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span> <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">datasets</span>

        <span class="k">if</span> <span class="s2">&quot;mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;ondisk&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ondisk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">acq_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">acq_files</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">acq_files</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
                <span class="n">f</span><span class="p">,</span>
                <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
                <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">acq_files</span>
        <span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">filter_time_range</span><span class="p">(</span><span class="n">dset</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Trim dataset to the specified time range.&quot;&quot;&quot;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tstart</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">time</span> <span class="o">&gt;=</span> <span class="n">tstart</span>

            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tstop</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="n">tstop</span>

            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">filter_file</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Filter a file&#39;s data down to the requested metrics</span>
<span class="sd">            and time range.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">metrics_to_copy</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">metrics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metrics_to_copy</span> <span class="o">=</span> <span class="n">metrics_to_copy</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>

            <span class="n">filtered_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">dset_name</span> <span class="ow">in</span> <span class="n">metrics_to_copy</span><span class="p">:</span>
                <span class="n">filtered_data</span><span class="p">[</span><span class="n">dset_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_time_range</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">dset_name</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">filtered_data</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_full_dtype</span><span class="p">(</span><span class="n">dset_name</span><span class="p">,</span> <span class="n">filtered_data</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns a numpy.dtype object with the union of all columns</span>
<span class="sd">            from all files. Also returns the total length of the data set</span>
<span class="sd">            (metric) including all files.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">all_columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># review number of times and columns:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)):</span>
                <span class="c1"># If this file has this data set:</span>
                <span class="k">if</span> <span class="n">dset_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="c1"># Increase the length of the data:</span>
                <span class="n">length</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">])</span>
                <span class="c1"># Add &#39;time&#39; and &#39;value&#39; columns first:</span>
                <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_columns</span><span class="p">:</span>
                    <span class="n">all_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
                    <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;value&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_columns</span><span class="p">:</span>
                    <span class="n">all_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
                    <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                <span class="c1"># Add new column if any:</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_columns</span><span class="p">:</span>
                        <span class="n">all_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                        <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

            <span class="n">data_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">all_columns</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">all_types</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_columns</span><span class="p">))]</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">data_dtype</span><span class="p">,</span> <span class="n">length</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_full_attrs</span><span class="p">(</span><span class="n">dset_name</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Creates a &#39;full_attrs&#39; dictionary of all attributes and all</span>
<span class="sd">            possible values they can take, from all the files, for a</span>
<span class="sd">            particular data set (metric). Also returns an &#39;index_remap&#39;</span>
<span class="sd">            list of dictionaries to remap indices of values in different</span>
<span class="sd">            files.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">full_attrs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary of attributes</span>
            <span class="n">index_remap</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of dictionaries (one per file)</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">fl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dset_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fl</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">index_remap</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>  <span class="c1"># List of dictionaries (one per file)</span>
                <span class="k">for</span> <span class="n">att</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">fl</span><span class="p">[</span><span class="n">dset_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># Reserve zeroeth entry for N/A</span>
                    <span class="n">index_remap</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">att</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">att</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">full_attrs</span><span class="p">:</span>
                        <span class="n">full_attrs</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">full_attrs</span><span class="p">[</span><span class="n">att</span><span class="p">]:</span>
                            <span class="n">full_attrs</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_attrs</span><span class="p">[</span><span class="n">att</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
                        <span class="c1"># Index of idx&#39;th val in full_attrs[att]:</span>
                        <span class="n">new_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">full_attrs</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># zero is for N/A:</span>
                        <span class="n">index_remap</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">att</span><span class="p">][</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_idx</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">full_attrs</span><span class="p">,</span> <span class="n">index_remap</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_full_data</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">data_dtype</span><span class="p">,</span> <span class="n">index_remap</span><span class="p">,</span> <span class="n">filtered_data</span><span class="p">,</span> <span class="n">dset_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns the full data matrix as a structured array. Values are</span>
<span class="sd">            modified when necessary acording to &#39;index_remap&#39; to correspond</span>
<span class="sd">            to the final positions in the &#39;full_attrs&#39;.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">full_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">data_dtype</span><span class="p">)</span>

            <span class="n">curr_ent</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current entry we are in the full data file</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)):</span>
                <span class="n">len_fl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">])</span>
                <span class="n">curr_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">curr_ent</span> <span class="p">:</span> <span class="n">curr_ent</span> <span class="o">+</span> <span class="n">len_fl</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dset_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">data_dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="c1"># Length of this file:</span>
                    <span class="k">if</span> <span class="n">att</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]:</span>
                        <span class="c1"># No need to remap values:</span>
                        <span class="n">full_data</span><span class="p">[</span><span class="n">att</span><span class="p">][</span><span class="n">curr_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">][</span><span class="n">att</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">index_remap</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                        <span class="c1"># Needs remapping values</span>
                        <span class="c1"># (need to remove 1 beause indices are 1-based):</span>
                        <span class="n">full_data</span><span class="p">[</span><span class="n">att</span><span class="p">][</span><span class="n">curr_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_remap</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">att</span><span class="p">][</span>
                            <span class="n">filtered_data</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">dset_name</span><span class="p">][</span><span class="n">att</span><span class="p">]</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Column not in file. Fill with zeros:</span>
                        <span class="n">full_data</span><span class="p">[</span><span class="n">att</span><span class="p">][</span><span class="n">curr_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">len_fl</span><span class="p">)</span>
                <span class="c1"># Update current entry value:</span>
                <span class="n">curr_ent</span> <span class="o">=</span> <span class="n">curr_ent</span> <span class="o">+</span> <span class="n">len_fl</span>

            <span class="k">return</span> <span class="n">full_data</span>

        <span class="n">hkp_data</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>

        <span class="n">filtered_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">filtered_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_file</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">dset_name</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">data_dtype</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">get_full_dtype</span><span class="p">(</span><span class="n">dset_name</span><span class="p">,</span> <span class="n">filtered_data</span><span class="p">)</span>

            <span class="c1"># Create the full dictionary of all attributes:</span>
            <span class="n">full_attrs</span><span class="p">,</span> <span class="n">index_remap</span> <span class="o">=</span> <span class="n">get_full_attrs</span><span class="p">(</span><span class="n">dset_name</span><span class="p">,</span> <span class="n">files</span><span class="p">)</span>

            <span class="c1"># Populate the data here.( Need full attrs)</span>
            <span class="n">full_data</span> <span class="o">=</span> <span class="n">get_full_data</span><span class="p">(</span>
                <span class="n">length</span><span class="p">,</span> <span class="n">data_dtype</span><span class="p">,</span> <span class="n">index_remap</span><span class="p">,</span> <span class="n">filtered_data</span><span class="p">,</span> <span class="n">dset_name</span>
            <span class="p">)</span>
            <span class="n">new_dset</span> <span class="o">=</span> <span class="n">hkp_data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dset_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">full_data</span><span class="p">)</span>

            <span class="c1"># Populate attrs</span>
            <span class="k">for</span> <span class="n">att</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">full_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hkp_data</span></div>


<div class="viewcode-block" id="HKPData.select">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKPData.select">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the metric as a pandas time-series DataFrame.</span>

<span class="sd">        Requires Pandas to be installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metric_name : string</span>
<span class="sd">            Name of metric to generate DataFrame for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

        <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">((</span><span class="n">dset</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="p">))</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">fields</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">}</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>

        <span class="k">for</span> <span class="n">label_name</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">label_ind</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="n">label_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">label_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">label_ind</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">label_name</span><span class="p">][</span><span class="n">label_ind</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">cols</span><span class="p">[</span><span class="n">label_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">label_val</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="HKPData.resample">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKPData.resample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">unstack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample the metric onto a regular grid of time.</span>

<span class="sd">        This internally uses the Pandas resampling functionality so that</span>
<span class="sd">        documentation is a useful reference. This will return the metric with</span>
<span class="sd">        the labels as a series of multi-level columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metric_name : str</span>
<span class="sd">            Name of metric to resample.</span>
<span class="sd">        rule : str</span>
<span class="sd">            The set of times to resample onto (example &#39;30S&#39;, &#39;1Min&#39;, &#39;2D&#39;). See</span>
<span class="sd">            the pandas docs for a full description.</span>
<span class="sd">        how : str or callable, optional</span>
<span class="sd">            How should we combine samples to regrid the data? This takes any</span>
<span class="sd">            valid argument for the the pandas apply method. Useful options are</span>
<span class="sd">            `&#39;mean&#39;`, `&#39;sum&#39;`, `&#39;min&#39;`, `&#39;max&#39;` and `&#39;std&#39;`.</span>
<span class="sd">        unstack : bool, optional</span>
<span class="sd">            Unstack the data, i.e. return with the labels as hierarchial columns.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Any remaining kwargs are passed to the `pandas.DataFrame.resample`</span>
<span class="sd">            method to give fine grained control of the resampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : pandas.DataFrame</span>
<span class="sd">            A dataframe resampled onto a regular grid. Labels now appear as part</span>
<span class="sd">            of multi-level columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">metric_name</span><span class="p">)</span>

        <span class="n">group_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">})</span>

        <span class="n">resampled_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_columns</span><span class="p">)</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">how</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unstack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">resampled_df</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">group_columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resampled_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">group_columns</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="WeatherData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.WeatherData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WeatherData</span><span class="p">(</span><span class="n">BaseData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseData` for weather data.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Needs to be able to extrac times from both mingun_weather files</span>
<span class="sd">        and chime_weather files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;station_time_blockhouse&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;For easy access to outside weather station temperature.</span>
<span class="sd">        Needs to be able to extrac temperatures from both mingun_weather files</span>
<span class="sd">        and chime_weather files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;blockhouse&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;blockhouse&quot;</span><span class="p">][</span><span class="s2">&quot;outTemp&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;outTemp&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="WeatherData.dataset_name_allowed">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.WeatherData.dataset_name_allowed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dataset_name_allowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Permits datasets in the root and &#39;blockhouse&#39; groups.&quot;&quot;&quot;</span>

        <span class="n">parent_name</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">posixpath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">parent_name</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span> <span class="ow">or</span> <span class="n">parent_name</span> <span class="o">==</span> <span class="s2">&quot;/blockhouse&quot;</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="WeatherData.group_name_allowed">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.WeatherData.group_name_allowed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_name_allowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Permits only the &quot;blockhouse&quot; group.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;/blockhouse&quot;</span> <span class="k">else</span> <span class="kc">False</span></div>
</div>



<div class="viewcode-block" id="RawADCData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.RawADCData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RawADCData</span><span class="p">(</span><span class="n">BaseData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseData` for raw ADC data.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>
        <span class="c1"># Define dataset filter to do the transpose.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">dset_filter</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">MemDatasetCommon</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span>
                    <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
                    <span class="n">convert_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dataset (</span><span class="si">{</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;has unexpected shape [</span><span class="si">{</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">].&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="n">andata_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">RawADCData</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="n">andata_objs</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">dataset_filter</span><span class="o">=</span><span class="n">dset_filter</span><span class="p">,</span>
            <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="GainFlagData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.GainFlagData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GainFlagData</span><span class="p">(</span><span class="n">BaseData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseData` for gain, digitalgain, and flag input acquisitions.</span>

<span class="sd">    These acquisitions consist of a collection of updates to the real-time</span>
<span class="sd">    pipeline ordered chronologically.  In most cases the updates do not</span>
<span class="sd">    occur at a regular cadence.  The time that each update occured can be</span>
<span class="sd">    accessed via `self.index_map[&#39;update_time&#39;]`.  In addition, each update</span>
<span class="sd">    is given a unique update ID that can be accessed via</span>
<span class="sd">    `self.datasets[&#39;update_id&#39;]` and can be searched using the</span>
<span class="sd">    `self.search_update_id` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GainFlagData.resample">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.GainFlagData.resample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dataset resampled at specific times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : string</span>
<span class="sd">            Name of the dataset to resample.</span>
<span class="sd">        timestamp : `np.ndarray`</span>
<span class="sd">            Unix timestamps.</span>
<span class="sd">        transpose : bool</span>
<span class="sd">            Tranpose the data such that time is the fastest varying axis.</span>
<span class="sd">            By default time will be the slowest varying axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : np.ndarray</span>
<span class="sd">            The dataset resampled at the desired times and transposed if requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_update_time</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dataset</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">dset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dset</span></div>


<div class="viewcode-block" id="GainFlagData.search_update_time">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.GainFlagData.search_update_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">search_update_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the index into the `update_time` axis that is valid for specific times.</span>

<span class="sd">        For each time returns the most recent update the occured before that time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp : `np.ndarray` of unix timestamp</span>
<span class="sd">            Unix timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : `np.ndarray` of `dtype = int`</span>
<span class="sd">            Index into the `update_time` axis that will yield values</span>
<span class="sd">            that are valid for the requested timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot request timestamps before the earliest update_time.&quot;</span>
            <span class="p">)</span>

        <span class="n">dmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dmax</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Requested timestamps are after the latest update_time &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;by as much as </span><span class="si">{</span><span class="n">dmax</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">3600.0</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> hours.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="GainFlagData.search_update_id">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.GainFlagData.search_update_id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">search_update_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">is_regex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the index into the `update_time` axis for a particular `update_id`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pattern : str</span>
<span class="sd">            The desired `update_id` or a glob pattern to search.</span>
<span class="sd">        is_regex : bool</span>
<span class="sd">            Set to True if `pattern` is a regular expression.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : `np.ndarray` of `dtype = int`</span>
<span class="sd">            Index into the `update_time` axis that will yield all</span>
<span class="sd">            updates whose `update_id` matches the requested pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">fnmatch</span>

        <span class="n">ptn</span> <span class="o">=</span> <span class="n">pattern</span> <span class="k">if</span> <span class="n">is_regex</span> <span class="k">else</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">ptn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">uid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_id</span><span class="p">[:])</span> <span class="k">if</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">uid</span><span class="p">)]</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `index_map[&#39;update_time&#39;]` for `caput.tod` functionality.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;update_time&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ntime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of updates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;update_time&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correlator inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ninput</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of correlator inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aliases the `update_id` dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;update_id&quot;</span><span class="p">]</span></div>



<div class="viewcode-block" id="FlagInputData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.FlagInputData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FlagInputData</span><span class="p">(</span><span class="n">GainFlagData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`GainFlagData` for flaginput acquisitions.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aliases the `flag` dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary that allow look up of source flags based on source name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_flags&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;source_flags&quot;</span><span class="p">][:,</span> <span class="n">kk</span><span class="p">,</span> <span class="p">:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_source_flags</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_flags</span>

<div class="viewcode-block" id="FlagInputData.get_source_index">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.FlagInputData.get_source_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_source_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index into the `source` axis for a given source name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source_name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="GainData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.GainData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GainData</span><span class="p">(</span><span class="n">GainFlagData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`GainFlagData` for gain and digitalgain acquisitions.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The spectral frequency axis as bin centres in MHz.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of frequency bins.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">])</span></div>



<div class="viewcode-block" id="CalibrationGainData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CalibrationGainData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalibrationGainData</span><span class="p">(</span><span class="n">GainData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`GainData` for gain acquisitions.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Names of the sources of gains.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nsource</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of sources of gains.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aliases the `gain` dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aliases the `weight` dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source_gains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary that allows look up of source gains based on source name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_gains&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;source_gains&quot;</span><span class="p">][:,</span> <span class="n">kk</span><span class="p">,</span> <span class="p">:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_source_gains</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_gains</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary that allows look up of source weights based on source name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_source_weights&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;source_weights&quot;</span><span class="p">][:,</span> <span class="n">kk</span><span class="p">,</span> <span class="p">:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_source_weights</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ro_dict</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_weights</span>

<div class="viewcode-block" id="CalibrationGainData.get_source_index">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CalibrationGainData.get_source_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_source_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index into the `source` axis for a given source name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">source_name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DigitalGainData">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.DigitalGainData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DigitalGainData</span><span class="p">(</span><span class="n">GainData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`GainData` for digitalgain acquisitions.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gain_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The coefficient of the digital gain applied to the channelized data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain_coeff&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gain_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The exponent of the digital gain applied to the channelized data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain_exp&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unix timestamp indicating when the digital gain was computed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;compute_time&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The digital gain applied to the channelized data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain_coeff&quot;</span><span class="p">][:]</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">**</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain_exp&quot;</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="BaseReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseReader</span><span class="p">(</span><span class="n">tod</span><span class="o">.</span><span class="n">Reader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides high level reading of CHIME data.</span>

<span class="sd">    You do not want to use this class, but rather one of its inherited classes</span>
<span class="sd">    (:class:`CorrReader`, :class:`HKReader`, :class:`WeatherReader`).</span>

<span class="sd">    Parses and stores meta-data from file headers allowing for the</span>
<span class="sd">    interpretation and selection of the data without reading it all from disk.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    files : filename, `h5py.File` or list there-of or filename pattern</span>
<span class="sd">        Files containing data. Filename patterns with wild cards (e.g.</span>
<span class="sd">        &quot;foo*.h5&quot;) are supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">BaseData</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="c1"># If files is a filename, or pattern, turn into list of files.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">files</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_empty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_class</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="p">())</span>

        <span class="c1"># Fetch all meta data.</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_empty</span><span class="o">.</span><span class="n">time</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="n">_get_dataset_names</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Set the metadata attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_files</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datasets</span> <span class="o">=</span> <span class="n">datasets</span>
        <span class="c1"># Set the default selections of the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_sel</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_sel</span> <span class="o">=</span> <span class="n">datasets</span>

<div class="viewcode-block" id="BaseReader.select_time_range">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseReader.select_time_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_time_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets :attr:`~Reader.time_sel` to include a time range.</span>

<span class="sd">        The times from the samples selected will have bin centre timestamps</span>
<span class="sd">        that are bracketed by the given *start_time* and *stop_time*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time : float or :class:`datetime.datetime`</span>
<span class="sd">            If a float, this is a Unix/POSIX time. Affects the first element of</span>
<span class="sd">            :attr:`~Reader.time_sel`.  Default leaves it unchanged.</span>
<span class="sd">        stop_time : float or :class:`datetime.datetime`</span>
<span class="sd">            If a float, this is a Unix/POSIX time. Affects the second element</span>
<span class="sd">            of :attr:`~Reader.time_sel`.  Default leaves it unchanged.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">select_time_range</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">stop_time</span><span class="o">=</span><span class="n">stop_time</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseReader.read">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.BaseReader.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the selected data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">            Underlying hdf5 like container that will store the data for the</span>
<span class="sd">            BaseData instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : :class:`BaseData`</span>
<span class="sd">            Data read from :attr:`~Reader.files` based on the selections given</span>
<span class="sd">            in :attr:`~Reader.time_sel`, :attr:`~Reader.prod_sel`, and</span>
<span class="sd">            :attr:`~Reader.freq_sel`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_class</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">stop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">datasets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_sel</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CorrReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for correlator data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">CorrData</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="n">data_empty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_empty</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">prod</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">data_empty</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prod</span> <span class="o">=</span> <span class="n">prod</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod_sel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_sel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_sel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Create apply_gain and renormalize attributes,</span>
        <span class="c1"># which are passed to CorrData.from_acq_h5() when</span>
        <span class="c1"># the read() method is called.  This gives the</span>
        <span class="c1"># user the ability to turn off apply_gain and</span>
        <span class="c1"># renormalize when using Reader.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_gain</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distributed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Insert virtual &#39;gain&#39; dataset if required parent datasets are present.</span>
        <span class="c1"># We could be more careful about this, but I think this will always</span>
        <span class="c1"># work.</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datasets</span>
        <span class="c1"># if (&#39;gain_coeff&#39; in datasets and &#39;gain_exp&#39; in datasets):</span>
        <span class="n">datasets</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;gain&quot;</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datasets</span> <span class="o">=</span> <span class="n">datasets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_sel</span> <span class="o">=</span> <span class="n">datasets</span>

    <span class="c1"># Properties</span>
    <span class="c1"># ----------</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correlation products in data files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prod</span><span class="p">[:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correlator inputs in data files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span><span class="p">[:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral frequency bin centres in data files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">[:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prod_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Which correlation products to read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prod_sel : 1D data selection</span>
<span class="sd">            Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">            along the correlation product axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prod_sel</span>

    <span class="nd">@prod_sel</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prod_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check to make sure this is a valid index for the product axis.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;*input_sel* is set and cannot specify both *prod_sel*&quot;</span>
                    <span class="s2">&quot; and *input_sel*.&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prod_sel</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Which correlator intputs to read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        input_sel : 1D data selection</span>
<span class="sd">            Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">            along the correlation product axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_sel</span>

    <span class="nd">@input_sel</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check to make sure this is a valid index for the product axis.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s2">&quot;chan_id&quot;</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;*prod_sel* is set and cannot specify both *prod_sel*&quot;</span>
                    <span class="s2">&quot; and *input_sel*.&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_sel</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Which frequencies to read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        freq_sel : 1D data selection</span>
<span class="sd">            Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">            along the frequency axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_sel</span>

    <span class="nd">@freq_sel</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq_sel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check to make sure this is a valid index for the frequency axis.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq_sel</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Data Selection Methods</span>
    <span class="c1"># ----------------------</span>

<div class="viewcode-block" id="CorrReader.select_prod_pairs">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader.select_prod_pairs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_prod_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pairs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets :attr:`~Reader.prod_sel` to include given product pairs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pairs : list of integer pairs</span>
<span class="sd">            Input pairs to be included.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">input_a</span><span class="p">,</span> <span class="n">input_b</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">)):</span>
                <span class="n">p_input_a</span><span class="p">,</span> <span class="n">p_input_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">input_a</span> <span class="o">==</span> <span class="n">p_input_a</span> <span class="ow">and</span> <span class="n">input_b</span> <span class="o">==</span> <span class="n">p_input_b</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">input_a</span> <span class="o">==</span> <span class="n">p_input_b</span> <span class="ow">and</span> <span class="n">input_b</span> <span class="o">==</span> <span class="n">p_input_a</span>
                <span class="p">):</span>
                    <span class="n">sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod_sel</span> <span class="o">=</span> <span class="n">sel</span></div>


<div class="viewcode-block" id="CorrReader.select_prod_autos">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader.select_prod_autos">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_prod_autos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets :attr:`~Reader.prod_sel` to only auto-correlations.&quot;&quot;&quot;</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">prod</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">prod</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod_sel</span> <span class="o">=</span> <span class="n">sel</span></div>


<div class="viewcode-block" id="CorrReader.select_prod_by_input">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader.select_prod_by_input">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_prod_by_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets :attr:`~Reader.prod_sel` to only products with given input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input : integer</span>
<span class="sd">            Correlator input number.  All correlation products with</span>
<span class="sd">            this input as one of the pairs are selected.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">prod</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">input</span> <span class="ow">or</span> <span class="n">prod</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">input</span><span class="p">:</span>
                <span class="n">sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod_sel</span> <span class="o">=</span> <span class="n">sel</span></div>


<div class="viewcode-block" id="CorrReader.select_freq_range">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader.select_freq_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_freq_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq_low</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets :attr:`~Reader.freq_sel` to given physical frequency range.</span>

<span class="sd">        Frequencies selected will have bin centres bracked by provided range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq_low : float</span>
<span class="sd">            Lower end of the frequency range in MHz.  Default is the lower edge</span>
<span class="sd">            of the band.</span>
<span class="sd">        freq_high : float</span>
<span class="sd">            Upper end of the frequency range in MHz.  Default is the upper edge</span>
<span class="sd">            of the band.</span>
<span class="sd">        freq_step : float</span>
<span class="sd">            How much bandwidth to skip over between samples in MHz. This value</span>
<span class="sd">            is approximate. Default is to include all samples in given range.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">)))</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">freq_step</span> <span class="o">//</span> <span class="n">df</span><span class="p">)</span>
        <span class="c1"># Noting that frequencies are reverse ordered in datasets.</span>
        <span class="k">if</span> <span class="n">freq_low</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">nfreq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="n">freq_low</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">freq_high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="n">freq_high</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Slight tweak to behaviour if step is not unity, lining up edge on</span>
        <span class="c1"># freq_low instead of freq_high.</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]</span></div>


<div class="viewcode-block" id="CorrReader.select_freq_physical">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader.select_freq_physical">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_freq_physical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets :attr:`~Reader.freq_sel` to include given physical frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frequencies : list of floats</span>
<span class="sd">            Frequencies to select. Physical frequencies are matched to indices</span>
<span class="sd">            on a best match basis.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">freq_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span>
        <span class="n">freq_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
        <span class="n">n_sel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
        <span class="n">diff_freq</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">freq_centre</span> <span class="o">-</span> <span class="n">frequencies</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="n">match_mask</span> <span class="o">=</span> <span class="n">diff_freq</span> <span class="o">&lt;</span> <span class="n">freq_width</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">freq_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sel</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">match_mask</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">first_match</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No match for frequency </span><span class="si">{frequencies[ii]}</span><span class="s2"> MHz.&quot;</span><span class="p">)</span>
            <span class="n">freq_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_match</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_sel</span> <span class="o">=</span> <span class="n">freq_inds</span></div>


    <span class="c1"># Data Reading</span>
    <span class="c1"># ------------</span>

<div class="viewcode-block" id="CorrReader.read">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CorrReader.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the selected data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">            Underlying hdf5 like container that will store the data for the</span>
<span class="sd">            BaseData instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : :class:`BaseData`</span>
<span class="sd">            Data read from :attr:`~Reader.files` based on the selections given</span>
<span class="sd">            in :attr:`~Reader.time_sel`, :attr:`~Reader.prod_sel`, and</span>
<span class="sd">            :attr:`~Reader.freq_sel`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dsets</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_sel</span><span class="p">)</span>

        <span class="c1"># Add in virtual gain dataset</span>
        <span class="c1"># This is done in earlier now, in self.datasets.</span>
        <span class="c1"># if (&#39;gain_coeff&#39; in dsets and &#39;gain_exp&#39; in dsets):</span>
        <span class="c1">#    dsets += (&#39;gain&#39;,)</span>

        <span class="k">return</span> <span class="n">CorrData</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">stop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">prod_sel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prod_sel</span><span class="p">,</span>
            <span class="n">freq_sel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_sel</span><span class="p">,</span>
            <span class="n">input_sel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sel</span><span class="p">,</span>
            <span class="n">apply_gain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">,</span>
            <span class="n">renormalize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">renormalize</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">dsets</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<span class="c1"># For backwards compatibility.</span>
<span class="n">Reader</span> <span class="o">=</span> <span class="n">CorrReader</span>


<div class="viewcode-block" id="HKReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HKReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for HK data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">HKData</span></div>



<div class="viewcode-block" id="HKPReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.HKPReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HKPReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for HKP data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">HKPData</span></div>



<div class="viewcode-block" id="WeatherReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.WeatherReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WeatherReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for weather data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">WeatherData</span></div>



<div class="viewcode-block" id="FlagInputReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.FlagInputReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FlagInputReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for input flag data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">FlagInputData</span></div>



<div class="viewcode-block" id="CalibrationGainReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.CalibrationGainReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalibrationGainReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for calibration gain data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">CalibrationGainData</span></div>



<div class="viewcode-block" id="DigitalGainReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.DigitalGainReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DigitalGainReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for digital gain data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">DigitalGainData</span></div>



<div class="viewcode-block" id="RawADCReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.RawADCReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RawADCReader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for raw ADC data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">RawADCData</span></div>



<div class="viewcode-block" id="AnDataError">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.AnDataError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AnDataError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exception raised when something unexpected happens with the data.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<span class="c1"># Functions</span>
<span class="c1"># ---------</span>

<span class="c1"># In caput now.</span>
<span class="n">concatenate</span> <span class="o">=</span> <span class="n">tod</span><span class="o">.</span><span class="n">concatenate</span>


<div class="viewcode-block" id="subclass_from_obj">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.subclass_from_obj">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subclass_from_obj</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pick a subclass of :class:`BaseData` based on an input object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : subclass of :class:`BaseData` (class, not an instance)</span>
<span class="sd">          Default class to return.</span>
<span class="sd">    obj : :class:`h5py.Group`, filename, :class:`memh5.Group` or</span>
<span class="sd">          :class:`BaseData` object from which to determine the appropriate</span>
<span class="sd">          subclass of :class:`AnData`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If obj is a filename, open it and recurse.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subclass_from_obj</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="n">new_cls</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="n">acquisition_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">acquisition_type</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;acquisition_type&quot;</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="n">acquisition_type</span> <span class="o">==</span> <span class="s2">&quot;corr&quot;</span><span class="p">:</span>
        <span class="n">new_cls</span> <span class="o">=</span> <span class="n">CorrData</span>
    <span class="k">elif</span> <span class="n">acquisition_type</span> <span class="o">==</span> <span class="s2">&quot;hk&quot;</span><span class="p">:</span>
        <span class="n">new_cls</span> <span class="o">=</span> <span class="n">HKData</span>
    <span class="k">elif</span> <span class="n">acquisition_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">BaseData</span><span class="p">):</span>
            <span class="n">new_cls</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="k">return</span> <span class="n">new_cls</span></div>



<span class="c1"># Private Functions</span>
<span class="c1"># -----------------</span>

<span class="c1"># Utilities</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_open_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">opened</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure that files are open, keeping a record of what was done.</span>

<span class="sd">    The arguments are modified in-place instead of returned, so that partial</span>
<span class="sd">    work is recorded in the event of an error.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">this_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">files</span><span class="p">)):</span>
        <span class="c1"># Sort out how to get an open hdf5 file.</span>
        <span class="n">open_file</span><span class="p">,</span> <span class="n">was_opened</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">get_h5py_File</span><span class="p">(</span><span class="n">this_file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">opened</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">was_opened</span>
        <span class="n">files</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">open_file</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_1D_selection</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong number of indices.&quot;</span><span class="p">)</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:]</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">selection</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">selection</span> <span class="p">:</span> <span class="n">selection</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannont be converted to a 1D selection.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">selection</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data selections may only be one dimensional.&quot;</span><span class="p">)</span>
        <span class="c1"># The following is more efficient and solves h5py issue #425. Converts</span>
        <span class="c1"># to integer selection.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">selection</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;h5py requires sorted non-duplicate selections.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">selection</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array selections must be integer or boolean type.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">selection</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="c1"># This is a workaround for h5py/h5py#1750</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">selection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_slice</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">uniq_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">selection</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniq_step</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">uniq_step</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">selection</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">uniq_step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">selection</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_dataset_names</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">toclose</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">get_h5py_File</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dataset_names</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                <span class="n">dataset_names</span> <span class="o">+=</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
        <span class="k">if</span> <span class="s2">&quot;blockhouse&quot;</span> <span class="ow">in</span> <span class="n">f</span> <span class="ow">and</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;blockhouse&quot;</span><span class="p">]):</span>
            <span class="c1"># chime_weather datasets are inside group &quot;blockhouse&quot;</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;blockhouse&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;blockhouse&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]):</span>
                    <span class="n">dataset_names</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;blockhouse/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,)</span>
        <span class="k">if</span> <span class="s2">&quot;flags&quot;</span> <span class="ow">in</span> <span class="n">f</span> <span class="ow">and</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]):</span>
                    <span class="n">dataset_names</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;flags/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">toclose</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">dataset_names</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_resolve_stack_prod_input_sel</span><span class="p">(</span>
    <span class="n">stack_sel</span><span class="p">,</span> <span class="n">stack_map</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">,</span> <span class="n">input_sel</span><span class="p">,</span> <span class="n">input_map</span>
<span class="p">):</span>
    <span class="n">nsels</span> <span class="o">=</span> <span class="p">(</span><span class="n">stack_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">prod_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">input_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nsels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Only one of *stack_sel*, *input_sel*, and *prod_sel* may be specified.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">nsels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stack_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">stack_sel</span><span class="p">)</span>
        <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">)</span>
        <span class="n">input_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">input_sel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prod_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">)</span>
            <span class="c1"># Choose inputs involved in selected products.</span>
            <span class="n">input_sel</span> <span class="o">=</span> <span class="n">_input_sel_from_prod_sel</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">)</span>
            <span class="n">stack_sel</span> <span class="o">=</span> <span class="n">_stack_sel_from_prod_sel</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">input_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">input_sel</span><span class="p">)</span>
            <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">_prod_sel_from_input_sel</span><span class="p">(</span><span class="n">input_sel</span><span class="p">,</span> <span class="n">input_map</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">)</span>
            <span class="n">stack_sel</span> <span class="o">=</span> <span class="n">_stack_sel_from_prod_sel</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># stack_sel</span>
            <span class="n">stack_sel</span> <span class="o">=</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">stack_sel</span><span class="p">)</span>
            <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">_prod_sel_from_stack_sel</span><span class="p">(</span><span class="n">stack_sel</span><span class="p">,</span> <span class="n">stack_map</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">)</span>
            <span class="n">input_sel</span> <span class="o">=</span> <span class="n">_input_sel_from_prod_sel</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">)</span>

        <span class="c1"># Now we need to rejig the index maps for the subsets of the inputs,</span>
        <span class="c1"># prods.</span>
        <span class="n">stack_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack_map</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">stack_sel</span><span class="p">]</span>
        <span class="c1"># prod_inds = np.arange(len(prod_map), dtype=int)[prod_sel]  # never used</span>
        <span class="n">input_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_map</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">input_sel</span><span class="p">]</span>

        <span class="n">stack_rmap</span> <span class="o">=</span> <span class="n">stack_rmap</span><span class="p">[</span><span class="n">prod_sel</span><span class="p">]</span>
        <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_search_array</span><span class="p">(</span><span class="n">stack_inds</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">])</span>

        <span class="c1"># Remake stack map from scratch, since prod referenced in current stack</span>
        <span class="c1"># map may have dissapeared.</span>
        <span class="n">stack_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack_inds</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">stack_map</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">stack_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_search_array</span><span class="p">(</span>
            <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack_inds</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">stack_map</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">][</span><span class="n">stack_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>

        <span class="n">prod_map</span> <span class="o">=</span> <span class="n">prod_map</span><span class="p">[</span><span class="n">prod_sel</span><span class="p">]</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="n">_search_array</span><span class="p">(</span><span class="n">input_inds</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">])</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">_search_array</span><span class="p">(</span><span class="n">input_inds</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">])</span>
        <span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
        <span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pb</span>
        <span class="n">input_map</span> <span class="o">=</span> <span class="n">input_map</span><span class="p">[</span><span class="n">input_sel</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">stack_sel</span><span class="p">,</span> <span class="n">stack_map</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">,</span> <span class="n">input_sel</span><span class="p">,</span> <span class="n">input_map</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_npissorted</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_search_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the indeces in array `a` of values in array &#39;v&#39;.</span>

<span class="sd">    Use algorithm that presorts `a`, efficient if `v` is long.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_sort_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
    <span class="n">a_sorted</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">a_sort_inds</span><span class="p">]</span>
    <span class="n">indeces_in_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">a_sorted</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># Make sure values actually present.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">a_sorted</span><span class="p">[</span><span class="n">indeces_in_sorted</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element in &#39;v&#39; not in &#39;a&#39;.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_sort_inds</span><span class="p">[</span><span class="n">indeces_in_sorted</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_input_sel_from_prod_sel</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">):</span>
    <span class="n">prod_map</span> <span class="o">=</span> <span class="n">prod_map</span><span class="p">[</span><span class="n">prod_sel</span><span class="p">]</span>
    <span class="n">input_sel</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">prod_map</span><span class="p">:</span>
        <span class="n">input_sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">input_sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
    <span class="c1"># ensure_1D here deals with h5py issue #425.</span>
    <span class="k">return</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">input_sel</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_prod_sel_from_input_sel</span><span class="p">(</span><span class="n">input_sel</span><span class="p">,</span> <span class="n">input_map</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_map</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">input_sel</span><span class="p">])</span>
    <span class="n">prod_sel</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_map</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">prod_sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
    <span class="c1"># ensure_1D here deals with h5py issue #425.</span>
    <span class="k">return</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_stack_sel_from_prod_sel</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">):</span>
    <span class="n">stack_sel</span> <span class="o">=</span> <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="n">prod_sel</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stack_sel</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_prod_sel_from_stack_sel</span><span class="p">(</span><span class="n">stack_sel</span><span class="p">,</span> <span class="n">stack_map</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">):</span>
    <span class="n">stack_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack_map</span><span class="p">))[</span><span class="n">stack_sel</span><span class="p">]</span>
    <span class="n">stack_rmap_sort_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
    <span class="n">stack_rmap_sorted</span> <span class="o">=</span> <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="n">stack_rmap_sort_inds</span><span class="p">]</span>
    <span class="n">left_indeces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">stack_rmap_sorted</span><span class="p">,</span> <span class="n">stack_inds</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">right_indeces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">stack_rmap_sorted</span><span class="p">,</span> <span class="n">stack_inds</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="n">prod_sel</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack_inds</span><span class="p">)):</span>
        <span class="n">prod_sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack_rmap_sort_inds</span><span class="p">[</span><span class="n">left_indeces</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="p">:</span> <span class="n">right_indeces</span><span class="p">[</span><span class="n">ii</span><span class="p">]])</span>
    <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_ensure_1D_selection</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">)))</span>


<div class="viewcode-block" id="versiontuple">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.versiontuple">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">versiontuple</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a version tuple from a version string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v: str</span>
<span class="sd">        A version string</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    versiontuple: tuple</span>
<span class="sd">        A tuple of `int` values created by splitting the string on dots.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))))</span></div>



<span class="c1"># Calculations from data.</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_renormalize</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Correct vis and vis_weight for lost packets.&quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_util</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span>

    <span class="c1"># Determine the datasets that need to be renormalized</span>
    <span class="n">datasets_to_renormalize</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ACQ_VIS_DATASETS</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">datasets_to_renormalize</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Determine if we will correct vis_weight in addition to vis.</span>
    <span class="n">adjust_weight</span> <span class="o">=</span> <span class="s2">&quot;vis_weight&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span>

    <span class="c1"># Extract number of packets expected</span>
    <span class="n">n_packets_expected</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;gpu.gpu_intergration_period&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Loop over frequencies to limit memory usage</span>
    <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">nfreq</span><span class="p">):</span>
        <span class="c1"># Calculate the fraction of packets received</span>
        <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;lost_packet_count&quot;</span><span class="p">][</span><span class="n">ff</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">n_packets_expected</span>
        <span class="p">)</span>

        <span class="c1"># Multiply vis_weight by fraction of packets received</span>
        <span class="k">if</span> <span class="n">adjust_weight</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">][</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">][</span><span class="n">ff</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight_factor</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>

        <span class="c1"># Divide vis by fraction of packets received</span>
        <span class="n">weight_factor</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_factor</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">datasets_to_renormalize</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">ff</span><span class="p">]</span> <span class="o">*=</span> <span class="n">weight_factor</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unwrap_fpga_counts</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unwrap 32-bit FPGA counts in a CorrData object.&quot;&quot;&quot;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

    <span class="n">time_map</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][:]</span>

    <span class="c1"># If FPGA counts are already 64-bit then we don&#39;t need to unwrap</span>
    <span class="k">if</span> <span class="n">time_map</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Try and fetch out required attributes, if they are not there (which</span>
    <span class="c1"># happens in older files), fill in the usual values</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;n_freq&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">samp_freq_MHz</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;fpga.samp_freq&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="mi">1024</span>
        <span class="n">samp_freq_MHz</span> <span class="o">=</span> <span class="mf">800.0</span>

    <span class="c1"># Calculate the length of an FPGA count and the time it takes to wrap</span>
    <span class="n">seconds_per_count</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">nfreq</span> <span class="o">/</span> <span class="p">(</span><span class="n">samp_freq_MHz</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>
    <span class="n">wrap_time</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mf">32.0</span> <span class="o">*</span> <span class="n">seconds_per_count</span>

    <span class="c1"># Estimate the FPGA initial zero time from the timestamp in the acquisition</span>
    <span class="c1"># name, if the acq name is not there, or of the correct format just silently return</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">acq_name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;acquisition_name&quot;</span><span class="p">]</span>
        <span class="n">acq_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">acq_name</span><span class="p">[:</span><span class="mi">16</span><span class="p">],</span> <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H%M%SZ&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="n">acq_start</span> <span class="o">=</span> <span class="n">CorrData</span><span class="o">.</span><span class="n">convert_time</span><span class="p">(</span><span class="n">acq_dt</span><span class="p">)</span>

    <span class="c1"># Calculate the time that the count last wrapped</span>
    <span class="n">last_wrap</span> <span class="o">=</span> <span class="n">time_map</span><span class="p">[</span><span class="s2">&quot;ctime&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_map</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">seconds_per_count</span>

    <span class="c1"># Use this and the FPGA zero time to calculate the total number of wraps</span>
    <span class="n">num_wraps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">last_wrap</span> <span class="o">-</span> <span class="n">acq_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">wrap_time</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

    <span class="c1"># Correct the FPGA counts by adding on the counts lost by wrapping</span>
    <span class="n">fpga_corrected</span> <span class="o">=</span> <span class="n">time_map</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_wraps</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span>

    <span class="c1"># Create an array to represent the new time dataset,</span>
    <span class="c1"># and fill in the corrected values</span>
    <span class="n">_time_dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ctime&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span>
    <span class="n">new_time_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">time_map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_time_dtype</span><span class="p">)</span>
    <span class="n">new_time_map</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fpga_corrected</span>
    <span class="n">new_time_map</span><span class="p">[</span><span class="s2">&quot;ctime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_map</span><span class="p">[</span><span class="s2">&quot;ctime&quot;</span><span class="p">]</span>

    <span class="c1"># Replace the time input map</span>
    <span class="n">data</span><span class="o">.</span><span class="n">del_index_map</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">new_time_map</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_timestamp_from_fpga_cpu</span><span class="p">(</span><span class="n">cpu_s</span><span class="p">,</span> <span class="n">cpu_us</span><span class="p">,</span> <span class="n">fpga_counts</span><span class="p">):</span>
    <span class="n">ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpu_s</span><span class="p">)</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">timestamp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cpu_s</span>
    <span class="k">if</span> <span class="n">cpu_us</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">timestamp</span> <span class="o">+=</span> <span class="n">cpu_us</span> <span class="o">/</span> <span class="mf">1.0e6</span>
    <span class="c1"># If we have the more precise fpga clock, use it.  Use the above to</span>
    <span class="c1"># calibrate.</span>
    <span class="k">if</span> <span class="n">fpga_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">timestamp_cpu</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Find discontinuities in the fpga_counts from wrapping.</span>
        <span class="n">d_fpga_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fpga_counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>
        <span class="p">(</span><span class="n">edge_inds</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d_fpga_counts</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">d_fpga_counts</span><span class="p">))</span>
        <span class="n">edge_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge_inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">ntime</span><span class="p">]))</span>
        <span class="c1"># Calculate a global slope.</span>
        <span class="n">slope_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">slope_den</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_inds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">edge_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="p">:</span> <span class="n">edge_inds</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">mean_cpu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">timestamp_cpu</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>
            <span class="n">mean_fpga</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fpga_counts</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>
            <span class="n">diff_cpu</span> <span class="o">=</span> <span class="n">timestamp_cpu</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_cpu</span>
            <span class="n">diff_fpga</span> <span class="o">=</span> <span class="n">fpga_counts</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_fpga</span>
            <span class="n">slope_num</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff_cpu</span> <span class="o">*</span> <span class="n">diff_fpga</span><span class="p">)</span>
            <span class="n">slope_den</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff_fpga</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">slope_num</span> <span class="o">/</span> <span class="n">slope_den</span>
        <span class="c1"># Calculate offset in each section.</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_inds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">edge_inds</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="p">:</span> <span class="n">edge_inds</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">mean_cpu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">timestamp_cpu</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>
            <span class="n">mean_fpga</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fpga_counts</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">mean_cpu</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">mean_fpga</span>
            <span class="c1"># Apply fit.</span>
            <span class="n">timestamp</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">fpga_counts</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
    <span class="c1"># XXX</span>
    <span class="c1"># The above provides integration ends, not centres.  Fix:</span>
    <span class="c1"># delta = np.median(np.diff(timestamp))</span>
    <span class="c1"># timestamp -= abs(delta) / 2.</span>
    <span class="k">return</span> <span class="n">timestamp</span>


<span class="c1"># IO for acquisition format 1.0</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_copy_dataset_acq1</span><span class="p">(</span>
    <span class="n">dataset_name</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">out_data</span><span class="p">,</span> <span class="n">prod_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_sel</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="n">s_ind</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ntime</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">acq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">acq_files</span><span class="p">):</span>
        <span class="n">acq_dataset</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span>
        <span class="n">this_ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s_ind</span> <span class="o">+</span> <span class="n">this_ntime</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">s_ind</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="c1"># No data from this file is included.</span>
            <span class="n">s_ind</span> <span class="o">+=</span> <span class="n">this_ntime</span>
            <span class="k">continue</span>
        <span class="c1"># What data (time frames) are included in this file.</span>
        <span class="c1"># out_slice = np.s_[max(0, s_ind - start):s_ind - start + this_ntime]</span>
        <span class="c1"># acq_slice = np.s_[max(0, start - s_ind):min(this_ntime, stop - s_ind)]</span>
        <span class="n">acq_slice</span><span class="p">,</span> <span class="n">out_slice</span> <span class="o">=</span> <span class="n">tod</span><span class="o">.</span><span class="n">_get_in_out_slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">s_ind</span><span class="p">,</span> <span class="n">this_ntime</span><span class="p">)</span>
        <span class="c1"># Split the fields of the dataset into separate datasets and reformat.</span>
        <span class="n">split_dsets</span><span class="p">,</span> <span class="n">split_dsets_cal</span> <span class="o">=</span> <span class="n">_format_split_acq_dataset_acq1</span><span class="p">(</span>
            <span class="n">acq_dataset</span><span class="p">,</span> <span class="n">acq_slice</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">dataset_name</span> <span class="o">==</span> <span class="s2">&quot;vis&quot;</span><span class="p">:</span>
            <span class="c1"># Convert to 64 but complex.</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">split_dsets</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="p">{</span><span class="s2">&quot;imag&quot;</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">}:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Visibilities should have fields &#39;real&#39; and &#39;imag&#39;&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; and instead have </span><span class="si">{</span><span class="n">split_dsets</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">vis_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">split_dsets</span><span class="p">[</span><span class="s2">&quot;real&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
            <span class="n">vis_data</span><span class="o">.</span><span class="n">real</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">split_dsets</span><span class="p">[</span><span class="s2">&quot;real&quot;</span><span class="p">]</span>
            <span class="n">vis_data</span><span class="o">.</span><span class="n">imag</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">split_dsets</span><span class="p">[</span><span class="s2">&quot;imag&quot;</span><span class="p">]</span>

            <span class="n">split_dsets</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="n">vis_data</span><span class="p">}</span>
            <span class="n">split_dsets_cal</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">split_dset_name</span><span class="p">,</span> <span class="n">split_dset</span> <span class="ow">in</span> <span class="n">split_dsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">prod_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># prod_sel could be 0.</span>
                <span class="c1"># Do this in two steps to get around shape matching.</span>
                <span class="n">split_dset</span> <span class="o">=</span> <span class="n">split_dset</span><span class="p">[</span><span class="n">freq_sel</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">split_dset</span> <span class="o">=</span> <span class="n">split_dset</span><span class="p">[:,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">split_dset_name</span><span class="p">:</span>
                <span class="n">full_name</span> <span class="o">=</span> <span class="n">dataset_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">split_dset_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">full_name</span> <span class="o">=</span> <span class="n">dataset_name</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">s_ind</span><span class="p">:</span>
                <span class="c1"># First file, initialize output dataset.</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">split_dset</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ntime</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">split_dset_name</span> <span class="ow">in</span> <span class="n">split_dsets_cal</span><span class="p">:</span>
                    <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cal&quot;</span><span class="p">:</span> <span class="n">split_dsets_cal</span><span class="p">[</span><span class="n">split_dset_name</span><span class="p">]}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># Try to figure out the axis names.</span>
                <span class="k">if</span> <span class="n">prod_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># The shape of the visibilities.</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;UNKNOWN&quot;</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,)</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="n">full_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">split_dset</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span>
                <span class="p">)</span>

                <span class="c1"># Copy over attributes</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="c1"># Finally copy the data over.</span>
            <span class="n">out_data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">full_name</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">out_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">split_dset</span><span class="p">[:]</span>
        <span class="n">s_ind</span> <span class="o">+=</span> <span class="n">this_ntime</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_files_acq1</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gets a list of open hdf5 file objects and checks their consistency.</span>

<span class="sd">    Checks that they all have the same datasets and that all datasets have</span>
<span class="sd">    consistent data types.</span>

<span class="sd">    Essential arguments are modified in-place instead of using return values.</span>
<span class="sd">    This keeps the lists as up to date as possible in the event that an</span>
<span class="sd">    exception is raised within this function.</span>

<span class="sd">    Non-essential information is returned such as the dtypes for all the</span>
<span class="sd">    datasets.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">first_file</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">open_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">files</span><span class="p">)):</span>
        <span class="c1"># Sort out how to get an open hdf5 file.</span>
        <span class="c1"># Check that all files have the same datasets with the same dtypes</span>
        <span class="c1"># and consistent shape.</span>
        <span class="c1"># All datasets in the same file must be the same shape.</span>
        <span class="c1"># Between files, all datasets with the same name must have the same</span>
        <span class="c1"># dtype.</span>
        <span class="n">this_dtypes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">first_dset</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">open_file</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">open_file</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="n">this_dtypes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">if</span> <span class="n">first_dset</span><span class="p">:</span>
                    <span class="n">this_dset_shape</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">first_dset</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">open_file</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">this_dset_shape</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Datasets in a file do not all have same shape.&quot;</span>
                        <span class="p">)</span>
        <span class="k">if</span> <span class="n">first_file</span><span class="p">:</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="n">this_dtypes</span>
            <span class="n">first_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">this_dtypes</span> <span class="o">!=</span> <span class="n">dtypes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Files do not have compatible datasets.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dtypes</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_header_info_acq1</span><span class="p">(</span><span class="n">h5_file</span><span class="p">):</span>
    <span class="c1"># Right now only have to deal with one format.  In the future will need to</span>
    <span class="c1"># deal with all different kinds of data.</span>
    <span class="n">header_info</span> <span class="o">=</span> <span class="n">_data_attrs_from_acq_attrs_acq1</span><span class="p">(</span><span class="n">h5_file</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
    <span class="c1"># Now need to calculate the time stamps.</span>
    <span class="n">timestamp_data</span> <span class="o">=</span> <span class="n">h5_file</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamp_data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AnDataError</span><span class="p">(</span><span class="s2">&quot;Acquisition file contains zero frames&quot;</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">timestamp_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ctime&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="n">time_upper_edges</span> <span class="o">=</span> <span class="n">_timestamp_from_fpga_cpu</span><span class="p">(</span>
        <span class="n">timestamp_data</span><span class="p">[</span><span class="s2">&quot;cpu_s&quot;</span><span class="p">],</span> <span class="n">timestamp_data</span><span class="p">[</span><span class="s2">&quot;cpu_us&quot;</span><span class="p">],</span> <span class="n">timestamp_data</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">time_lower_edges</span> <span class="o">=</span> <span class="n">time_upper_edges</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time_upper_edges</span><span class="p">))</span>
    <span class="n">time</span><span class="p">[</span><span class="s2">&quot;ctime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_lower_edges</span>
    <span class="n">time</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp_data</span><span class="p">[</span><span class="s2">&quot;fpga_count&quot;</span><span class="p">]</span>
    <span class="n">header_info</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">h5_file</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">memh5</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="n">h5_file</span><span class="p">[</span><span class="n">key</span><span class="p">])]</span>
    <span class="n">header_info</span><span class="p">[</span><span class="s2">&quot;datasets&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">header_info</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_resolve_header_info_acq1</span><span class="p">(</span><span class="n">header_info</span><span class="p">):</span>
    <span class="n">first_info</span> <span class="o">=</span> <span class="n">header_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">first_info</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">first_info</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span>
    <span class="n">datasets</span> <span class="o">=</span> <span class="n">first_info</span><span class="p">[</span><span class="s2">&quot;datasets&quot;</span><span class="p">]</span>
    <span class="n">time_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_info</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">header_info</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">],</span> <span class="n">freq</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Files do not have consistent frequency bin widths.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;centre&quot;</span><span class="p">],</span> <span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Files do not have consistent frequency bin centres.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">prod</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Files do not have consistent correlation products.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;datasets&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">datasets</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Files do not have consistent data sets.&quot;</span><span class="p">)</span>
        <span class="n">time_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">time_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">datasets</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_files_frames_acq1</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Counts the number of frames in each file and sorts out which frames to</span>
<span class="sd">    read.&quot;&quot;&quot;</span>

    <span class="n">dataset_name</span> <span class="o">=</span> <span class="s2">&quot;vis&quot;</span>  <span class="c1"># For now just base everything off of &#39;vis&#39;.</span>
    <span class="n">n_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">this_file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="c1"># Make sure the dataset is 1D.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_file</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected 1D datasets.&quot;</span><span class="p">)</span>
        <span class="n">n_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">this_file</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]))</span>
    <span class="n">n_time_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_times</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tod</span><span class="o">.</span><span class="n">_start_stop_inds</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n_time_total</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_format_split_acq_dataset_acq1</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">time_slice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Formats a dataset from a acq h5 file into a more easily handled array.</span>

<span class="sd">    Completely reverses the order of all axes.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get shape information.</span>
    <span class="n">ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="n">ntime_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntime</span><span class="p">)[</span><span class="n">time_slice</span><span class="p">])</span>
    <span class="c1"># If each record is an array, then get that shape.</span>
    <span class="n">back_shape</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># The shape of the output array.</span>
    <span class="n">reversed_back_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">back_shape</span><span class="p">)</span>
    <span class="n">reversed_back_shape</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reversed_back_shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ntime_out</span><span class="p">,)</span>
    <span class="c1"># Check if there are multiple data fields in this dataset.  If so they will</span>
    <span class="c1"># each end up in their own separate arrays.</span>
    <span class="k">if</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntime</span><span class="p">)[</span><span class="n">time_slice</span><span class="p">]):</span>
            <span class="c1"># 1D case is trivial.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">back_shape</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">back_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not done yet.&quot;</span><span class="p">)</span>
                <span class="c1"># Otherwise, loop over all dimensions except the last one.</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;multi_index&quot;</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;cal&quot;</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Mismatch between dataset and it&#39;s cal attribute.&quot;</span><span class="p">)</span>
            <span class="n">out_cal</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_cal</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">},</span> <span class="n">out_cal</span>

    <span class="n">fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="c1"># If there is a &#39;cal&#39; attribute, make sure it&#39;s the right shape.</span>
    <span class="k">if</span> <span class="s2">&quot;cal&quot;</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;cal&#39; attribute has more than one element.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;cal&#39; attribute not compatible with dataset dtype.&quot;</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out_cal</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Figure out what fields there are and allocate memory.</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">out_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_arr</span>
        <span class="k">if</span> <span class="s2">&quot;cal&quot;</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">out_cal</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">field</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntime</span><span class="p">)[</span><span class="n">time_slice</span><span class="p">]):</span>
        <span class="c1"># Copy data for efficient read.</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>  <span class="c1"># Copies to memory.</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">back_shape</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">back_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">field</span><span class="p">][:,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="n">field</span><span class="p">][:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Multidimensional, try to be more efficient.</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;multi_index&quot;</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                    <span class="c1"># Reverse the multiindex for the out array.</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span>
                    <span class="n">ind_rev</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                    <span class="n">ind_rev</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="n">ind_rev</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_rev</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">jj</span><span class="p">,)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">ind_rev</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_cal</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_data_attrs_from_acq_attrs_acq1</span><span class="p">(</span><span class="n">acq_attrs</span><span class="p">):</span>
    <span class="c1"># The frequency axis.  In MHz.</span>
    <span class="n">samp_freq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">acq_attrs</span><span class="p">[</span><span class="s2">&quot;system_sampling_frequency&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e6</span>
    <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">acq_attrs</span><span class="p">[</span><span class="s2">&quot;n_freq&quot;</span><span class="p">])</span>
    <span class="n">freq_width</span> <span class="o">=</span> <span class="n">samp_freq</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">nfreq</span>
    <span class="n">freq_width_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">freq_width_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">freq_width</span>
    <span class="n">freq_centre</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">samp_freq</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">freq_width_array</span><span class="p">)</span> <span class="o">+</span> <span class="n">freq_width</span>
    <span class="p">)</span>  <span class="c1"># This offset gives the correct channels</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;centre&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)])</span>
    <span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_centre</span>
    <span class="n">freq</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_width</span>
    <span class="c1"># The product axis.</span>
    <span class="n">prod_channels</span> <span class="o">=</span> <span class="n">acq_attrs</span><span class="p">[</span><span class="s2">&quot;chan_indices&quot;</span><span class="p">]</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_channels</span><span class="p">)</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nprod</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;input_a&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;input_b&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)])</span>
    <span class="c1"># This raises a warning for some data, where the col names aren&#39;t exactly</span>
    <span class="c1"># &#39;input_a&#39; and &#39;input_b&#39;.</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">prod</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">prod_channels</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">):</span>
        <span class="n">prod</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_channels</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">prod</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_channels</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Populate the output.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_index_map_from_acq1</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="n">time_sel</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">freq_sel</span><span class="p">):</span>
    <span class="n">data_headers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">acq_file</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">:</span>
        <span class="n">data_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_get_header_info_acq1</span><span class="p">(</span><span class="n">acq_file</span><span class="p">))</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tmp_dsets</span> <span class="o">=</span> <span class="n">_resolve_header_info_acq1</span><span class="p">(</span><span class="n">data_headers</span><span class="p">)</span>
    <span class="c1"># Populate output.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">time_sel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">time_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">prod_sel</span><span class="p">]</span>
    <span class="n">out</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">freq_sel</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="andata_from_acq1">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.andata_from_acq1">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">andata_from_acq1</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">freq_sel</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a `CorrData` object from a 1.0.0 archive version acq.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    acq_files : filename, `h5py.File` or list there-of or filename pattern</span>
<span class="sd">        Files to convert from acquisition format to analysis format.</span>
<span class="sd">        Filename patterns with wild cards (e.g. &quot;foo*.h5&quot;) are supported.</span>
<span class="sd">    start : int</span>
<span class="sd">        What frame to start at in the full set of files.</span>
<span class="sd">    stop : int</span>
<span class="sd">        What frame to stop at in the full set of files.</span>
<span class="sd">    prod_sel : 1D data selection</span>
<span class="sd">        Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">        along the correlation product axis.</span>
<span class="sd">    freq_sel : 1D data selection</span>
<span class="sd">        Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">        along the frequency axis.</span>
<span class="sd">    datasets : list of strings</span>
<span class="sd">        Names of datasets to include from acquisition files. Default is to</span>
<span class="sd">        include all datasets found in the acquisition files.</span>
<span class="sd">    out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">        Underlying hdf5 like container that will store the data for the</span>
<span class="sd">        BaseData instance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corrdata:</span>
<span class="sd">        A `CorrData` object with the requested data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First open all the files and collect necessary data for all of them.</span>
    <span class="n">dtypes</span> <span class="o">=</span> <span class="n">_check_files_acq1</span><span class="p">(</span><span class="n">acq_files</span><span class="p">)</span>
    <span class="c1"># Figure how much of the total data to read.</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">_get_files_frames_acq1</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
    <span class="c1"># Initialize the output.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">CorrData</span><span class="p">(</span><span class="n">out_group</span><span class="p">)</span>
    <span class="c1"># Assume all meta-data are the same as in the first file and copy it</span>
    <span class="c1"># over.</span>
    <span class="n">acq</span> <span class="o">=</span> <span class="n">acq_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">add_history</span><span class="p">(</span><span class="s2">&quot;acq&quot;</span><span class="p">,</span> <span class="n">memh5</span><span class="o">.</span><span class="n">attrs2dict</span><span class="p">(</span><span class="n">acq</span><span class="o">.</span><span class="n">attrs</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">][</span><span class="s2">&quot;archive_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;1.0.0&quot;</span>
    <span class="c1"># Copy data attribute axis info.</span>
    <span class="n">index_map</span> <span class="o">=</span> <span class="n">_get_index_map_from_acq1</span><span class="p">(</span><span class="n">acq_files</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">),</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">freq_sel</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">axis_values</span> <span class="ow">in</span> <span class="n">index_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">axis_name</span><span class="p">,</span> <span class="n">axis_values</span><span class="p">)</span>
    <span class="c1"># Set file format attributes.</span>
    <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;instrument_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;UNKNOWN&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;instrument_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">acq</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">else</span> <span class="n">acq</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;instrument_name&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;acquisition_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;UNKNOWN&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;acquisition_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;corr&quot;</span>
    <span class="c1"># Copy over the cal information if there is any.</span>
    <span class="k">if</span> <span class="s2">&quot;cal&quot;</span> <span class="ow">in</span> <span class="n">acq</span><span class="p">:</span>
        <span class="n">memh5</span><span class="o">.</span><span class="n">deep_group_copy</span><span class="p">(</span>
            <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">],</span>
            <span class="n">data</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s2">&quot;cal&quot;</span><span class="p">],</span>
            <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="n">CorrData</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="n">CorrData</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># Now copy the datasets.</span>
    <span class="k">if</span> <span class="n">datasets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="c1"># Start with the visibilities.</span>
    <span class="n">vis_shape</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">for</span> <span class="n">dataset_name</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">dataset_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
            <span class="k">continue</span>
            <span class="c1"># msg = &quot;No dataset named %s in Acq files.&quot; % dataset_name</span>
            <span class="c1"># raise ValueError(msg)</span>

        <span class="k">if</span> <span class="n">dataset_name</span> <span class="ow">in</span> <span class="n">ACQ_VIS_SHAPE_DATASETS</span><span class="p">:</span>
            <span class="c1"># These datasets must all be the same shape.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis_shape</span><span class="p">:</span>
                <span class="n">vis_shape</span> <span class="o">=</span> <span class="n">dtypes</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">elif</span> <span class="n">dtypes</span><span class="p">[</span><span class="n">dataset_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vis_shape</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">vis_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expected the following datasets to be identically &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;shaped and 3D in Acq files: </span><span class="si">{</span><span class="n">ACQ_VIS_SHAPE_DATASETS</span><span class="si">!s}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">_copy_dataset_acq1</span><span class="p">(</span>
                <span class="n">dataset_name</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">freq_sel</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_copy_dataset_acq1</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>



<span class="c1"># IO for archive format 2.0</span>


<div class="viewcode-block" id="andata_from_archive2">
<a class="viewcode-back" href="../../_autosummary/ch_util.andata.html#ch_util.andata.andata_from_archive2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">andata_from_archive2</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">acq_files</span><span class="p">,</span>
    <span class="n">start</span><span class="p">,</span>
    <span class="n">stop</span><span class="p">,</span>
    <span class="n">stack_sel</span><span class="p">,</span>
    <span class="n">prod_sel</span><span class="p">,</span>
    <span class="n">input_sel</span><span class="p">,</span>
    <span class="n">freq_sel</span><span class="p">,</span>
    <span class="n">datasets</span><span class="p">,</span>
    <span class="n">out_group</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create an Andata object from a version 2.0.0 archive format acq.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls:</span>
<span class="sd">        class of object to create</span>
<span class="sd">    acq_files : filename, `h5py.File` or list there-of or filename pattern</span>
<span class="sd">        Files to convert from acquisition format to analysis format.</span>
<span class="sd">        Filename patterns with wild cards (e.g. &quot;foo*.h5&quot;) are supported.</span>
<span class="sd">    start : int</span>
<span class="sd">        What frame to start at in the full set of files.</span>
<span class="sd">    stop : int</span>
<span class="sd">        What frame to stop at in the full set of files.</span>
<span class="sd">    prod_sel : 1D data selection</span>
<span class="sd">        Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">        along the correlation product axis.</span>
<span class="sd">    freq_sel : 1D data selection</span>
<span class="sd">        Valid numpy index for a 1D array, specifying what data to read</span>
<span class="sd">        along the frequency axis.</span>
<span class="sd">    datasets : list of strings</span>
<span class="sd">        Names of datasets to include from acquisition files. Default is to</span>
<span class="sd">        include all datasets found in the acquisition files.</span>
<span class="sd">    out_group : `h5py.Group`, hdf5 filename or `memh5.Group`</span>
<span class="sd">        Underlying hdf5 like container that will store the data for the</span>
<span class="sd">        BaseData instance.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    andata : `cls` instance</span>
<span class="sd">        The andata object for the requested data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># XXX For short term force to CorrData class.  Will be fixed once archive</span>
    <span class="c1"># files carry &#39;acquisition_type&#39; attribute.</span>
    <span class="c1"># andata_objs = [ cls(d) for d in acq_files ]</span>
    <span class="n">andata_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CorrData</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">]</span>

    <span class="c1"># Resolve input and prod maps</span>
    <span class="n">first_imap</span> <span class="o">=</span> <span class="n">andata_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index_map</span>
    <span class="n">first_rmap</span> <span class="o">=</span> <span class="n">andata_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse_map</span>

    <span class="c1"># Cannot use input/prod sel for stacked data</span>
    <span class="k">if</span> <span class="s2">&quot;stack&quot;</span> <span class="ow">in</span> <span class="n">first_imap</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">input_sel</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot give input_sel for a stacked dataset.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prod_sel</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot give prod_sel for a stacked dataset.&quot;</span><span class="p">)</span>

    <span class="n">prod_map</span> <span class="o">=</span> <span class="n">first_imap</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">input_map</span> <span class="o">=</span> <span class="n">first_imap</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">input_map</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">ensure_unicode</span><span class="p">(</span><span class="n">input_map</span><span class="p">)</span>  <span class="c1"># Convert string entries to unicode</span>
    <span class="k">if</span> <span class="s2">&quot;stack&quot;</span> <span class="ow">in</span> <span class="n">first_imap</span><span class="p">:</span>
        <span class="n">stack_map</span> <span class="o">=</span> <span class="n">first_imap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stack_rmap</span> <span class="o">=</span> <span class="n">first_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Unstacked so the stack and prod axes are essentially the same.</span>
        <span class="n">nprod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_map</span><span class="p">)</span>
        <span class="n">stack_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nprod</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;u1&quot;</span><span class="p">)])</span>
        <span class="n">stack_map</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stack_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nprod</span><span class="p">)</span>
        <span class="n">stack_rmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nprod</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;u1&quot;</span><span class="p">)])</span>
        <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stack_rmap</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nprod</span><span class="p">)</span>
        <span class="c1"># Efficiently slice prod axis, not stack axis.</span>
        <span class="k">if</span> <span class="n">stack_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prod_sel</span> <span class="o">=</span> <span class="n">stack_sel</span>
            <span class="n">stack_sel</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="p">(</span>
        <span class="n">stack_sel</span><span class="p">,</span>
        <span class="n">stack_map</span><span class="p">,</span>
        <span class="n">stack_rmap</span><span class="p">,</span>
        <span class="n">prod_sel</span><span class="p">,</span>
        <span class="n">prod_map</span><span class="p">,</span>
        <span class="n">input_sel</span><span class="p">,</span>
        <span class="n">input_map</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_resolve_stack_prod_input_sel</span><span class="p">(</span>
        <span class="n">stack_sel</span><span class="p">,</span> <span class="n">stack_map</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">,</span> <span class="n">prod_sel</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">,</span> <span class="n">input_sel</span><span class="p">,</span> <span class="n">input_map</span>
    <span class="p">)</span>

    <span class="c1"># Define dataset filter to convert vis datatype.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dset_filter</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">time_sel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># For compatibility with older caput.</span>
        <span class="k">if</span> <span class="n">time_sel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># A lot of the logic here is that h5py can only deal with one</span>
        <span class="c1"># *fancy* slice (that is 1 axis where the slice is an array).</span>
        <span class="c1"># Note that *time_sel* is always a normal slice, so don&#39;t have to worry</span>
        <span class="c1"># about it as much.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;attrs&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Special treatement for pure sub-array dtypes, which get</span>
        <span class="c1"># modified by numpy to add dimensions when read.</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;V&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">and</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">field_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)])</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># The datasets this effects are tiny, so just read them in.</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span> <span class="ow">and</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">):</span>
            <span class="c1"># For large datasets, take great pains to down-select as</span>
            <span class="c1"># efficiently as possible.</span>
            <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;stack&quot;</span><span class="p">:</span>
                <span class="n">msel</span> <span class="o">=</span> <span class="n">stack_sel</span>
            <span class="k">elif</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
                <span class="n">msel</span> <span class="o">=</span> <span class="n">prod_sel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msel</span> <span class="o">=</span> <span class="n">input_sel</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">nfsel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">)</span> <span class="k">if</span> <span class="n">freq_sel</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">)</span>
                <span class="n">npsel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">msel</span><span class="p">)</span> <span class="k">if</span> <span class="n">msel</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">msel</span><span class="p">)</span>
                <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">andata_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">])</span>
                <span class="n">nprod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">andata_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">])</span>
                <span class="n">frac_fsel</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nfsel</span><span class="p">)</span> <span class="o">/</span> <span class="n">nfreq</span>
                <span class="n">frac_psel</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">npsel</span><span class="p">)</span> <span class="o">/</span> <span class="n">nprod</span>

                <span class="k">if</span> <span class="n">frac_psel</span> <span class="o">&lt;</span> <span class="n">frac_fsel</span><span class="p">:</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:,</span> <span class="n">msel</span><span class="p">,</span> <span class="n">time_sel</span><span class="p">][</span><span class="n">freq_sel</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">freq_sel</span><span class="p">,</span> <span class="p">:,</span> <span class="n">time_sel</span><span class="p">][:,</span> <span class="n">msel</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># At least one of *msel* and *freq_sel* is an</span>
                <span class="c1"># integer or slice object and h5py can do the full read</span>
                <span class="c1"># efficiently.</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">freq_sel</span><span class="p">,</span> <span class="n">msel</span><span class="p">,</span> <span class="n">time_sel</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Dynamically figure out the axis ordering.</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># h5py datasets don&#39;t have ndim.</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;freq&quot;</span> <span class="ow">in</span> <span class="n">axis</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_sel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
                <span class="s2">&quot;stack&quot;</span> <span class="ow">in</span> <span class="n">axis</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_sel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;prod&quot;</span> <span class="ow">in</span> <span class="n">axis</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prod_sel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
                <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="n">axis</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_sel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># At least two array slices. Incrementally down select.</span>
                <span class="c1"># First freq.</span>
                <span class="n">dataset_sel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_sel</span>
                <span class="c1"># Assume the time is the fastest varying index</span>
                <span class="c1"># and down select here.</span>
                <span class="n">dataset_sel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_sel</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dataset_sel</span><span class="p">)]</span>
                <span class="c1"># And again for stack.</span>
                <span class="n">dataset_sel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;stack&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_sel</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dataset_sel</span><span class="p">)]</span>
                <span class="c1"># And again for prod.</span>
                <span class="n">dataset_sel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_sel</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dataset_sel</span><span class="p">)]</span>
                <span class="c1"># And again for input.</span>
                <span class="n">dataset_sel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_sel</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dataset_sel</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dataset_sel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_sel</span>
                    <span class="k">elif</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;stack&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_sel</span>
                    <span class="k">elif</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;prod&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_sel</span>
                    <span class="k">elif</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_sel</span>
                    <span class="k">elif</span> <span class="n">axis</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">in</span> <span class="n">CONCATENATION_AXES</span><span class="p">:</span>
                        <span class="n">dataset_sel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_sel</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dataset_sel</span><span class="p">)]</span>

        <span class="c1"># Change data type for the visibilities, if necessary.</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ACQ_VIS_DATASETS</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:]</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dataset</span>

    <span class="c1"># The actual read, file by file.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
        <span class="n">andata_objs</span><span class="p">,</span>
        <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
        <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
        <span class="n">dataset_filter</span><span class="o">=</span><span class="n">dset_filter</span><span class="p">,</span>
        <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
        <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Andata (or memh5) should already do the right thing.</span>
    <span class="c1"># Explicitly close up files</span>
    <span class="c1"># for ad in andata_objs:</span>
    <span class="c1">#     ad.close()</span>

    <span class="c1"># Rejig the index map according to prod_sel and freq_sel.</span>
    <span class="c1"># Need to use numpy arrays to avoid weird cyclic reference issues.</span>
    <span class="c1"># (https://github.com/numpy/numpy/issues/1601)</span>
    <span class="n">fmap</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="n">freq_sel</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># pmap = data.index_map[&#39;prod&#39;][prod_sel].view(np.ndarray).copy()</span>
    <span class="c1"># imap = data.index_map[&#39;input&#39;][input_sel].view(np.ndarray).copy()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="n">fmap</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="n">stack_map</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">create_reverse_map</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="n">stack_rmap</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="n">prod_map</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">input_map</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">input_sel</span></div>



<span class="c1"># Routines for re-mapping the index_map/input to match up the order that is</span>
<span class="c1"># in the files, and the layout database</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_generate_input_map</span><span class="p">(</span><span class="n">serials</span><span class="p">,</span> <span class="n">chans</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Generate an input map in the correct format. If chans is None, just</span>
    <span class="c1"># number from 0 upwards, otherwise use the channel numbers specified.</span>

    <span class="c1"># Define datatype of input map array</span>
    <span class="c1"># TODO: Python 3 string issues</span>
    <span class="n">_imap_dtype</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;chan_id&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">,</span> <span class="s2">&quot;U32&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="c1"># Add in channel numbers correctly</span>
    <span class="k">if</span> <span class="n">chans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chan_iter</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">serials</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chan_iter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">chans</span><span class="p">,</span> <span class="n">serials</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chan_iter</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_imap_dtype</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_versiontuple</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;acq&quot;</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">history</span><span class="p">:</span>
        <span class="n">archive_version</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">][</span><span class="s2">&quot;archive_version&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">archive_version</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;archive_version&quot;</span><span class="p">]</span>

    <span class="n">archive_version</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">versiontuple</span><span class="p">(</span><span class="n">archive_version</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remap_stone_abbot</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
    <span class="c1"># Generate an index_map/input for the old stone/abbot files</span>

    <span class="c1"># Really old files do not have an adc_serial attribute</span>
    <span class="k">if</span> <span class="s2">&quot;adc_serial&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Super old file. Cannot tell difference between stone and abbot.&quot;</span><span class="p">)</span>
        <span class="n">serial</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fetch and parse serial value</span>
        <span class="n">serial</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">][</span><span class="s2">&quot;adc_serial&quot;</span><span class="p">])</span>

    <span class="c1"># The serials are defined oddly in the files, use a dict to look them up</span>
    <span class="n">serial_map</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;0003&quot;</span><span class="p">,</span> <span class="mi">33</span><span class="p">:</span> <span class="s2">&quot;0033&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;????&quot;</span><span class="p">}</span>  <span class="c1"># Stone  # Abbot  # Unknown</span>

    <span class="c1"># Construct new array of index_map</span>
    <span class="n">serial_pat</span> <span class="o">=</span> <span class="s2">&quot;29821-0000-&quot;</span> <span class="o">+</span> <span class="n">serial_map</span><span class="p">[</span><span class="n">serial</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;-C</span><span class="si">%i</span><span class="s2">&quot;</span>
    <span class="n">inputmap</span> <span class="o">=</span> <span class="n">_generate_input_map</span><span class="p">([</span><span class="n">serial_pat</span> <span class="o">%</span> <span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span>

    <span class="c1"># Copy out old index_map/input if it exists</span>
    <span class="k">if</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">afile</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input_orig&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]))</span>
        <span class="c1"># del afile._data[&#39;index_map&#39;]._dict[&#39;input&#39;]</span>
        <span class="n">afile</span><span class="o">.</span><span class="n">del_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

    <span class="c1"># Create new index map</span>
    <span class="n">afile</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">afile</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remap_blanchard</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
    <span class="c1"># Remap a blanchard correlator file</span>

    <span class="n">BPC_END</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mf">1410586200.0</span>  <span class="c1"># 2014/09/13 05:30 UTC ~ when blanchard was moved into the crate</span>
    <span class="p">)</span>
    <span class="n">last_time</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Use time to check if blanchard was in the crate or not</span>
    <span class="k">if</span> <span class="n">last_time</span> <span class="o">&lt;</span> <span class="n">BPC_END</span><span class="p">:</span>
        <span class="c1"># Find list of channels and adc serial using different methods depending</span>
        <span class="c1"># on the archive file version</span>
        <span class="k">if</span> <span class="n">_get_versiontuple</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.0.0&quot;</span><span class="p">):</span>
            <span class="c1"># The older files have no index_map/input so we need to guess/construct it.</span>
            <span class="n">chanlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
            <span class="n">adc_serial</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">][</span><span class="s2">&quot;adc_serial&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The newer archive files have the index map, and so we can just parse this</span>
            <span class="n">chanlist</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
            <span class="n">adc_serial</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="s2">&quot;adc_serial&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Construct new array of index_map</span>
        <span class="n">serial_pat</span> <span class="o">=</span> <span class="s2">&quot;29821-0000-&quot;</span> <span class="o">+</span> <span class="n">adc_serial</span> <span class="o">+</span> <span class="s2">&quot;-C</span><span class="si">%02i</span><span class="s2">&quot;</span>
        <span class="n">inputmap</span> <span class="o">=</span> <span class="n">_generate_input_map</span><span class="p">([</span><span class="n">serial_pat</span> <span class="o">%</span> <span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">chanlist</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">_remap_crate_corr</span><span class="p">(</span><span class="n">afile</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">afile</span>

    <span class="c1"># Copy out old index_map/input if it exists</span>
    <span class="k">if</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">afile</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input_orig&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]))</span>
        <span class="c1"># del afile._data[&#39;index_map&#39;]._dict[&#39;input&#39;]</span>
        <span class="n">afile</span><span class="o">.</span><span class="n">del_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

    <span class="c1"># Create new index map</span>
    <span class="n">afile</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">afile</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remap_first9ucrate</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
    <span class="c1"># Remap a first9ucrate file</span>
    <span class="k">if</span> <span class="n">_get_versiontuple</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.0.0&quot;</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Remapping old format first9ucrate files is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">afile</span>

    <span class="c1"># Remap ignoring the fact that there was firt9ucrate data in the old format</span>
    <span class="n">_remap_crate_corr</span><span class="p">(</span><span class="n">afile</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">afile</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remap_slotX</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
    <span class="c1"># Remap a slotXX correlator file</span>

    <span class="c1"># Figure out the slot number</span>
    <span class="n">inst_name</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;instrument_name&quot;</span><span class="p">]</span>
    <span class="n">slotnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">inst_name</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>

    <span class="n">_remap_crate_corr</span><span class="p">(</span><span class="n">afile</span><span class="p">,</span> <span class="n">slotnum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">afile</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remap_crate_corr</span><span class="p">(</span><span class="n">afile</span><span class="p">,</span> <span class="n">slot</span><span class="p">):</span>
    <span class="c1"># Worker routine for remapping the new style files for blanchard,</span>
    <span class="c1"># first9ucrate and slotX</span>

    <span class="k">if</span> <span class="n">_get_versiontuple</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.0.0&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only functions with archive 2.0.0 files.&quot;</span><span class="p">)</span>

    <span class="n">CRATE_CHANGE</span> <span class="o">=</span> <span class="mf">1412640000.0</span>  <span class="c1"># The crate serial changed over for layout 60</span>
    <span class="n">last_time</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">last_time</span> <span class="o">&lt;</span> <span class="n">CRATE_CHANGE</span><span class="p">:</span>
        <span class="n">crate_serial</span> <span class="o">=</span> <span class="s2">&quot;K7BP16-0002&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">crate_serial</span> <span class="o">=</span> <span class="s2">&quot;K7BP16-0004&quot;</span>

    <span class="c1"># Fetch and remap the channel list</span>
    <span class="n">chanlist</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
    <span class="n">channel_remapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># Channel order in new scheme</span>
    <span class="n">chanlist</span> <span class="o">=</span> <span class="n">channel_remapping</span><span class="p">[</span><span class="n">chanlist</span><span class="p">]</span>

    <span class="c1"># The slot remapping function (i.e. C(c) from doclib/165/channel_standards)</span>
    <span class="n">slot_remapping</span> <span class="o">=</span> <span class="p">[</span>
        <span class="mi">80</span><span class="p">,</span>
        <span class="mi">16</span><span class="p">,</span>
        <span class="mi">64</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">208</span><span class="p">,</span>
        <span class="mi">144</span><span class="p">,</span>
        <span class="mi">192</span><span class="p">,</span>
        <span class="mi">128</span><span class="p">,</span>
        <span class="mi">240</span><span class="p">,</span>
        <span class="mi">176</span><span class="p">,</span>
        <span class="mi">224</span><span class="p">,</span>
        <span class="mi">160</span><span class="p">,</span>
        <span class="mi">112</span><span class="p">,</span>
        <span class="mi">48</span><span class="p">,</span>
        <span class="mi">96</span><span class="p">,</span>
        <span class="mi">32</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># Create new list of serials</span>
    <span class="n">serials</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">crate_serial</span><span class="si">}{</span><span class="n">slot</span><span class="si">:</span><span class="s2">02</span><span class="si">}{</span><span class="n">ci</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">chanlist</span><span class="p">]</span>

    <span class="c1"># Create a list of channel ids (taking into account that they are</span>
    <span class="c1"># meaningless for the old crate)</span>
    <span class="k">if</span> <span class="n">last_time</span> <span class="o">&gt;=</span> <span class="n">CRATE_CHANGE</span><span class="p">:</span>
        <span class="n">chans</span> <span class="o">=</span> <span class="p">[</span><span class="n">slot_remapping</span><span class="p">[</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">chanlist</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chans</span> <span class="o">=</span> <span class="n">chanlist</span>

    <span class="n">inputmap</span> <span class="o">=</span> <span class="n">_generate_input_map</span><span class="p">(</span><span class="n">serials</span><span class="p">,</span> <span class="n">chans</span><span class="p">)</span>

    <span class="c1"># Save and remove old index map</span>
    <span class="n">afile</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input_orig&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]))</span>
    <span class="n">afile</span><span class="o">.</span><span class="n">del_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

    <span class="c1"># Create new index map</span>
    <span class="n">afile</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">afile</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remap_inputs</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
    <span class="c1"># Master routine for remapping inputs. This tries to figure out which</span>
    <span class="c1"># instrument took the data, and then dispatch to the right routine to</span>
    <span class="c1"># generate the new index_map/input. This follows the logic in doclib:165</span>

    <span class="c1"># Eventually the change will be made in the correlator software and we</span>
    <span class="c1"># can stop remapping files after that time.</span>

    <span class="c1"># NOTE: need to be careful where you use afile.attrs versus</span>
    <span class="c1"># afile.history[&#39;acq&#39;] for getting properties</span>

    <span class="n">last_time</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">SA_END</span> <span class="o">=</span> <span class="mf">1397088000.0</span>  <span class="c1"># 2014/04/10 ~ last time stone and abbot were working</span>

    <span class="c1"># h5py should return a byte string for the attribute and so we need to decode</span>
    <span class="c1"># it</span>
    <span class="n">inst_name</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;instrument_name&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
    <span class="n">num_antenna</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;acq&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_antenna&quot;</span><span class="p">,</span> <span class="s2">&quot;-1&quot;</span><span class="p">))</span>

    <span class="c1"># Test if is abbot or stone</span>
    <span class="k">if</span> <span class="n">last_time</span> <span class="o">&lt;</span> <span class="n">SA_END</span> <span class="ow">and</span> <span class="n">num_antenna</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># Relies upon old files having the acq history</span>
        <span class="n">_remap_stone_abbot</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">inst_name</span> <span class="o">==</span> <span class="s2">&quot;blanchard&quot;</span><span class="p">:</span>
        <span class="n">_remap_blanchard</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">inst_name</span> <span class="o">==</span> <span class="s2">&quot;first9ucrate&quot;</span><span class="p">:</span>
        <span class="n">_remap_first9ucrate</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">inst_name</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;slot&quot;</span><span class="p">:</span>
        <span class="n">_remap_slotX</span><span class="p">(</span><span class="n">afile</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know what this data is.&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_insert_gains</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">input_sel</span><span class="p">):</span>
    <span class="c1"># Construct a full dataset for the gains and insert it into the CorrData</span>
    <span class="c1"># object</span>
    <span class="c1"># freq_sel is needed for selecting the relevant frequencies in old data</span>

    <span class="c1"># Input_sel is only used for pre archive_version 2.2, where there is no way</span>
    <span class="c1"># to know which header items to pull out.</span>

    <span class="c1"># For old versions the gains are stored in the attributes and need to be</span>
    <span class="c1"># extracted</span>
    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;archive_version&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span> <span class="ow">or</span> <span class="n">versiontuple</span><span class="p">(</span>
        <span class="n">memh5</span><span class="o">.</span><span class="n">bytes_to_unicode</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;archive_version&quot;</span><span class="p">])</span>
    <span class="p">)</span> <span class="o">&lt;</span> <span class="n">versiontuple</span><span class="p">(</span><span class="s2">&quot;2.2.0&quot;</span><span class="p">):</span>
        <span class="c1"># Hack to find the indices of the frequencies in the file</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">800</span><span class="p">,</span> <span class="mf">400.0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>  <span class="c1"># The should be the frequency channel</span>

        <span class="c1"># Compare with a tolerance (&lt; 1e-4). Broken out into loop so we can deal</span>
        <span class="c1"># with the case where there are no matches</span>
        <span class="n">fsel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">fc</span><span class="p">:</span>
            <span class="n">fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fr</span> <span class="o">-</span> <span class="n">freq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fsel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Initialise gains to one by default</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ninput</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ninput_orig</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;number_of_antennas&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">ninput_orig</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">][</span><span class="s2">&quot;number_of_antennas&quot;</span><span class="p">]</span>

        <span class="c1"># In certain files this entry is a length-1 array,</span>
        <span class="c1"># turn it into a scalar if it is not</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ninput_orig</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">ninput_orig</span> <span class="o">=</span> <span class="n">ninput_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ninput_orig</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">:</span>
            <span class="c1"># For 16 channel or earlier data, each channel has a simple</span>
            <span class="c1"># labelling for its gains</span>
            <span class="n">keylist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="s2">&quot;antenna_scaler_gain&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninput_orig</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For 256 channel data this is more complicated</span>

            <span class="c1"># Construct list of keys for all gain entries</span>
            <span class="n">keylist</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ID&quot;</span><span class="p">]</span>

            <span class="c1"># Extract the channel id from each key</span>
            <span class="n">chanid</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">]</span>

            <span class="c1"># Sort the keylist according to the channel ids, as the inputs</span>
            <span class="c1"># should be sorted by channel id.</span>
            <span class="n">keylist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">chanid</span><span class="p">,</span> <span class="n">keylist</span><span class="p">))</span>
        <span class="c1"># Down select keylist based on input_sel.</span>
        <span class="n">input_sel_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ninput_orig</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)[</span><span class="n">input_sel</span><span class="p">])</span>
        <span class="n">keylist</span> <span class="o">=</span> <span class="p">[</span><span class="n">keylist</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">input_sel_list</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">nfreq</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Could not match all frequency channels. Skipping gain calculation.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Iterate over the keys and extract the gains</span>
            <span class="k">for</span> <span class="n">chan</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">:</span>
                <span class="c1"># Try and find gain entry</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                    <span class="n">g_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">]:</span>
                    <span class="n">g_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s2">&quot;acq&quot;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find gain entry [</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">] for channel </span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Unpack the gain values and construct the gain array</span>
                <span class="n">g_real</span><span class="p">,</span> <span class="n">g_imag</span> <span class="o">=</span> <span class="n">g_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">g_data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">g_exp</span> <span class="o">=</span> <span class="n">g_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">g_full</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_real</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">g_imag</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">g_exp</span>

                <span class="c1"># Select frequencies that are loaded from the file</span>
                <span class="n">g_sel</span> <span class="o">=</span> <span class="n">g_full</span><span class="p">[</span><span class="n">fsel</span><span class="p">]</span>

                <span class="n">gain</span><span class="p">[:,</span> <span class="n">input_sel_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="p">)]</span> <span class="o">=</span> <span class="n">g_sel</span>

        <span class="c1"># Gain array must be specified for all times, repeat along the time axis</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ntime</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ninput</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>

        <span class="c1"># Check that the gain datasets have been loaded</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;gain_coeff&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;gain_exp&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Required gain datasets not loaded from file (&gt; v2.2.0), &quot;</span>
                <span class="s2">&quot;using unit gains.&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract the gain datasets from the file</span>
            <span class="n">gain_exp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain_exp&quot;</span><span class="p">][:]</span>
            <span class="n">gain_coeff</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gain_coeff&quot;</span><span class="p">][:]</span>

            <span class="c1"># Turn into a single array</span>
            <span class="k">if</span> <span class="n">gain_coeff</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span>
                <span class="n">gain</span> <span class="o">*=</span> <span class="n">gain_coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gain</span><span class="o">.</span><span class="n">real</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain_coeff</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span>
                <span class="n">gain</span><span class="o">.</span><span class="n">imag</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain_coeff</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span>
            <span class="n">gain</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">gain_exp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="c1"># Add gain dataset to object, and create axis attribute</span>
    <span class="n">gain_dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;gain&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>
    <span class="n">gain_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">])</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013–2024, CHIME Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>