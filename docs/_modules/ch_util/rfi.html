

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ch_util.rfi &mdash; ch_util 25.8.0.post7+git.687d3a3f documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/katex-math.css?v=05624691" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c157ac5c"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/katex.min.js?v=5cc8ed51"></script>
      <script src="../../_static/auto-render.min.js?v=af98beb9"></script>
      <script src="../../_static/katex_autorenderer.js?v=bebc588a"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ch_util
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ch_util</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ch_util.rfi</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ch_util.rfi</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tools for RFI flagging</span>

<span class="sd">This module contains tools for finding and removing Radio Frequency Interference</span>
<span class="sd">(RFI).</span>

<span class="sd">Note that this generates masks where the elements containing RFI are marked as</span>
<span class="sd">:obj:`True`, and the remaining elements are marked :obj:`False`. This is in</span>
<span class="sd">contrast to the routines in :mod:`ch_pipeline.rfi` which generates a inverse</span>
<span class="sd">noise weighting, where RFI containing elements are effectively :obj:`False`, and</span>
<span class="sd">the remainder are :obj:`True`.</span>

<span class="sd">There are general purpose routines for flagging RFI in `andata` like datasets:</span>

<span class="sd">- :py:meth:`flag_dataset`</span>
<span class="sd">- :py:meth:`number_deviations`</span>

<span class="sd">For more control there are specific routines that can be called:</span>

<span class="sd">- :py:meth:`mad_cut_2d`</span>
<span class="sd">- :py:meth:`mad_cut_1d`</span>
<span class="sd">- :py:meth:`mad_cut_rolling`</span>
<span class="sd">- :py:meth:`spectral_cut`</span>
<span class="sd">- :py:meth:`frequency_mask`</span>
<span class="sd">- :py:meth:`sir1d`</span>
<span class="sd">- :py:meth:`sir`</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sig</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">chime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span>

<span class="c1"># Set up logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NullHandler</span><span class="p">())</span>


<span class="c1"># Ranges of bad frequencies given by their start time (in unix time) and</span>
<span class="c1"># corresponding start and end frequencies (in MHz)</span>
<span class="c1"># If the start time is not specified, t = [], the flag is applied to all CSDs</span>
<span class="n">BAD_FREQUENCIES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;chime&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="c1">### Bad bands at first light</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">449.41</span><span class="p">,</span> <span class="mf">450.98</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">454.88</span><span class="p">,</span> <span class="mf">456.05</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">457.62</span><span class="p">,</span> <span class="mf">459.18</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">483.01</span><span class="p">,</span> <span class="mf">485.35</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">487.70</span><span class="p">,</span> <span class="mf">494.34</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">497.85</span><span class="p">,</span> <span class="mf">506.05</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">529.10</span><span class="p">,</span> <span class="mf">536.52</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">541.60</span><span class="p">,</span> <span class="mf">548.00</span><span class="p">]],</span>
        <span class="c1">### Additional bad bands</span>
        <span class="c1"># Narrow, high power bands visible in sensitivities and</span>
        <span class="c1"># some longer baselines. There is some sporadic rfi in between</span>
        <span class="c1"># the two bands</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">460.15</span><span class="p">,</span> <span class="mf">460.55</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">464.00</span><span class="p">,</span> <span class="mf">470.32</span><span class="p">]],</span>
        <span class="c1"># 6 MHz band (reported by Simon)</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">505.85</span><span class="p">,</span> <span class="mf">511.71</span><span class="p">]],</span>
        <span class="c1"># Bright band which has been present since early on</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">517.97</span><span class="p">,</span> <span class="mf">525.00</span><span class="p">]],</span>
        <span class="c1"># UHF TV Channel 27 ending CSD 3212 inclusive (2022/08/24)</span>
        <span class="c1"># This is extended until CSD 3446 (2023/04/13) to account for gain errors</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1681410777</span><span class="p">],</span> <span class="p">[</span><span class="mf">548.00</span><span class="p">,</span> <span class="mf">554.49</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">564.65</span><span class="p">,</span> <span class="mf">578.00</span><span class="p">]],</span>
        <span class="c1"># UHF TV Channel 32 ending CSD 3213 inclusive (2022/08/25)</span>
        <span class="c1"># This is extended until CSD 3446 (2023/04/13) to account for gain errors</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1681410777</span><span class="p">],</span> <span class="p">[</span><span class="mf">578.00</span><span class="p">,</span> <span class="mf">585.35</span><span class="p">]],</span>
        <span class="c1"># from CSD 2893 (2021/10/09 - ) UHF TV Channel 33 (reported by Seth)</span>
        <span class="p">[[</span><span class="mi">1633758888</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">584.00</span><span class="p">,</span> <span class="mf">590.00</span><span class="p">]],</span>
        <span class="c1"># UHF TV Channel 35</span>
        <span class="p">[[</span><span class="mi">1633758888</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">596.00</span><span class="p">,</span> <span class="mf">602.00</span><span class="p">]],</span>
        <span class="c1"># Low power band visible in long baselines</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">602.00</span><span class="p">,</span> <span class="mf">607.82</span><span class="p">]],</span>
        <span class="c1"># from CSD 2243 (2019/12/31 - ) Rogersâ€™ new 600 MHz band</span>
        <span class="p">[[</span><span class="mi">1577755022</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">617.00</span><span class="p">,</span> <span class="mf">627.00</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">693.16</span><span class="p">,</span> <span class="mf">693.55</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">694.34</span><span class="p">,</span> <span class="mf">696.68</span><span class="p">]],</span>
        <span class="c1"># from CSD 2080 (2019/07/21 - ) Blobs, Channels 55 and 56</span>
        <span class="p">[[</span><span class="mi">1564051033</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">716.00</span><span class="p">,</span> <span class="mf">728.00</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">729.88</span><span class="p">,</span> <span class="mf">745.12</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">746.29</span><span class="p">,</span> <span class="mf">756.45</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="s2">&quot;kko&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="c1"># Bad bands from statistical analysis of Jan 20, 2023 N2 data</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">433.59</span><span class="p">,</span> <span class="mf">433.98</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">439.84</span><span class="p">,</span> <span class="mf">440.62</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">483.20</span><span class="p">,</span> <span class="mf">484.38</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">616.80</span><span class="p">,</span> <span class="mf">626.95</span><span class="p">]],</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">799.61</span><span class="p">,</span> <span class="mf">800.00</span><span class="p">]],</span>
        <span class="c1"># Notch filter stoppband + leakage</span>
        <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[</span><span class="mf">710.55</span><span class="p">,</span> <span class="mf">757.81</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="s2">&quot;gbo&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;hco&quot;</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">}</span>


<div class="viewcode-block" id="flag_dataset">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.flag_dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flag_dataset</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">freq_width</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">time_width</span><span class="o">=</span><span class="mf">420.0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">flag1d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rolling</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;RFI flag the dataset.  This function wraps `number_deviations`,</span>
<span class="sd">    and remains largely for backwards compatability.  The pipeline code</span>
<span class="sd">    now calls `number_deviations` directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : `andata.CorrData`</span>
<span class="sd">        Must contain vis and weight attribute that are both</span>
<span class="sd">        `np.ndarray[nfreq, nprod, ntime]`.  Note that this</span>
<span class="sd">        function does not work with CorrData that has</span>
<span class="sd">        been stacked over redundant baselines.</span>
<span class="sd">    freq_width : float</span>
<span class="sd">        Frequency interval in *MHz* to compare across.</span>
<span class="sd">    time_width : float</span>
<span class="sd">        Time interval in *seconds* to compare.</span>
<span class="sd">    threshold : float</span>
<span class="sd">        Threshold in MAD over which to cut out RFI.</span>
<span class="sd">    rolling : bool</span>
<span class="sd">        Use a rolling window instead of distinct blocks.</span>
<span class="sd">    flag1d : bool, optional</span>
<span class="sd">        Only apply the MAD cut in the time direction. This is useful if the</span>
<span class="sd">        frequency coverage is sparse.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray</span>
<span class="sd">        RFI mask, output shape is the same as input visibilities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">auto_ii</span><span class="p">,</span> <span class="n">auto_vis</span><span class="p">,</span> <span class="n">auto_ndev</span> <span class="o">=</span> <span class="n">number_deviations</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">freq_width</span><span class="o">=</span><span class="n">freq_width</span><span class="p">,</span>
        <span class="n">time_width</span><span class="o">=</span><span class="n">time_width</span><span class="p">,</span>
        <span class="n">flag1d</span><span class="o">=</span><span class="n">flag1d</span><span class="p">,</span>
        <span class="n">rolling</span><span class="o">=</span><span class="n">rolling</span><span class="p">,</span>
        <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">auto_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">auto_ndev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span>

    <span class="c1"># Apply the frequency cut to the data (add here because we are distributed</span>
    <span class="c1"># over products and its easy)</span>
    <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">])</span>

    <span class="n">freq_mask</span> <span class="o">=</span> <span class="n">frequency_mask</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[:],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="n">auto_ii</span><span class="p">,</span> <span class="n">auto_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">auto_mask</span><span class="p">,</span> <span class="n">freq_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="c1"># Create an empty mask for the full dataset</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Loop over all products and flag if either inputs auto correlation was flagged</span>
    <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">nprod</span><span class="p">):</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">ij</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][</span><span class="n">pi</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">auto_ii</span><span class="p">:</span>
            <span class="n">ai</span> <span class="o">=</span> <span class="n">auto_ii</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[:,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">[:,</span> <span class="n">pi</span><span class="p">],</span> <span class="n">auto_mask</span><span class="p">[:,</span> <span class="n">ai</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ij</span> <span class="ow">in</span> <span class="n">auto_ii</span><span class="p">:</span>
            <span class="n">aj</span> <span class="o">=</span> <span class="n">auto_ii</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ij</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[:,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">[:,</span> <span class="n">pi</span><span class="p">],</span> <span class="n">auto_mask</span><span class="p">[:,</span> <span class="n">aj</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">mask</span></div>



<div class="viewcode-block" id="number_deviations">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.number_deviations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">number_deviations</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">freq_width</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
    <span class="n">time_width</span><span class="o">=</span><span class="mf">420.0</span><span class="p">,</span>
    <span class="n">flag1d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">apply_static_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">rolling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the number of median absolute deviations (MAD)</span>
<span class="sd">    of the autocorrelations from the local median.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : `andata.CorrData`</span>
<span class="sd">        Must contain vis and weight attributes that are both</span>
<span class="sd">        `np.ndarray[nfreq, nprod, ntime]`.</span>
<span class="sd">    freq_width : float</span>
<span class="sd">        Frequency interval in *MHz* to compare across.</span>
<span class="sd">    time_width : float</span>
<span class="sd">        Time interval in *seconds* to compare across.</span>
<span class="sd">    flag1d : bool</span>
<span class="sd">        Only apply the MAD cut in the time direction. This is useful if the</span>
<span class="sd">        frequency coverage is sparse.</span>
<span class="sd">    apply_static_mask : bool</span>
<span class="sd">        Apply static mask obtained from `frequency_mask` before computing</span>
<span class="sd">        the median absolute deviation.</span>
<span class="sd">    rolling : bool</span>
<span class="sd">        Use a rolling window instead of distinct blocks.</span>
<span class="sd">    stack: bool</span>
<span class="sd">        Average over all autocorrelations.</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        Normalize by the median value over time prior to averaging over</span>
<span class="sd">        autocorrelations.  Only relevant if `stack` is True.</span>
<span class="sd">    fill_value: float</span>
<span class="sd">        Data that was already flagged as bad will be set to this value in</span>
<span class="sd">        the output array.  Should be a large positive value that is greater</span>
<span class="sd">        than the threshold that will be placed.  Default is float(&#39;Inf&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    auto_ii: np.ndarray[ninput,]</span>
<span class="sd">        Index of the inputs that have been processed.</span>
<span class="sd">        If stack is True, then [0] will be returned.</span>

<span class="sd">    auto_vis: np.ndarray[nfreq, ninput, ntime]</span>
<span class="sd">        The autocorrelations that were used to calculate</span>
<span class="sd">        the number of deviations.</span>

<span class="sd">    ndev : np.ndarray[nfreq, ninput, ntime]</span>
<span class="sd">        Number of median absolute deviations of the autocorrelations</span>
<span class="sd">        from the local median.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">memh5</span><span class="p">,</span> <span class="n">mpiarray</span>

    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;Inf&quot;</span><span class="p">)</span>

    <span class="c1"># Check if dataset is parallel</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">memh5</span><span class="o">.</span><span class="n">MemDatasetDistributed</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

    <span class="c1"># Extract the auto correlations</span>
    <span class="n">auto_ii</span><span class="p">,</span> <span class="n">auto_vis</span><span class="p">,</span> <span class="n">auto_flag</span> <span class="o">=</span> <span class="n">get_autocorrelations</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">normalize</span><span class="p">)</span>

    <span class="c1"># Calculate time interval in samples. If the data has an ra axis instead,</span>
    <span class="c1"># use an estimation of the time per sample</span>
    <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">twidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_width</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">))))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">twidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_width</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ra</span><span class="p">[:])</span> <span class="o">/</span> <span class="mf">86164.0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected data type with a `time` or `ra` axis. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Create static flag of frequencies that are known to be bad</span>
    <span class="n">static_flag</span> <span class="o">=</span> <span class="p">(</span>
        <span class="o">~</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[:],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apply_static_mask</span>
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="c1"># Ensure these are distributed across frequency</span>
        <span class="n">auto_vis</span> <span class="o">=</span> <span class="n">auto_vis</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">auto_flag</span> <span class="o">=</span> <span class="n">auto_flag</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">static_flag</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">static_flag</span><span class="p">[</span><span class="n">auto_vis</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate frequency interval in bins</span>
    <span class="n">fwidth</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">freq_width</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">))))</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">flag1d</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># Create an empty array for number of median absolute deviations</span>
    <span class="n">ndev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">auto_vis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">auto_flag_view</span> <span class="o">=</span> <span class="n">auto_flag</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span> <span class="k">if</span> <span class="n">parallel</span> <span class="k">else</span> <span class="n">auto_flag</span>
    <span class="n">static_flag_view</span> <span class="o">=</span> <span class="n">static_flag</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span> <span class="k">if</span> <span class="n">parallel</span> <span class="k">else</span> <span class="n">static_flag</span>
    <span class="n">ndev_view</span> <span class="o">=</span> <span class="n">ndev</span><span class="o">.</span><span class="n">local_array</span> <span class="k">if</span> <span class="n">parallel</span> <span class="k">else</span> <span class="n">ndev</span>

    <span class="c1"># Loop over extracted autos and create a mask for each</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">auto_vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">flg</span> <span class="o">=</span> <span class="n">static_flag_view</span> <span class="o">&amp;</span> <span class="n">auto_flag_view</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
        <span class="c1"># Gather enire array onto each rank</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">auto_vis</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span> <span class="k">if</span> <span class="n">parallel</span> <span class="k">else</span> <span class="n">auto_vis</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
        <span class="c1"># Use NaNs to ignore previously flagged data when computing the MAD</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flg</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">local_bounds</span> <span class="o">=</span> <span class="n">auto_vis</span><span class="o">.</span><span class="n">local_bounds</span> <span class="k">if</span> <span class="n">parallel</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Apply RFI flagger</span>
        <span class="k">if</span> <span class="n">rolling</span><span class="p">:</span>
            <span class="c1"># Limit bounds to the local portion of the array</span>
            <span class="n">ndev_i</span> <span class="o">=</span> <span class="n">mad_cut_rolling</span><span class="p">(</span>
                <span class="n">arr</span><span class="p">,</span> <span class="n">twidth</span><span class="o">=</span><span class="n">twidth</span><span class="p">,</span> <span class="n">fwidth</span><span class="o">=</span><span class="n">fwidth</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit_range</span><span class="o">=</span><span class="n">local_bounds</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">flag1d</span><span class="p">:</span>
            <span class="n">ndev_i</span> <span class="o">=</span> <span class="n">mad_cut_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">local_bounds</span><span class="p">,</span> <span class="p">:],</span> <span class="n">twidth</span><span class="o">=</span><span class="n">twidth</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ndev_i</span> <span class="o">=</span> <span class="n">mad_cut_2d</span><span class="p">(</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">local_bounds</span><span class="p">,</span> <span class="p">:],</span> <span class="n">twidth</span><span class="o">=</span><span class="n">twidth</span><span class="p">,</span> <span class="n">fwidth</span><span class="o">=</span><span class="n">fwidth</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="n">ndev_view</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ndev_i</span>

    <span class="c1"># Fill any values equal to NaN with the user specified fill value</span>
    <span class="n">ndev_view</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ndev_view</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">return</span> <span class="n">auto_ii</span><span class="p">,</span> <span class="n">auto_vis</span><span class="p">,</span> <span class="n">ndev</span></div>



<div class="viewcode-block" id="get_autocorrelations">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.get_autocorrelations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_autocorrelations</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract autocorrelations from a data stack.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : `andata.CorrData`</span>
<span class="sd">        Must contain vis and weight attributes that are both</span>
<span class="sd">        `np.ndarray[nfreq, nprod, ntime]`.</span>
<span class="sd">    stack: bool, optional</span>
<span class="sd">        Average over all autocorrelations.</span>
<span class="sd">    normalize : bool, optional</span>
<span class="sd">        Normalize by the median value over time prior to averaging over</span>
<span class="sd">        autocorrelations.  Only relevant if `stack` is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    auto_ii: np.ndarray[ninput,]</span>
<span class="sd">        Index of the inputs that have been processed.</span>
<span class="sd">        If stack is True, then [0] will be returned.</span>

<span class="sd">    auto_vis: np.ndarray[nfreq, ninput, ntime]</span>
<span class="sd">        The autocorrelations that were used to calculate</span>
<span class="sd">        the number of deviations.</span>

<span class="sd">    auto_flag: np.ndarray[nfreq, ninput, ntime]</span>
<span class="sd">        Indices where data weights are positive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract the auto correlations</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>
    <span class="n">auto_ii</span><span class="p">,</span> <span class="n">auto_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span> <span class="k">if</span> <span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="p">)</span>

    <span class="n">auto_vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">auto_pi</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># If requested, average over all inputs to construct the stacked autocorrelations</span>
    <span class="c1"># for the instrument (also known as the incoherent beam)</span>
    <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="n">auto_pi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Do not include bad inputs in the average</span>
        <span class="n">partial_stack</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_stack</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;input_flags&quot;</span><span class="p">):</span>
            <span class="n">input_flags</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span>
            <span class="n">good_inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_flags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are on average </span><span class="si">{</span><span class="n">good_inputs</span><span class="si">}</span><span class="s2"> good inputs.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">input_flags</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">input_flags</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying input_flags to weight.&quot;</span><span class="p">)</span>
                <span class="n">weight</span> <span class="o">*=</span> <span class="n">input_flags</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">auto_ii</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Normalizing autocorrelations prior to stacking.&quot;</span><span class="p">)</span>
            <span class="n">med_auto</span> <span class="o">=</span> <span class="n">nanmedian</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">auto_vis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">med_auto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">med_auto</span><span class="p">),</span> <span class="n">med_auto</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">auto_vis</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med_auto</span><span class="p">)</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">auto_vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">weight</span> <span class="o">*</span> <span class="n">auto_vis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

        <span class="n">auto_flag</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="n">auto_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">auto_flag</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="n">auto_pi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">auto_ii</span><span class="p">,</span> <span class="n">auto_vis</span><span class="p">,</span> <span class="n">auto_flag</span></div>



<div class="viewcode-block" id="spectral_cut">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.spectral_cut">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectral_cut</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fil_window</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">only_autos</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag out the TV bands, or other constant spectral RFI.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : `andata.obj`</span>
<span class="sd">        If `only_autos` shape is (freq, n_feeds, time), else (freq, n_prod,</span>
<span class="sd">        time).</span>
<span class="sd">    fil_window : integer</span>
<span class="sd">        Window of median filter for baseline of chime spectrum. Default is 15.</span>
<span class="sd">    only_autos : boolean</span>
<span class="sd">        Whether data contains only autos or not.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask: np.ndarray[freq,time]</span>
<span class="sd">          RFI mask (no product axis).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">only_autos</span><span class="p">:</span>
        <span class="n">data_vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nfeed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">auto_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">tools</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfeed</span><span class="p">)]</span>
        <span class="n">data_vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">auto_ind</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>

    <span class="n">stack_autos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data_vis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">stack_autos_time_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stack_autos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Locations of the generally decent frequency bands</span>
    <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">])</span>

    <span class="n">drawn_bool_mask</span> <span class="o">=</span> <span class="n">frequency_mask</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[:],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>
    <span class="n">good_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">drawn_bool_mask</span><span class="p">)</span>

    <span class="c1"># Calculate standard deivation of the average channel</span>
    <span class="n">std_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">stack_autos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">std_arr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">stack_autos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># standard deviation of the mean</span>

    <span class="c1"># Smooth with a median filter, and then interpolate to estimate the</span>
    <span class="c1"># baseline of the spectrum</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">medfilt</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">stack_autos_time_ave</span><span class="p">[</span><span class="n">good_data</span><span class="p">],</span> <span class="n">fil_window</span><span class="p">)</span>
    <span class="n">interpolat_arr_baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fa</span><span class="p">[</span><span class="n">good_data</span><span class="p">],</span> <span class="n">medfilt</span><span class="p">)</span>
    <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">stack_autos_time_ave</span> <span class="o">-</span> <span class="n">interpolat_arr_baseline</span>

    <span class="c1"># Mask out frequencies with too much power</span>
    <span class="n">mask_1d</span> <span class="o">=</span> <span class="n">rel_pow</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sigma</span>

    <span class="c1"># Generate mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data_vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask_1d</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mask</span></div>



<div class="viewcode-block" id="frequency_mask">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.frequency_mask">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">frequency_mask</span><span class="p">(</span>
    <span class="n">freq_centre</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">freq_width</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">instrument</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;chime&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag known bad frequencies.</span>

<span class="sd">    Time dependent static RFI flags that affect the recent observations are added.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq_centre</span>
<span class="sd">        Centre of each frequency channel</span>
<span class="sd">    freq_width</span>
<span class="sd">        Width of each frequency channel. If `None` (default), calculate the width from</span>
<span class="sd">        the frequency centre separation. If supplied as an array it must be</span>
<span class="sd">        broadcastable</span>
<span class="sd">        against `freq_centre`.</span>
<span class="sd">    timestamp</span>
<span class="sd">        UNIX observing time. If `None` (default) mask all specified bands regardless of</span>
<span class="sd">        their start/end times, otherwise mask only timestamps within the band start and</span>
<span class="sd">        end times. If supplied as an array it must be broadcastable against</span>
<span class="sd">        `freq_centre`.</span>
<span class="sd">    instrument</span>
<span class="sd">        Telescope name. [kko, gbo, hco, chime (default)]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask</span>
<span class="sd">        An array marking the bad frequency channels. The final shape is the result of</span>
<span class="sd">        broadcasting `freq_centre` and `timestamp` together.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">freq_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq_centre</span><span class="p">)))</span>

    <span class="n">freq_start</span> <span class="o">=</span> <span class="n">freq_centre</span> <span class="o">-</span> <span class="n">freq_width</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">freq_end</span> <span class="o">=</span> <span class="n">freq_centre</span> <span class="o">+</span> <span class="n">freq_width</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Broadcast to get the output mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">freq_centre</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">bad_freq</span> <span class="o">=</span> <span class="n">BAD_FREQUENCIES</span><span class="p">[</span><span class="n">instrument</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No RFI flags defined for </span><span class="si">{</span><span class="n">instrument</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">),</span> <span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">fe</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bad_freq</span><span class="p">:</span>
        <span class="n">fmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_end</span> <span class="o">&gt;</span> <span class="n">fs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_start</span> <span class="o">&lt;</span> <span class="n">fe</span><span class="p">)</span>

        <span class="c1"># If we don&#39;t have a timestamp then just mask all bands</span>
        <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmask</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise calculate the mask based on the start and end times</span>
            <span class="n">tmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmask</span> <span class="o">&amp;=</span> <span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">start_time</span>

            <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmask</span> <span class="o">&amp;=</span> <span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">end_time</span>

        <span class="c1"># Mask frequencies and times specified in this band</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="n">tmask</span> <span class="o">&amp;</span> <span class="n">fmask</span>

    <span class="k">return</span> <span class="n">mask</span></div>



<div class="viewcode-block" id="mad_cut_2d">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.mad_cut_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mad_cut_2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fwidth</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">twidth</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">freq_flat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out RFI using a median absolute deviation cut in time-frequency blocks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[freq, time]</span>
<span class="sd">        Array of data to mask.</span>
<span class="sd">    fwidth : integer, optional</span>
<span class="sd">        Number of frequency samples to average median over.</span>
<span class="sd">    twidth : integer, optional</span>
<span class="sd">        Number of time samples to average median over.</span>
<span class="sd">    threshold : scalar, optional</span>
<span class="sd">        Number of median deviations above which we cut the data.</span>
<span class="sd">    freq_flat : boolean, optional</span>
<span class="sd">        Flatten in the frequency direction by dividing through by the median.</span>
<span class="sd">    mask : boolean, optional</span>
<span class="sd">        If True return the mask, if False return the number of</span>
<span class="sd">        median absolute deviations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray[freq, time]</span>
<span class="sd">        Mask or number of median absolute deviations for each sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">median</span> <span class="o">=</span> <span class="n">nanmedian</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>

    <span class="n">flen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fwidth</span><span class="p">))</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">twidth</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">madmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">madmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">freq_flat</span><span class="p">:</span>
        <span class="c1"># Flatten</span>
        <span class="n">mfd</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">mfd</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1">## Iterate over all frequency and time blocks</span>
    <span class="c1">#</span>
    <span class="c1"># This can be done more quickly by reshaping the arrays into blocks, but</span>
    <span class="c1"># only works when there are an integer number of blocks. Probably best to</span>
    <span class="c1"># rewrite in cython.</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">flen</span><span class="p">):</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">fi</span> <span class="o">*</span> <span class="n">fwidth</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">fi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fwidth</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tlen</span><span class="p">):</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">ti</span> <span class="o">*</span> <span class="n">twidth</span>
            <span class="n">te</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">ti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">twidth</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">dsec</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">fs</span><span class="p">:</span><span class="n">fe</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span><span class="n">te</span><span class="p">]</span>
            <span class="n">msec</span> <span class="o">=</span> <span class="n">madmask</span><span class="p">[</span><span class="n">fs</span><span class="p">:</span><span class="n">fe</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span><span class="n">te</span><span class="p">]</span>

            <span class="n">mval</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">dsec</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">dsec</span> <span class="o">-</span> <span class="n">mval</span>
            <span class="n">med_abs_dev</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

            <span class="n">med_inv</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med_abs_dev</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">msec</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">*</span> <span class="n">med_inv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">*</span> <span class="n">med_inv</span>

    <span class="k">return</span> <span class="n">madmask</span></div>



<div class="viewcode-block" id="mad_cut_1d">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.mad_cut_1d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mad_cut_1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">twidth</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out RFI using a median absolute deviation cut in the time direction.</span>

<span class="sd">    This is useful for datasets with sparse frequency coverage. Functionally</span>
<span class="sd">    this routine is equivalent to :func:`mad_cut_2d` with `fwidth = 1`, but will</span>
<span class="sd">    be much faster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[freq, time]</span>
<span class="sd">        Array of data to mask.</span>
<span class="sd">    twidth : integer, optional</span>
<span class="sd">        Number of time samples to average median over.</span>
<span class="sd">    threshold : scalar, optional</span>
<span class="sd">        Number of median deviations above which we cut the data.</span>
<span class="sd">    mask : boolean, optional</span>
<span class="sd">        If True return the mask, if False return the number of</span>
<span class="sd">        median absolute deviations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray[freq, time]</span>
<span class="sd">        Mask or number of median absolute deviations for each sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">median</span> <span class="o">=</span> <span class="n">nanmedian</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>

    <span class="n">tlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">twidth</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">madmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">madmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1">## Iterate over all time chunks</span>
    <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tlen</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ti</span> <span class="o">*</span> <span class="n">twidth</span>
        <span class="n">te</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">ti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">twidth</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">dsec</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">ts</span><span class="p">:</span><span class="n">te</span><span class="p">]</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">madmask</span><span class="p">[:,</span> <span class="n">ts</span><span class="p">:</span><span class="n">te</span><span class="p">]</span>

        <span class="n">mval</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">dsec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">dsec</span> <span class="o">-</span> <span class="n">mval</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">med_abs_dev</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">med_inv</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med_abs_dev</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">msec</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">*</span> <span class="n">med_inv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">*</span> <span class="n">med_inv</span>

    <span class="k">return</span> <span class="n">madmask</span></div>



<span class="c1"># Define several functions for creating 2D rolling window</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rolling_window_lastaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_rolling_window</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_rolling_window_lastaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">win</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_rolling_window_lastaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">win</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<div class="viewcode-block" id="mad_cut_rolling">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.mad_cut_rolling">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mad_cut_rolling</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">fwidth</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
    <span class="n">twidth</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
    <span class="n">freq_flat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">limit_range</span><span class="p">:</span> <span class="nb">slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out RFI by placing a cut on the absolute deviation.</span>
<span class="sd">    Compared to `mad_cut_2d`, this function calculates</span>
<span class="sd">    the median and median absolute deviation using a rolling</span>
<span class="sd">    2D median filter, i.e., for every (freq, time) sample a</span>
<span class="sd">    separate estimates of these statistics is obtained for a</span>
<span class="sd">    window that is centered on that sample.</span>

<span class="sd">    For sparsely sampled frequency axis, set fwidth = 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[freq, time]</span>
<span class="sd">        Array of data to mask.</span>
<span class="sd">    fwidth : integer, optional</span>
<span class="sd">        Number of frequency samples to calculate median over.</span>
<span class="sd">    twidth : integer, optional</span>
<span class="sd">        Number of time samples to calculate median over.</span>
<span class="sd">    threshold : scalar, optional</span>
<span class="sd">        Number of median absolute deviations above which we cut the data.</span>
<span class="sd">    freq_flat : boolean, optional</span>
<span class="sd">        Flatten in the frequency direction by dividing each frequency</span>
<span class="sd">        by the median over time.</span>
<span class="sd">    mask : boolean, optional</span>
<span class="sd">        If True return the mask, if False return the number of</span>
<span class="sd">        median absolute deviations.</span>
<span class="sd">    limit_range : slice, optional</span>
<span class="sd">        Data is limited to this range in the freqeuncy axis. Defaults to slice(None).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray[freq, time]</span>
<span class="sd">        Mask or number of median absolute deviations for each sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure we have an odd number of samples</span>
    <span class="n">fwidth</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">fwidth</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">twidth</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">twidth</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">foff</span> <span class="o">=</span> <span class="n">fwidth</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">toff</span> <span class="o">=</span> <span class="n">twidth</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">nfreq</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># If requested, flatten over the frequency direction.</span>
    <span class="k">if</span> <span class="n">freq_flat</span><span class="p">:</span>
        <span class="n">mfd</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">mfd</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Add NaNs around the edges of the array so that we don&#39;t have to</span>
    <span class="c1"># treat them separately</span>
    <span class="n">eshp</span> <span class="o">=</span> <span class="p">[</span><span class="n">nfreq</span> <span class="o">+</span> <span class="n">fwidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">+</span> <span class="n">twidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">exp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">eshp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">exp_data</span><span class="p">[</span><span class="n">foff</span> <span class="p">:</span> <span class="n">foff</span> <span class="o">+</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">toff</span> <span class="p">:</span> <span class="n">toff</span> <span class="o">+</span> <span class="n">ntime</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">if</span> <span class="n">limit_range</span> <span class="o">!=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Get only desired slice</span>
        <span class="n">expsl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">limit_range</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="nb">min</span><span class="p">(</span><span class="n">limit_range</span><span class="o">.</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">foff</span><span class="p">,</span> <span class="n">exp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">dsl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">limit_range</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">limit_range</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">exp_data</span> <span class="o">=</span> <span class="n">exp_data</span><span class="p">[</span><span class="n">expsl</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">dsl</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Use numpy slices to construct the rolling windowed data</span>
    <span class="n">win_data</span> <span class="o">=</span> <span class="n">_rolling_window</span><span class="p">(</span><span class="n">exp_data</span><span class="p">,</span> <span class="p">(</span><span class="n">fwidth</span><span class="p">,</span> <span class="n">twidth</span><span class="p">))</span>

    <span class="c1"># Compute the local median and median absolute deviation</span>
    <span class="n">med</span> <span class="o">=</span> <span class="n">nanmedian</span><span class="p">(</span><span class="n">win_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">med_abs_dev</span> <span class="o">=</span> <span class="n">nanmedian</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">win_data</span> <span class="o">-</span> <span class="n">med</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">inv_med_abs_dev</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med_abs_dev</span><span class="p">)</span>

    <span class="c1"># Calculate and return the mask or the number of median absolute deviations</span>
    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">madmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">med</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_med_abs_dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">madmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">med</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_med_abs_dev</span>

    <span class="k">return</span> <span class="n">madmask</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">nanmedian</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;All-NaN (slice|axis) encountered&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># Iterative HPF masking for identifying narrow-band features in gains or spectra</span>
<div class="viewcode-block" id="highpass_delay_filter">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.highpass_delay_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">highpass_delay_filter</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau_cut</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a high-pass delay filter.</span>

<span class="sd">    The stop band will range from [-tau_cut, tau_cut].</span>
<span class="sd">    DAYENU is used to construct the filter in the presence</span>
<span class="sd">    of masked frequencies.  See Ewall-Wice et al. 2021</span>
<span class="sd">    (arXiv:2004.11397) for a description.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq : np.ndarray[nfreq,]</span>
<span class="sd">        Frequency in MHz.</span>
<span class="sd">    tau_cut : float</span>
<span class="sd">        The half width of the stop band in micro-seconds.</span>
<span class="sd">    flag : np.ndarray[nfreq,]</span>
<span class="sd">        Boolean flag that indicates what frequencies are valid.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        The stop-band rejection of the filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pinv : np.ndarray[nfreq, nfreq]</span>
<span class="sd">        High pass delay filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nfreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">size</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">nfreq</span><span class="p">)</span>

    <span class="n">mflag</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau_cut</span> <span class="o">*</span> <span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">freq</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="n">epsilon</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">cov</span> <span class="o">*</span> <span class="n">mflag</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">mflag</span></div>



<div class="viewcode-block" id="iterative_hpf_masking">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.iterative_hpf_masking">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iterative_hpf_masking</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">,</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">tau_cut</span><span class="o">=</span><span class="mf">0.60</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="mi">65</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span>
    <span class="n">nperiter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">niter</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
    <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask features in a spectrum that have significant power at high delays.</span>

<span class="sd">    Uses the following iterative procedure to generate the mask:</span>

<span class="sd">        - Apply a high-pass filter to the spectrum.</span>
<span class="sd">        - For each frequency channel, calculate the median absolute</span>
<span class="sd">          deviation of nearby frequency channels to get an estimate</span>
<span class="sd">          of the noise.  Divide the high-pass filtered spectrum by</span>
<span class="sd">          the noise estimate.</span>
<span class="sd">        - Mask excursions with the largest signal to noise.</span>
<span class="sd">        - Regenerate the high-pass filter using the new mask.</span>
<span class="sd">        - Repeat.</span>

<span class="sd">    The procedure stops when the maximum number of iterations is reached</span>
<span class="sd">    or there are no excursions beyond some threshold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq: np.ndarray[nfreq,]</span>
<span class="sd">        Frequency in MHz.</span>
<span class="sd">    y: np.ndarray[nfreq,]</span>
<span class="sd">        Spectrum to search for narrowband features.</span>
<span class="sd">    flag: np.ndarray[nfreq,]</span>
<span class="sd">        Boolean flag where True indicates valid data.</span>
<span class="sd">    tau_cut: float</span>
<span class="sd">        Cutoff of the high-pass filter in microseconds.</span>
<span class="sd">    epsilon: float</span>
<span class="sd">        Stop-band rejection of the filter.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Number of median absolute deviations beyond which</span>
<span class="sd">        a frequency channel is considered an outlier.</span>
<span class="sd">    window: int</span>
<span class="sd">        Width of the window used to estimate the noise</span>
<span class="sd">        (by calculating a local median absolute deviation).</span>
<span class="sd">    nperiter: int</span>
<span class="sd">        Maximum number of frequency channels to flag</span>
<span class="sd">        on any iteration.</span>
<span class="sd">    niter: int</span>
<span class="sd">        Maximum number of iterations.</span>
<span class="sd">    timestamp : float</span>
<span class="sd">        Start observing time (in unix time)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yhpf: np.ndarray[nfreq,]</span>
<span class="sd">        The high-pass filtered spectrum generated using</span>
<span class="sd">        the mask from the last iteration.</span>
<span class="sd">    flag: np.ndarray[nfreq,]</span>
<span class="sd">        Boolean flag where True indicates valid data.</span>
<span class="sd">        This is the logical complement to the mask</span>
<span class="sd">        from the last iteration.</span>
<span class="sd">    rsigma: np.ndarray[nfreq,]</span>
<span class="sd">        The local median absolute deviation from the last</span>
<span class="sd">        iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">weighted_median</span>

    <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="c1"># Make sure the frequencies are float64, otherwise</span>
    <span class="c1"># can have problems with construction of filter</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Make sure the size of the window is odd</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">window</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># If an initial flag was not provided, then use the static rfi mask.</span>
    <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="o">~</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>

    <span class="c1"># We will be updating the flags on each iteration.  Make a copy of</span>
    <span class="c1"># the input so that we do not overwrite.</span>
    <span class="n">new_flag</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Iterate</span>
    <span class="n">itt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">itt</span> <span class="o">&lt;</span> <span class="n">niter</span><span class="p">:</span>
        <span class="c1"># Construct the filter using the current mask</span>
        <span class="n">NF</span> <span class="o">=</span> <span class="n">highpass_delay_filter</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau_cut</span><span class="p">,</span> <span class="n">new_flag</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>

        <span class="c1"># Apply the filter</span>
        <span class="n">yhpf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">NF</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Calculate the local median absolute deviation</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">yhpf</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">new_flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">rsigma</span> <span class="o">=</span> <span class="mf">1.48625</span> <span class="o">*</span> <span class="n">weighted_median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ry</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;split&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the signal to noise</span>
        <span class="n">rs2n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yhpf</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">rsigma</span><span class="p">))</span>

        <span class="c1"># Identify frequency channels that are above the signal to noise threshold</span>
        <span class="n">above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">rs2n</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">above_threshold</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Find the largest nperiter frequency channels that are above the threshold</span>
        <span class="n">ibad</span> <span class="o">=</span> <span class="n">above_threshold</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yhpf</span><span class="p">[</span><span class="n">above_threshold</span><span class="p">]))[</span><span class="mi">0</span><span class="p">:</span><span class="n">nperiter</span><span class="p">]]</span>

        <span class="c1"># Flag those frequency channels, increment the counter</span>
        <span class="n">new_flag</span><span class="p">[</span><span class="n">ibad</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">itt</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Construct and apply the filter using the final flag</span>
    <span class="n">NF</span> <span class="o">=</span> <span class="n">highpass_delay_filter</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">tau_cut</span><span class="p">,</span> <span class="n">new_flag</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>

    <span class="n">yhpf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">NF</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">yhpf</span><span class="p">,</span> <span class="n">new_flag</span><span class="p">,</span> <span class="n">rsigma</span></div>



<span class="c1"># Scale-invariant rank (SIR) functions</span>
<div class="viewcode-block" id="sir1d">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.sir1d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sir1d</span><span class="p">(</span><span class="n">basemask</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Numpy implementation of the scale-invariant rank (SIR) operator.</span>

<span class="sd">    For more information, see arXiv:1201.3364v2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basemask : numpy 1D array of boolean type</span>
<span class="sd">        Array with the threshold mask previously generated.</span>
<span class="sd">        1 (True) for flagged points, 0 (False) otherwise.</span>
<span class="sd">    eta : float</span>
<span class="sd">        Aggressiveness of the method: with eta=0, no additional samples are</span>
<span class="sd">        flagged and the function returns basemask. With eta=1, all samples</span>
<span class="sd">        will be flagged. The authors in arXiv:1201.3364v2 seem to be convinced</span>
<span class="sd">        that 0.2 is a mostly universally optimal value, but no optimization</span>
<span class="sd">        has been done on CHIME data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : numpy 1D array of boolean type</span>
<span class="sd">        The mask after the application of the (SIR) operator. Same shape and</span>
<span class="sd">        type as basemask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">basemask</span><span class="o">.</span><span class="n">size</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">basemask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">eta</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

    <span class="n">MP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">M</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">MQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">MQ</span> <span class="o">-</span> <span class="n">MP</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span></div>



<div class="viewcode-block" id="sir">
<a class="viewcode-back" href="../../_autosummary/ch_util.rfi.html#ch_util.rfi.sir">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sir</span><span class="p">(</span><span class="n">basemask</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">only_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_time</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply the SIR operator over the frequency and time axes for each product.</span>

<span class="sd">    This is a wrapper for `sir1d`.  It loops over times, applying `sir1d`</span>
<span class="sd">    across the frequency axis.  It then loops over frequencies, applying `sir1d`</span>
<span class="sd">    across the time axis.  It returns the logical OR of these two masks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basemask : np.ndarray[nfreq, nprod, ntime] of boolean type</span>
<span class="sd">        The previously generated threshold mask.</span>
<span class="sd">        1 (True) for masked points, 0 (False) otherwise.</span>
<span class="sd">    eta : float</span>
<span class="sd">        Aggressiveness of the method: with eta=0, no additional samples are</span>
<span class="sd">        flagged and the function returns basemask. With eta=1, all samples</span>
<span class="sd">        will be flagged.</span>
<span class="sd">    only_freq : bool</span>
<span class="sd">        Only apply the SIR operator across the frequency axis.</span>
<span class="sd">    only_time : bool</span>
<span class="sd">        Only apply the SIR operator across the time axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray[nfreq, nprod, ntime] of boolean type</span>
<span class="sd">        The mask after the application of the SIR operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">only_freq</span> <span class="ow">and</span> <span class="n">only_time</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of only_freq and only_time can be True.&quot;</span><span class="p">)</span>

    <span class="n">nfreq</span><span class="p">,</span> <span class="n">nprod</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">basemask</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">newmask</span> <span class="o">=</span> <span class="n">basemask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_time</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntime</span><span class="p">):</span>
                <span class="n">newmask</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">|=</span> <span class="n">sir1d</span><span class="p">(</span><span class="n">basemask</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_freq</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">):</span>
                <span class="n">newmask</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">|=</span> <span class="n">sir1d</span><span class="p">(</span><span class="n">basemask</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="p">:],</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newmask</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013â€“2024, CHIME Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>