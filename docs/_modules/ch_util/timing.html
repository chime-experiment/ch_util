

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ch_util.timing &mdash; ch_util 25.3.1.post7+git.a3fec444 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/katex-math.css?v=05624691" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1d928e64"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/katex.min.js?v=5cc8ed51"></script>
      <script src="../../_static/auto-render.min.js?v=af98beb9"></script>
      <script src="../../_static/katex_autorenderer.js?v=bebc588a"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ch_util
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ch_util</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ch_util.timing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ch_util.timing</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tools for timing jitter and delay corrections.</span>

<span class="sd">This module contains tools for using noise sources to correct</span>
<span class="sd">timing jitter and timing delay.</span>


<span class="sd">Example</span>
<span class="sd">=======</span>

<span class="sd">The function :meth:`construct_delay_template` generates a delay template from</span>
<span class="sd">measurements of the visibility between noise source inputs, which can</span>
<span class="sd">be used to remove the timing jitter in other data.</span>

<span class="sd">The user seldom needs to work with :meth:`construct_delay_template`</span>
<span class="sd">directly and can instead use several high-level functions and containers</span>
<span class="sd">that load the timing data, derive the timing correction using</span>
<span class="sd">:meth:`construct_delay_template`, and then enable easy application of</span>
<span class="sd">the timing correction to other data.</span>

<span class="sd">For example, to load the timing data and derive the timing correction from</span>
<span class="sd">a list of timing acquisition files (i.e., `YYYYMMSSTHHMMSSZ_chimetiming_corr`),</span>
<span class="sd">use the following:</span>

<span class="sd">    ```tdata = TimingData.from_acq_h5(timing_acq_filenames)```</span>

<span class="sd">This results in a :class:`andata.CorrData` object that has additional</span>
<span class="sd">methods avaiable for applying the timing correction to other data.</span>
<span class="sd">For example, to obtain the complex gain for some freq, input, and time</span>
<span class="sd">that upon multiplication will remove the timing jitter, use the following:</span>

<span class="sd">    ```tgain, tweight = tdata.get_gain(freq, input, time)```</span>

<span class="sd">To apply the timing correction to the visibilities in an :class:`andata.CorrData`</span>
<span class="sd">object called `data`, use the following:</span>

<span class="sd">    ```tdata.apply_timing_correction(data)```</span>

<span class="sd">The timing acquisitions must cover the span of time that you wish to correct.</span>
<span class="sd">If you have a list of data acquisition files and would like to obtain</span>
<span class="sd">the appropriate timing correction by searching the archive for the</span>
<span class="sd">corresponding timing acquisitons files, then use:</span>

<span class="sd">    ```tdata = load_timing_correction(data_acq_filenames_full_path)```</span>

<span class="sd">To print a summary of the timing correction, use:</span>

<span class="sd">    ```print(tdata)```</span>

<span class="sd">In April 2020, the CHIME pipeline began generating the timing correction in real time</span>
<span class="sd">and saving it to delay acquisitions (with format `YYYYMMSSTHHMMSSZ_chime_timing`).</span>
<span class="sd">To read in a timing correction generated by the real-time pipeline, use the following:</span>

<span class="sd">    ```tdata = TimingCorrection.from_acq_h5(delay_acq_filenames)```</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.interpolate</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.optimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">speed_of_light</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span><span class="p">,</span> <span class="n">andata</span><span class="p">,</span> <span class="n">rfi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">memh5</span><span class="p">,</span> <span class="n">mpiarray</span><span class="p">,</span> <span class="n">tod</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">caput.time</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ctime</span>

<span class="n">FREQ_TO_OMEGA</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-6</span>
<span class="n">FREQ_PIVOT</span> <span class="o">=</span> <span class="mf">600.0</span>

<span class="n">AXES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;update_time&quot;</span><span class="p">,</span> <span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="s2">&quot;series&quot;</span><span class="p">]</span>

<span class="n">DSET_SPEC</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;weight_tau&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;weight_alpha&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;static_phi&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;static_amp&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;weight_static_phi&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;weight_static_amp&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;static_phi_fit&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;num_freq&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;rms_amp&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;series&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;rms_phi&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;series&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;amp&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;weight_phi&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;weight_amp&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="s2">&quot;coeff_tau&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;coeff_alpha&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_source&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="s2">&quot;reference_noise_source&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">],</span> <span class="s2">&quot;flag&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
<span class="p">}</span>

<span class="c1"># Set up logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NullHandler</span><span class="p">())</span>


<div class="viewcode-block" id="TimingCorrection">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TimingCorrection</span><span class="p">(</span><span class="n">andata</span><span class="o">.</span><span class="n">BaseData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container that holds a timing correction.</span>

<span class="sd">    Provides methods for applying that correction to other datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimingCorrection.from_dict">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.from_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a TimingCorrection object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq: np.ndarray[nfreq, ] of dtype=(&#39;centre&#39;, &#39;width&#39;)</span>
<span class="sd">            Frequencies in MHz that were used to construct the timing correction.</span>
<span class="sd">        noise_source: np.ndarray[nsource,] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">            Correlator inputs that were used to construct the timing correction.</span>
<span class="sd">        input: np.ndarray[ninput, ] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">            Correlator inputs to which the timing correction will be applied.</span>
<span class="sd">        time: np.ndarray[ntime, ]</span>
<span class="sd">            Unix time.</span>
<span class="sd">        param: np.ndarray[nparam, ]</span>
<span class="sd">            Parameters of the model fit to the static phase versus frequency.</span>
<span class="sd">        series: np.ndarray[nseries, ]</span>
<span class="sd">            Labels different time series output by the real-time pipeline.</span>
<span class="sd">        tau:  np.ndarray[nsource, ntime]</span>
<span class="sd">            The actual timing correction, which is the relative delay of each of the</span>
<span class="sd">            noise source inputs with respect to a reference input versus time.</span>
<span class="sd">        weight_tau:  np.ndarray[nsource, ntime]</span>
<span class="sd">            Estimate of the uncertainty (inverse variance) on the timing correction.</span>
<span class="sd">        static_phi: np.ndarray[nfreq, nsource]</span>
<span class="sd">            The phase that was subtracted from each frequency and input prior to</span>
<span class="sd">            fitting for the timing correction.  This is necessary to remove the</span>
<span class="sd">            approximately static ripple pattern caused by reflections.</span>
<span class="sd">        weight_static_phi: np.ndarray[nfreq, nsource]</span>
<span class="sd">            Inverse variance on static_phi.</span>
<span class="sd">        static_phi_fit: np.ndarray[nparam, nsource]</span>
<span class="sd">            Best-fit parameters of a fit to the static phase versus frequency</span>
<span class="sd">            for each of the noise source inputs.</span>
<span class="sd">        alpha: np.ndarray[nsource, ntime]</span>
<span class="sd">            The coefficient of the spectral model of the amplitude variations of</span>
<span class="sd">            each of the noise source inputs versus time.</span>
<span class="sd">        weight_alpha: np.ndarray[nsource, ntime]</span>
<span class="sd">            Estimate of the uncertainty (inverse variance) on the amplitude</span>
<span class="sd">            coefficients.</span>
<span class="sd">        static_amp: np.ndarray[nfreq, nsource]</span>
<span class="sd">            The amplitude that was subtracted from each frequency and input prior to</span>
<span class="sd">            fitting for the amplitude variations.  This is necessary to remove the</span>
<span class="sd">            approximately static ripple pattern caused by reflections.</span>
<span class="sd">        weight_static_amp: np.ndarray[nfreq, nsource]</span>
<span class="sd">            Inverse variance on static_amp.</span>
<span class="sd">        num_freq: np.ndarray[nsource, ntime]</span>
<span class="sd">            The number of frequencies used to determine the delay and alpha quantities.</span>
<span class="sd">            If num_freq is 0, then that time is ignored when deriving the timing</span>
<span class="sd">            correction.</span>
<span class="sd">        rms_amp: np.ndarray[nsource, nseries, ntime]</span>
<span class="sd">            The RMS of the amplitude over the frequency axis.  Only used by real-time</span>
<span class="sd">            pipeline.</span>
<span class="sd">        rms_phi: np.ndarray[nsource, nseries, ntime]</span>
<span class="sd">            The RMS of the phase over the frequency axis.  Only used by real-time</span>
<span class="sd">            pipeline.</span>
<span class="sd">        coeff_tau: np.ndarray[ninput, nsource]</span>
<span class="sd">            If coeff_tau is provided, then the timing correction applied to a particular</span>
<span class="sd">            input will be the linear combination of the tau correction from the</span>
<span class="sd">            noise source inputs, with the coefficients set by this array.</span>
<span class="sd">        coeff_alpha: np.ndarray[ninput, nsource]</span>
<span class="sd">            If coeff_alpha is provided, then the timing correction applied to a</span>
<span class="sd">            particular input will be adjusted by the linear combination of the alpha</span>
<span class="sd">            correction from the noise source inputs, with the coefficients set by this</span>
<span class="sd">            array.</span>
<span class="sd">        reference_noise_source: np.ndarray[ninput]</span>
<span class="sd">            The noise source input that was used as reference when fitting coeff_tau.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">AXES</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">DSET_SPEC</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="c1"># Run base initialiser</span>
        <span class="n">tcorr</span> <span class="o">=</span> <span class="n">TimingCorrection</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Create index maps</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">index_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">tcorr</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Create datasets</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">DSET_SPEC</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">tcorr</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">tcorr</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tcorr</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>
        <span class="c1"># The timing correction files generated by the real-time pipeline are</span>
        <span class="c1"># structured differently than those generated by the offline pipeline,</span>
        <span class="c1"># so we need to use a different method for interpreting and reading them.</span>
        <span class="c1"># Determine if the files are real-time or offline by checking for an</span>
        <span class="c1"># update_time axis</span>
        <span class="k">if</span> <span class="s2">&quot;update_time&quot;</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;index_map&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_interpret_and_read_real_time</span><span class="p">(</span>
                <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_interpret_and_read_offline</span><span class="p">(</span>
            <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read_real_time</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>

        <span class="c1"># Instantiate an object for each file</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ondisk</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">]</span>

        <span class="c1"># Create a filter that will transpose any dataset</span>
        <span class="c1"># with a time axis so that it&#39;s the last dimension</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">dataset_filter</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>

            <span class="n">attrs</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;update_time&quot;</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>

                <span class="n">dim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;update_time&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

                    <span class="n">ax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

                    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">dataset</span><span class="p">[:],</span> <span class="n">dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">MemDatasetCommon</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

                    <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">dataset</span>

        <span class="c1"># Now concatenate the files.  Dynamic datasets will be concatenated.</span>
        <span class="c1"># Static datasets will be extracted from the first file.</span>
        <span class="k">return</span> <span class="n">tod</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="n">objs</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">dataset_filter</span><span class="o">=</span><span class="n">dataset_filter</span><span class="p">,</span>
            <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interpret_and_read_offline</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">out_group</span><span class="p">):</span>
        <span class="c1"># Instantiate an object for each file</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ondisk</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">acq_files</span><span class="p">]</span>

        <span class="c1"># Reference all dynamic datasets to the static quantities</span>
        <span class="c1"># defined in the first file</span>
        <span class="n">iref</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="n">objs</span><span class="p">[</span><span class="n">iref</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span>

        <span class="c1"># Determine the overall delay offset relative to the reference file</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">static_phi</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">weight_static_phi</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">phi_ref</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">weight_ref</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">weight_ref</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">+</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_ref</span><span class="p">))</span>
        <span class="n">err</span> <span class="o">*=</span> <span class="n">flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">dphi</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">-</span> <span class="n">phi_ref</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dphi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Fit the difference in the static phase between this file and the</span>
                    <span class="c1"># reference file to a linear relationship with frequency.  Uses</span>
                    <span class="c1"># nonlinear-least-squares that is insensitive to phase wrapping</span>
                    <span class="n">param</span> <span class="o">=</span> <span class="n">fit_poly_to_phase</span><span class="p">(</span>
                        <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">dphi</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">tt</span><span class="p">]),</span> <span class="n">err</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">tt</span><span class="p">],</span> <span class="n">nparam</span><span class="o">=</span><span class="mi">2</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Add the best-fit slope to the delay template for this file</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="n">nn</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Determine the overall amplitude offset relative to the reference file</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">static_amp</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">weight_static_amp</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">amp_ref</span> <span class="o">=</span> <span class="n">amp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">weight_ref</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">weight_ref</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">+</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_ref</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">weight</span> <span class="o">*=</span> <span class="n">flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">damp</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">-</span> <span class="n">amp_ref</span>

        <span class="n">asc</span> <span class="o">=</span> <span class="n">amp_ref</span> <span class="o">*</span> <span class="n">_amplitude_scaling</span><span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">asc</span> <span class="o">*</span> <span class="n">damp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">asc</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objs</span><span class="p">):</span>
            <span class="c1"># Add the offset to the amplitude template for this file</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Now concatenate the files.  Dynamic datasets will be concatenated.</span>
        <span class="c1"># Static datasets will be extracted from the first file.</span>
        <span class="k">return</span> <span class="n">tod</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="n">objs</span><span class="p">,</span>
            <span class="n">out_group</span><span class="o">=</span><span class="n">out_group</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
            <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span>
            <span class="n">convert_attribute_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_attribute_strings</span><span class="p">,</span>
            <span class="n">convert_dataset_strings</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert_dataset_strings</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the frequency bin centres.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the time axis.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;update_time&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;update_time&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ntime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the number of time samples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">noise_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the noise source inputs.</span>

<span class="sd">        Note that in older versions of the timing correction, the</span>
<span class="sd">        noise_source axis does not exist.  Instead, the equivalent</span>
<span class="sd">        quantity is labeled as input.  Since the addition of the</span>
<span class="sd">        coeff dataset it has become necessary to distinguish between the</span>
<span class="sd">        noise source inputs from which the timing correction is derived</span>
<span class="sd">        and the correlator inputs to which the timing correction is applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;noise_source&quot;</span> <span class="k">if</span> <span class="s2">&quot;noise_source&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span> <span class="k">else</span> <span class="s2">&quot;input&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nsource</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the number of noise source inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the correlator inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tau</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the tau array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the weight_tau array.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;weight_tau&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">:</span>
            <span class="c1"># weight_tau does not exist.  This is the case for timing</span>
            <span class="c1"># corrections generated with older versions of the code.</span>
            <span class="c1"># Create a default weight_tau dataset and return that.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_num_freq</span><span class="p">:</span>
                <span class="n">weight_tau</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:])</span>

            <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="s2">&quot;weight_tau&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">weight_tau</span><span class="p">)</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">DSET_SPEC</span><span class="p">[</span><span class="s2">&quot;weight_tau&quot;</span><span class="p">][</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;weight_tau&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the static_phi array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;static_phi&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight_static_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the weight_static_phi array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;weight_static_phi&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_phi_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the static_phi_fit array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;static_phi_fit&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the alpha array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the weight_alpha array.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;weight_alpha&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">:</span>
            <span class="c1"># weight_alpha does not exist.  This is the case for timing</span>
            <span class="c1"># corrections generated with older versions of the code.</span>
            <span class="c1"># Create a default weight_alpha dataset and return that.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_num_freq</span><span class="p">:</span>
                <span class="n">weight_alpha</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:])</span>

            <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">weight_alpha</span> <span class="o">*=</span> <span class="n">scale</span>

            <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="s2">&quot;weight_alpha&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">weight_alpha</span><span class="p">)</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">DSET_SPEC</span><span class="p">[</span><span class="s2">&quot;weight_alpha&quot;</span><span class="p">][</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;weight_alpha&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_amp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the static_amp array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;static_amp&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight_static_amp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the weight_static_amp array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;weight_static_amp&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the num_freq array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;num_freq&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_num_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inidicates if there is a num_freq flag that identifies missing data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;num_freq&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coeff_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the coeff_tau array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;coeff_tau&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_coeff_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indicates if there are valid coeff that map noise source tau to inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;coeff_tau&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span>
            <span class="ow">and</span> <span class="s2">&quot;noise_source&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span>
            <span class="ow">and</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coeff_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide convenience access to the coeff_alpha array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;coeff_alpha&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_coeff_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indicates if there are valid coeff that map noise source alpha to inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;coeff_alpha&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span>
            <span class="ow">and</span> <span class="s2">&quot;noise_source&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span>
            <span class="ow">and</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_map</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">amp_to_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is the conversion from noise source amplitude variations</span>
<span class="sd">        to delay variations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;amp_to_delay&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@amp_to_delay</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">amp_to_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set amp_to_delay</span>

<span class="sd">        Note that setting this quantity will result in the following</span>
<span class="sd">        modification to the timing correction:</span>

<span class="sd">            tau --&gt; tau - amp_to_delay * alpha</span>

<span class="sd">        This can be used to remove variations introduced by the noise</span>
<span class="sd">        source distribution system from the timing correction using the</span>
<span class="sd">        amplitude variations as a proxy for temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_alpha</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The amplitude variations are already being used to &quot;</span>
                <span class="s2">&quot;correct the delay variations through the coeff_alpha dataset.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;amp_to_delay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@amp_to_delay</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">amp_to_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove amp_to_delay&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;amp_to_delay&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;amp_to_delay&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if this timing correction contains amplitude data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;alpha&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reference_noise_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the index of the reference noise source.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;reference_noise_source&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;reference_noise_source&quot;</span><span class="p">][:]</span>
            <span class="k">return</span> <span class="n">iref</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">iref</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">iref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_delay_noise_source</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zero_delay_noise_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the index of the noise source with zero delay.&quot;&quot;&quot;</span>
        <span class="n">zero_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:])</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">zero_tau</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Could not determine which input the delay template &quot;</span>
                <span class="s2">&quot;is referenced with respect to.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">zero_tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="TimingCorrection.set_coeff">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.set_coeff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_coeff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coeff_tau</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">,</span>
        <span class="n">noise_source</span><span class="p">,</span>
        <span class="n">coeff_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reference_noise_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use coefficients to construct timing correction.</span>

<span class="sd">        Setting the coefficients changes how the timing corretion for a particular</span>
<span class="sd">        correlator input is derived.  Without coefficients, each input is matched</span>
<span class="sd">        to the timing correction from a single noise source input through the</span>
<span class="sd">        map_input_to_noise_source method.  With coefficients, each input is a</span>
<span class="sd">        linear combination of the timing correction from all noise source inputs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coeff_tau: np.ndarray[ninput, nsource]</span>
<span class="sd">            The timing correction applied to a particular input will be the</span>
<span class="sd">            linear combination of the tau correction from the noise source inputs,</span>
<span class="sd">            with the coefficients set by this array.</span>
<span class="sd">        inputs: np.ndarray[ninput, ] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">            Correlator inputs to which the timing correction will be applied.</span>
<span class="sd">        noise_source: np.ndarray[nsource,] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">            Correlator inputs that were used to construct the timing correction.</span>
<span class="sd">        coeff_alpha: np.ndarray[ninput, nsource]</span>
<span class="sd">            The timing correction applied to a particular input will be adjusted by</span>
<span class="sd">            the linear combination of the alpha correction from the noise source inputs,</span>
<span class="sd">            with the coefficients set by this array.</span>
<span class="sd">        reference_noise_source: np.ndarray[ninput,]</span>
<span class="sd">            For each input, the index into noise_source that was used as</span>
<span class="sd">            reference in the fit for coeff_tau.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sn_lookup</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">sn</span><span class="p">:</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">noise_source</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">][:])</span>
        <span class="p">}</span>

        <span class="n">reod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">sn_lookup</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">][:]]</span>
        <span class="p">)</span>

        <span class="n">datasets</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coeff_tau&quot;</span><span class="p">:</span> <span class="n">coeff_tau</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">coeff_alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;coeff_alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff_alpha</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">&quot;The amplitude variations are already &quot;</span>
                    <span class="s2">&quot;being used to correct the delay variations &quot;</span>
                    <span class="s2">&quot;through the amp_to_delay parameter.&quot;</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">DSET_SPEC</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">coeff</span><span class="p">[:,</span> <span class="n">reod</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">coeff</span><span class="p">[:,</span> <span class="n">reod</span><span class="p">])</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reference_noise_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_sn_lookup</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">sn</span><span class="p">:</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">][:])</span>
            <span class="p">}</span>

            <span class="n">reference_reodered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">ref_sn_lookup</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">noise_source</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">][</span><span class="n">reference_noise_source</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;reference_noise_source&quot;</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">DSET_SPEC</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">reference_reodered</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">reference_reodered</span><span class="p">)</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimingCorrection.delete_coeff">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.delete_coeff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stop using coefficients to construct timing correction.</span>

<span class="sd">        Calling this method will delete the `coeff_tau`, `coeff_alpha`,</span>
<span class="sd">        and `reference_noise_source` datasets if they exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;coeff_tau&quot;</span><span class="p">,</span> <span class="s2">&quot;coeff_alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;reference_noise_source&quot;</span><span class="p">]:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">DSET_SPEC</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">group</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="TimingCorrection.search_input">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.search_input">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">search_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find inputs in the input axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs: np.ndarray[ninput,] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index: np.ndarray[ninput,] of .int</span>
<span class="sd">            Indices of the input axis that yield the requested inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_input_lookup&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_lookup</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">sn</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">sn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">][:])</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_lookup</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">][:]]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TimingCorrection.set_global_reference_time">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.set_global_reference_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_global_reference_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tref</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize the delay and alpha template to the value at a single time.</span>

<span class="sd">        Useful for referencing the template to the value at the time that</span>
<span class="sd">        you plan to calibrate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tref : unix time</span>
<span class="sd">            Reference the templates to the values at this time.</span>
<span class="sd">        window: float</span>
<span class="sd">            Reference the templates to the median value over a window (in</span>
<span class="sd">            seconds) around tref.  If nonzero, this will override the</span>
<span class="sd">            interpolate keyword.</span>
<span class="sd">        interpolate : bool</span>
<span class="sd">            Interpolate the delay template to time tref.  Otherwise take</span>
<span class="sd">            the measured time nearest to tref.  The get_tau method is use</span>
<span class="sd">            to perform the interpolation, and kwargs for that method will</span>
<span class="sd">            be passed along.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tref</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">tref</span><span class="p">)</span>
        <span class="n">tref_string</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_datetime</span><span class="p">(</span><span class="n">tref</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S %Z&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Referencing timing correction with respect to </span><span class="si">{</span><span class="n">tref_string</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">tref</span> <span class="o">-</span> <span class="n">window</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">tref</span> <span class="o">+</span> <span class="n">window</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">iref</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Using median of </span><span class="si">{</span><span class="n">iref</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> samples around reference time.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_num_freq</span><span class="p">:</span>
                    <span class="n">tau_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">alpha_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="p">):</span>
                        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">iref</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">good</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">tau_ref</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">iref</span><span class="p">[</span><span class="n">good</span><span class="p">]])</span>
                            <span class="n">alpha_ref</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">iref</span><span class="p">[</span><span class="n">good</span><span class="p">]])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tau_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:,</span> <span class="n">iref</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">alpha_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:,</span> <span class="n">iref</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Timing correction not available for time </span><span class="si">{</span><span class="n">tref_string</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">tref</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tref</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Timing correction not available for time </span><span class="si">{</span><span class="n">tref_string</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;interp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span>

            <span class="n">tau_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tau</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tref</span><span class="p">),</span> <span class="n">ignore_amp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">alpha_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tref</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">tau_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">alpha_ref</span></div>


<div class="viewcode-block" id="TimingCorrection.set_reference_time">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.set_reference_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_reference_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tref</span><span class="p">,</span>
        <span class="n">tstart</span><span class="p">,</span>
        <span class="n">tend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tinit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tau_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize the delay and alpha template to specific times.</span>

<span class="sd">        Required if applying the timing correction to data that has</span>
<span class="sd">        already been calibrated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tref : np.ndarray[nref]</span>
<span class="sd">            Reference the delays to the values at this unix time.</span>
<span class="sd">        tstart : np.ndarray[nref]</span>
<span class="sd">            Begin transition to the reference delay at this unix time.</span>
<span class="sd">        tend : np.ndarray[nref]</span>
<span class="sd">            Complete transition to the reference delay at this unix time.</span>
<span class="sd">        tinit : float</span>
<span class="sd">            Use the delay at this time for the period before the first tstart.</span>
<span class="sd">            Takes prescendent over tau_init.</span>
<span class="sd">        tau_init : np.ndarray[nsource]</span>
<span class="sd">            Use this delay for times before the first tstart.  Must provide a value</span>
<span class="sd">            for each noise source input.  If None, then will reference with respect</span>
<span class="sd">            to the average delay over the full time series.</span>
<span class="sd">        alpha_init : np.ndarray[nsource]</span>
<span class="sd">            Use this alpha for times before the first tstart.  Must provide a value</span>
<span class="sd">            for each noise source input.  If None, then will reference with respect</span>
<span class="sd">            to the average alpha over the full time series.</span>
<span class="sd">        interpolate : bool</span>
<span class="sd">            Interpolate the delay template to times tref. Otherwise take the measured</span>
<span class="sd">            times nearest to tref. The get_tau method is use to perform the</span>
<span class="sd">            interpolation, and kwargs for that method will be passed along.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">tref</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;interp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span>

        <span class="n">tau_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tau</span><span class="p">(</span><span class="n">tref</span><span class="p">,</span> <span class="n">ignore_amp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">alpha_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="n">tref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tinit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tinit</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">tinit</span><span class="p">)</span>
            <span class="n">tau_init</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tau</span><span class="p">(</span><span class="n">tinit</span><span class="p">,</span> <span class="n">ignore_amp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">alpha_init</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="n">tinit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tau_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tau_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tau_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tau_ref</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tau_init</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">tau_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">tau_init</span> <span class="o">=</span> <span class="n">tau_init</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Initial tau has size </span><span class="si">{</span><span class="n">tau_init</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but there are </span><span class="si">{</span><span class="n">tau_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> noise sources.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">alpha_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">alpha_ref</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alpha_init</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">alpha_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">alpha_init</span> <span class="o">=</span> <span class="n">alpha_init</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Initial alpha has size </span><span class="si">{</span><span class="n">alpha_init</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but there are </span><span class="si">{</span><span class="n">alpha_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> noise sources.&quot;</span>
                <span class="p">)</span>

        <span class="n">tau_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tau_init</span><span class="p">,</span> <span class="n">tau_ref</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">alpha_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">alpha_init</span><span class="p">,</span> <span class="n">alpha_ref</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">tstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">tstart</span><span class="p">))</span>
        <span class="n">istart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">tstart</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">tend</span><span class="p">))</span>
            <span class="n">iend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="n">tstart</span>
            <span class="n">iend</span> <span class="o">=</span> <span class="n">istart</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ts</span><span class="p">,</span> <span class="n">te</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">te</span> <span class="o">&gt;</span> <span class="n">ts</span><span class="p">:</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">ts</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="n">te</span><span class="p">))</span>
                <span class="n">coeff</span><span class="p">[</span><span class="n">fill</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fill</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">fill</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">tau_ref_full</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">tau_ref</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coeff</span><span class="p">)</span> <span class="o">*</span> <span class="n">tau_ref</span><span class="p">[:,</span> <span class="n">iend</span><span class="p">]</span>
        <span class="n">alpha_ref_full</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">coeff</span> <span class="o">*</span> <span class="n">alpha_ref</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">coeff</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha_ref</span><span class="p">[:,</span> <span class="n">iend</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">tau_ref_full</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">alpha_ref_full</span></div>


<div class="viewcode-block" id="TimingCorrection.get_tau">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.get_tau">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">ignore_amp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">extrap_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the delay for each noise source at the requested times.</span>

<span class="sd">        Uses the TimingInterpolator to interpolate to the requested times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp:  np.ndarray[ntime,]</span>
<span class="sd">            Unix timestamp.</span>
<span class="sd">        ignore_amp: bool</span>
<span class="sd">            Do not apply a noise source based amplitude correction, even if one exists.</span>
<span class="sd">        interp: string</span>
<span class="sd">            Method to interpolate over time.  Options include &#39;linear&#39;, &#39;nearest&#39;,</span>
<span class="sd">            &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;, and &#39;next&#39;.</span>
<span class="sd">        extrap_limit: float</span>
<span class="sd">            Do not extrapolate the underlying data beyond its boundaries by this</span>
<span class="sd">            amount in seconds.  Default is 2 integrations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tau: np.ndarray[nsource, ntime]</span>
<span class="sd">            Delay as a function of time for each of the noise sources.</span>
<span class="sd">        weight : np.ndarray[nsource, ntime]</span>
<span class="sd">            The uncertainty on the delay, expressed as an inverse variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_num_freq</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">ignore_amp</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_amplitude</span><span class="p">:</span>
            <span class="n">tau_interpolator</span> <span class="o">=</span> <span class="n">TimingInterpolator</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:],</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_tau</span><span class="p">[:],</span>
                <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                <span class="n">extrap_limit</span><span class="o">=</span><span class="n">extrap_limit</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">tau</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">tau_interpolator</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Correcting delay template using amplitude template &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with coefficient </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Determine which input the delay template is referenced to</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_delay_noise_source</span>

            <span class="c1"># Subtract the referenced, scaled alpha template from the delay template</span>
            <span class="n">tau_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>

            <span class="c1"># Extract the weights</span>
            <span class="n">weight_corrected</span> <span class="o">=</span> <span class="n">_weight_propagation_addition</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weight_tau</span><span class="p">[:],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weight_alpha</span><span class="p">[:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weight_alpha</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_to_delay</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Interpolate to the requested times</span>
            <span class="n">tau_interpolator</span> <span class="o">=</span> <span class="n">TimingInterpolator</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:],</span>
                <span class="n">tau_corrected</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">weight_corrected</span><span class="p">,</span>
                <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
                <span class="n">extrap_limit</span><span class="o">=</span><span class="n">extrap_limit</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">tau</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">tau_interpolator</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tau</span><span class="p">,</span> <span class="n">weight</span></div>


<div class="viewcode-block" id="TimingCorrection.get_alpha">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.get_alpha">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">extrap_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the amplitude variation for each noise source at the requested times.</span>

<span class="sd">        Uses the TimingInterpolator to interpolate to the requested times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp:  np.ndarray[ntime,]</span>
<span class="sd">            Unix timestamp.</span>
<span class="sd">        interp: string</span>
<span class="sd">            Method to interpolate over time.  Options include &#39;linear&#39;, &#39;nearest&#39;,</span>
<span class="sd">            &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;, and &#39;next&#39;.</span>
<span class="sd">        extrap_limit: float</span>
<span class="sd">            Do not extrapolate the underlying data beyond its boundaries by this</span>
<span class="sd">            amount in seconds.  Default is 2 integrations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha: np.ndarray[nsource, ntime]</span>
<span class="sd">            Amplitude coefficient as a function of time for each of the noise sources.</span>
<span class="sd">        weight : np.ndarray[nsource, ntime]</span>
<span class="sd">            The uncertainty on the amplitude coefficient, expressed as an</span>
<span class="sd">            inverse variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_num_freq</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">alpha_interpolator</span> <span class="o">=</span> <span class="n">TimingInterpolator</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:],</span>
            <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_alpha</span><span class="p">[:],</span>
            <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">interp</span><span class="p">,</span>
            <span class="n">extrap_limit</span><span class="o">=</span><span class="n">extrap_limit</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">alpha</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">alpha_interpolator</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">weight</span></div>


<div class="viewcode-block" id="TimingCorrection.get_stacked_tau">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.get_stacked_tau">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_stacked_tau</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">reverse_stack</span><span class="p">,</span> <span class="n">input_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the delay for each stacked visibility at the requested time.</span>

<span class="sd">        Averages the delays from the noise source inputs that map to the</span>
<span class="sd">        set of redundant baseline included in each stacked visibility.</span>
<span class="sd">        This yields the appropriate common-mode delay correction.  If</span>
<span class="sd">        input_flags is provided, then the bad inputs that were excluded</span>
<span class="sd">        from the stack are also excluded from the delay template averaging.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp:  np.ndarray[ntime,]</span>
<span class="sd">            Unix timestamp.</span>
<span class="sd">        inputs: np.ndarray[ninput,]</span>
<span class="sd">            Must contain &#39;correlator_input&#39; field.</span>
<span class="sd">        prod: np.ndarray[nprod,]</span>
<span class="sd">            The products that were included in the stack.</span>
<span class="sd">            Typically found in the `index_map[&#39;prod&#39;]` attribute of the</span>
<span class="sd">            `andata.CorrData` object.</span>
<span class="sd">        reverse_stack: np.ndarray[nprod,] of dtype=(&#39;stack&#39;, &#39;conjugate&#39;)</span>
<span class="sd">            The index of the stack axis that each product went into.</span>
<span class="sd">            Typically found in `reverse_map[&#39;stack&#39;]` attribute</span>
<span class="sd">            of the `andata.CorrData`.</span>
<span class="sd">        input_flags : np.ndarray [ninput, ntime]</span>
<span class="sd">            Array indicating which inputs were good at each time.</span>
<span class="sd">            Non-zero value indicates that an input was good.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tau: np.ndarray[nstack, ntime]</span>
<span class="sd">            Delay as a function of time for each stacked visibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use the get_tau method to get the data for the noise source inputs</span>
        <span class="c1"># at the requested times.</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tau</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_tau</span><span class="p">:</span>
            <span class="c1"># This tau correction has a coefficient array.</span>
            <span class="c1"># Find the coefficients for the requested inputs.</span>
            <span class="n">reod</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">_convert_to_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search_input</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff_tau</span><span class="p">[</span><span class="n">reod</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Determine how the noise source delays were referenced</span>
            <span class="c1"># when fitting for the coefficients</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_noise_source</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">iref</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">iref</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_delay_noise_source</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">iref</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iref</span> <span class="o">=</span> <span class="n">iref</span><span class="p">[</span><span class="n">reod</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Stack the data from the noise source inputs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">prod</span><span class="p">,</span>
            <span class="n">reverse_stack</span><span class="p">,</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span>
            <span class="n">input_flags</span><span class="o">=</span><span class="n">input_flags</span><span class="p">,</span>
            <span class="n">reference_noise_source</span><span class="o">=</span><span class="n">iref</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TimingCorrection.get_stacked_alpha">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.get_stacked_alpha">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_stacked_alpha</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">reverse_stack</span><span class="p">,</span> <span class="n">input_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the stacked alphas for the noise source amplitude variations.</span>

<span class="sd">        Averages the alphas from the noise source inputs that map to the</span>
<span class="sd">        set of redundant baseline included in each stacked visibility.  If</span>
<span class="sd">        input_flags is provided, then the bad inputs that were excluded</span>
<span class="sd">        from the stack are also excluded from the alpha template averaging.</span>
<span class="sd">        This method can be used to generate a stacked alpha template that</span>
<span class="sd">        can be used to correct a stacked tau template for variations in the</span>
<span class="sd">        noise source distribution system.  However, it is recommended that</span>
<span class="sd">        the tau template be corrected before stacking. This is accomplished</span>
<span class="sd">        by setting the `amp_to_delay` property prior to calling</span>
<span class="sd">        `get_stacked_tau`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp:  np.ndarray[ntime,]</span>
<span class="sd">            Unix timestamp.</span>
<span class="sd">        inputs: np.ndarray[ninput,]</span>
<span class="sd">            Must contain &#39;correlator_input&#39; field.</span>
<span class="sd">        prod: np.ndarray[nprod,]</span>
<span class="sd">            The products that were included in the stack.</span>
<span class="sd">            Typically found in the `index_map[&#39;prod&#39;]` attribute of the</span>
<span class="sd">            `andata.CorrData` object.</span>
<span class="sd">        reverse_stack: np.ndarray[nprod,] of dtype=(&#39;stack&#39;, &#39;conjugate&#39;)</span>
<span class="sd">            The index of the stack axis that each product went into.</span>
<span class="sd">            Typically found in `reverse_map[&#39;stack&#39;]` attribute</span>
<span class="sd">            of the `andata.CorrData`.</span>
<span class="sd">        input_flags : np.ndarray [ninput, ntime]</span>
<span class="sd">            Array indicating which inputs were good at each time.</span>
<span class="sd">            Non-zero value indicates that an input was good.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha: np.ndarray[nstack, ntime]</span>
<span class="sd">            Noise source amplitude variation as a function of time for each</span>
<span class="sd">            stacked visibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_amplitude</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;This timing correction does not include &quot;</span>
                <span class="s2">&quot;an adjustment based on the noise soure amplitude.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_alpha</span><span class="p">:</span>
            <span class="c1"># This alpha correction has a coefficient array.</span>
            <span class="c1"># Find the coefficients for the requested inputs.</span>
            <span class="n">reod</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">_convert_to_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search_input</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff_alpha</span><span class="p">[</span><span class="n">reod</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Use the get_alpha method to get the data for the noise source inputs.</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Stack the data from the noise source inputs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stack</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">reverse_stack</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">input_flags</span><span class="o">=</span><span class="n">input_flags</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">,</span>
        <span class="n">prod</span><span class="p">,</span>
        <span class="n">reverse_stack</span><span class="p">,</span>
        <span class="n">coeff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">input_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reference_noise_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">stack_index</span> <span class="o">=</span> <span class="n">reverse_stack</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span>
        <span class="n">stack_conj</span> <span class="o">=</span> <span class="n">reverse_stack</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">nstack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stack_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nprod</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">size</span>
        <span class="n">ninput</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Sort the products based on the index of the stack axis they went into.</span>
        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">stack_index</span><span class="p">)</span>
        <span class="n">sorted_stack_index</span> <span class="o">=</span> <span class="n">stack_index</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>
        <span class="n">sorted_stack_conj</span> <span class="o">=</span> <span class="n">stack_conj</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>
        <span class="n">sorted_prod</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="n">sorted_prod</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sorted_prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">sorted_stack_conj</span><span class="p">,</span> <span class="n">temp</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">],</span> <span class="n">temp</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">sorted_prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">sorted_stack_conj</span><span class="p">,</span> <span class="n">temp</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">],</span> <span class="n">temp</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Find boundaries into the sorted products that separate stacks.</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sorted_stack_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">nprod</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Check for coefficient array that encodes the contribution of</span>
        <span class="c1"># each noise source to each input.</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This timing correction does not have a coefficient array.</span>
            <span class="c1"># Construct from the output of the map_input_to_noise_source method.</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">map_input_to_noise_source</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">))</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninput</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">coeff</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ninput</span><span class="p">),</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Expand the coefficient array to have single element time axis</span>
        <span class="n">nsource</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Construct separate coefficient array that handles the reference noise source</span>
        <span class="n">with_ref</span> <span class="o">=</span> <span class="n">reference_noise_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">with_ref</span><span class="p">:</span>
            <span class="n">cref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ninput</span><span class="p">,</span> <span class="n">nsource</span><span class="p">,</span> <span class="n">nsource</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">cref</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ninput</span><span class="p">),</span> <span class="n">reference_noise_source</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>

        <span class="c1"># If input_flags was not provided, or if it is all True or all False, then we</span>
        <span class="c1"># assume all inputs are good and carry out a faster calculation.</span>
        <span class="n">no_input_flags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">input_flags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">input_flags</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">input_flags</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">no_input_flags</span><span class="p">:</span>
            <span class="c1"># No input flags provided.  All inputs considered good.</span>
            <span class="n">uniq_input_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ninput</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">index_time</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Find the unique sets of input flags.</span>
            <span class="n">uniq_input_flags</span><span class="p">,</span> <span class="n">index_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">input_flags</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

        <span class="n">ntime_uniq</span> <span class="o">=</span> <span class="n">uniq_input_flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Initialize arrays to hold the stacked coefficients</span>
        <span class="n">stack_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstack</span><span class="p">,</span> <span class="n">nsource</span><span class="p">,</span> <span class="n">ntime_uniq</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">weight_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstack</span><span class="p">,</span> <span class="n">ntime_uniq</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Loop over stacked products</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">ssi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sorted_stack_index</span><span class="p">)):</span>
            <span class="c1"># Get the input pairs that went into this stack</span>
            <span class="n">prodo</span> <span class="o">=</span> <span class="n">sorted_prod</span><span class="p">[</span><span class="n">boundary</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="p">:</span> <span class="n">boundary</span><span class="p">[</span><span class="n">ss</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">prodo</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="n">prodo</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span>

            <span class="c1"># Sum the difference in coefficients over pairs of inputs,</span>
            <span class="c1"># weighted by the product of the input flags for those inputs.</span>
            <span class="n">ww</span> <span class="o">=</span> <span class="n">uniq_input_flags</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">uniq_input_flags</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span>
            <span class="n">weight_norm</span><span class="p">[</span><span class="n">ssi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stack_coeff</span><span class="p">[</span><span class="n">ssi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">ww</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">-</span> <span class="n">coeff</span><span class="p">[</span><span class="n">bb</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">with_ref</span><span class="p">:</span>
                <span class="n">stack_coeff</span><span class="p">[</span><span class="n">ssi</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">ww</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cref</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">-</span> <span class="n">cref</span><span class="p">[</span><span class="n">bb</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

        <span class="c1"># The delay for each stacked product is a linear combination of the</span>
        <span class="c1"># delay from the noise source inputs.</span>
        <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">stack_coeff</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index_time</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">stacked_data</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_norm</span><span class="p">[:,</span> <span class="n">index_time</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">stacked_data</span>

<div class="viewcode-block" id="TimingCorrection.get_timing_correction">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.get_timing_correction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_timing_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the phase correction from each noise source.</span>

<span class="sd">        Assumes the phase correction scales with frequency nu as</span>

<span class="sd">            phi = 2 pi nu tau</span>

<span class="sd">        and uses the get_tau method to interpolate over time. It acccepts and</span>
<span class="sd">        passes along keyword arguments for that method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq: np.ndarray[nfreq, ]</span>
<span class="sd">            Frequency in MHz.</span>
<span class="sd">        timestamp:  np.ndarray[ntime, ]</span>
<span class="sd">            Unix timestamp.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">            Complex gain containing a pure phase correction for each of the</span>
<span class="sd">            noise sources.</span>
<span class="sd">        weight: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">            Uncerainty on the gain for each of the noise sources,</span>
<span class="sd">            expressed as an inverse variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tau</span><span class="p">,</span> <span class="n">wtau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tau</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span>
            <span class="o">*</span> <span class="n">FREQ_TO_OMEGA</span>
            <span class="o">*</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="p">)</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">wtau</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">gain</span><span class="p">,</span> <span class="n">weight</span></div>


<div class="viewcode-block" id="TimingCorrection.get_gain">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.get_gain">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the complex gain for the requested frequencies, inputs, and times.</span>

<span class="sd">        Multiplying the visibilities by the outer product of these gains will remove</span>
<span class="sd">        the fluctuations in phase due to timing jitter.  This method uses the</span>
<span class="sd">        get_tau method.  It acccepts and passes along keyword arguments for that method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq: np.ndarray[nfreq, ]</span>
<span class="sd">            Frequency in MHz.</span>
<span class="sd">        inputs: np.ndarray[ninput, ]</span>
<span class="sd">            Must contain &#39;correlator_input&#39; field.</span>
<span class="sd">        timestamp: np.ndarray[ntime, ]</span>
<span class="sd">            Unix timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain : np.ndarray[nfreq, ninput, ntime]</span>
<span class="sd">            Complex gain.  Multiplying the visibilities by the</span>
<span class="sd">            outer product of this vector at a given time and</span>
<span class="sd">            frequency will correct for the timing jitter.</span>
<span class="sd">        weight: np.ndarray[nfreq, ninput, ntime]</span>
<span class="sd">            Uncerainty on the gain expressed as an inverse variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_tau</span><span class="p">:</span>
            <span class="c1"># Get the delay template for the noise source inputs</span>
            <span class="c1"># at the requested times</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">wtau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tau</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">vartau</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">wtau</span><span class="p">)</span>

            <span class="c1"># Find the coefficients for the requested inputs</span>
            <span class="n">reod</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">_convert_to_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search_input</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>

            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff_tau</span><span class="p">[</span><span class="n">reod</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Different calculation dependening on whether or not the</span>
            <span class="c1"># reference noise source changes with input</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_noise_source</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">iref</span><span class="p">):</span>
                <span class="c1"># There is a single reference for all inputs.</span>
                <span class="c1"># Check if it is different than the current reference.</span>
                <span class="k">if</span> <span class="n">iref</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_delay_noise_source</span><span class="p">:</span>
                    <span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">-</span> <span class="n">tau</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">vartau</span> <span class="o">=</span> <span class="n">vartau</span> <span class="o">+</span> <span class="n">vartau</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># The delay for each input is a linear combination of the</span>
                <span class="c1"># delay from the noise source inputs</span>
                <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
                <span class="n">vartau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">vartau</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Find the reference for the requested inputs</span>
                <span class="n">iref</span> <span class="o">=</span> <span class="n">iref</span><span class="p">[</span><span class="n">reod</span><span class="p">]</span>

                <span class="c1"># The delay for each input is a linear combination of the</span>
                <span class="c1"># delay from the noise source inputs</span>
                <span class="n">sumC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span> <span class="o">-</span> <span class="n">sumC</span> <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="p">:]</span>

                <span class="n">vartau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">vartau</span><span class="p">)</span> <span class="o">+</span> <span class="n">sumC</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">vartau</span><span class="p">[</span><span class="n">iref</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Check if we need to correct the delay using the noise source amplitude</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_amplitude</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_alpha</span><span class="p">:</span>
                <span class="c1"># Get the alpha template for the noise source inputs</span>
                <span class="c1"># at the requested times</span>
                <span class="n">alpha</span><span class="p">,</span> <span class="n">walpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">varalpha</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">walpha</span><span class="p">)</span>

                <span class="n">Calpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff_alpha</span><span class="p">[</span><span class="n">reod</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># Adjust the delay for each input by the linear combination of the</span>
                <span class="c1"># amplitude from the noise source inputs</span>
                <span class="n">tau</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Calpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

                <span class="n">vartau</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Calpha</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">varalpha</span><span class="p">)</span>

            <span class="c1"># Scale by 2 pi nu to convert to gain</span>
            <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span>
                <span class="o">*</span> <span class="n">FREQ_TO_OMEGA</span>
                <span class="o">*</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="p">)</span>

            <span class="n">weight</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                <span class="n">vartau</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the timing correction for the noise source inputs at the</span>
            <span class="c1"># requested times and frequencies</span>
            <span class="n">gain</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_timing_correction</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Determine which noise source to use for each input</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">map_input_to_noise_source</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">)</span>

            <span class="n">gain</span> <span class="o">=</span> <span class="n">gain</span><span class="p">[:,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[:,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Return gains</span>
        <span class="k">return</span> <span class="n">gain</span><span class="p">,</span> <span class="n">weight</span></div>


<div class="viewcode-block" id="TimingCorrection.apply_timing_correction">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.apply_timing_correction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_timing_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the timing correction to another visibility dataset.</span>

<span class="sd">        This method uses the get_gain or get_stacked_tau method, depending</span>
<span class="sd">        on whether or not the visibilities have been stacked.  It acccepts</span>
<span class="sd">        and passes along keyword arguments for those method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData / equivalent or np.ndarray[nfreq, nprod, ntime]</span>
<span class="sd">            If timestream is an np.ndarray containing the visiblities, the</span>
<span class="sd">            you must also pass the corresponding freq, prod, input, and</span>
<span class="sd">            time axis as kwargs.  Otherwise these quantities are obtained</span>
<span class="sd">            from the attributes of CorrData.  If the visibilities have been</span>
<span class="sd">            stacked, then you must additionally pass the stack and</span>
<span class="sd">            reverse_stack axis as kwargs, and (optionally) the input flags.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Create a copy of the input visibilities.  Apply the timing</span>
<span class="sd">            correction to the copy and return it, leaving the original</span>
<span class="sd">            untouched.  Default is False.</span>
<span class="sd">        freq : np.ndarray[nfreq, ]</span>
<span class="sd">            Frequency in MHz.</span>
<span class="sd">            Must be passed as keyword argument if timestream is an np.ndarray.</span>
<span class="sd">        prod: np.ndarray[nprod,  ]</span>
<span class="sd">            Product map.</span>
<span class="sd">            Must be passed as keyword argument if timestream is an np.ndarray.</span>
<span class="sd">        time: np.ndarray[ntime, ]</span>
<span class="sd">            Unix time.</span>
<span class="sd">            Must be passed as keyword argument if timestream is an np.ndarray.</span>
<span class="sd">        input: np.ndarray[ninput, ] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">            Input axis.</span>
<span class="sd">            Must be passed as keyword argument if timestream is an np.ndarray.</span>
<span class="sd">        stack : np.ndarray[nstack, ]</span>
<span class="sd">            Stack axis.</span>
<span class="sd">            Must be passed as keyword argument if timestream is an np.ndarray</span>
<span class="sd">            and the visibilities have been stacked.</span>
<span class="sd">        reverse_stack : np.ndarray[nprod, ] of dtype=(&#39;stack&#39;, &#39;conjugate&#39;)</span>
<span class="sd">            The index of the stack axis that each product went into.</span>
<span class="sd">            Typically found in `reverse_map[&#39;stack&#39;]` attribute.</span>
<span class="sd">            Must be passed as keyword argument if timestream is an np.ndarray</span>
<span class="sd">            and the visibilities have been stacked.</span>
<span class="sd">        input_flags : np.ndarray [ninput, ntime]</span>
<span class="sd">            Array indicating which inputs were good at each time.  Non-zero</span>
<span class="sd">            value indicates that an input was good.  Optional.  Only used for</span>
<span class="sd">            stacked visibilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        If copy == True:</span>
<span class="sd">            vis : np.ndarray[nfreq, nprod(nstack), ntime]</span>
<span class="sd">                New set of visibilities with timing correction applied.</span>
<span class="sd">        else:</span>
<span class="sd">            None</span>
<span class="sd">                Correction is applied to the input visibility data.  Also,</span>
<span class="sd">                if timestream is an andata.CorrData instance and the gain</span>
<span class="sd">                dataset exists, then it will be updated with the complex</span>
<span class="sd">                gains that have been applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timestream</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">is_obj</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">vis</span> <span class="o">=</span> <span class="n">timestream</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">freq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prod&quot;</span><span class="p">)</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">reverse_stack</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;reverse_stack&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_obj</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># This works for both distributed and non-distributed datasets</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">freq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;freq&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prod&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;prod&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span>
                <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:]</span>
            <span class="p">)</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">input</span><span class="p">[:]</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">time</span><span class="p">[:]</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;stack&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span>
                <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span>
            <span class="p">)</span>
            <span class="n">reverse_stack</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;reverse_stack&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;reverse_stack&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span>
                <span class="k">else</span> <span class="n">timestream</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span>
            <span class="p">)</span>

        <span class="n">input_flags</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;input_flags&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Determine if the visibilities have been stacked</span>
        <span class="n">is_stack</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">stack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">reverse_stack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">prod</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_stack</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying timing correction to stacked data.&quot;</span><span class="p">)</span>
            <span class="c1"># Visibilities have been stacked.</span>
            <span class="c1"># Stack the timing correction before applying it.</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stacked_tau</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">,</span>
                <span class="n">inputs</span><span class="p">,</span>
                <span class="n">prod</span><span class="p">,</span>
                <span class="n">reverse_stack</span><span class="p">,</span>
                <span class="n">input_flags</span><span class="o">=</span><span class="n">input_flags</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_amplitude</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_alpha</span><span class="p">:</span>
                <span class="n">tau</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stacked_alpha</span><span class="p">(</span>
                    <span class="n">timestamp</span><span class="p">,</span>
                    <span class="n">inputs</span><span class="p">,</span>
                    <span class="n">prod</span><span class="p">,</span>
                    <span class="n">reverse_stack</span><span class="p">,</span>
                    <span class="n">input_flags</span><span class="o">=</span><span class="n">input_flags</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Loop over local frequencies and apply the timing correction</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">*</span> <span class="n">tau</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying timing correction to unstacked data.&quot;</span><span class="p">)</span>
            <span class="c1"># Visibilities have not been stacked yet.  Use the timing correction as is.</span>
            <span class="c1"># Get the gain corrections for the times and frequencies in timestream.</span>
            <span class="n">gain</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gain</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Loop over products and apply the timing correction</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod</span><span class="p">):</span>
                <span class="n">vis</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">gain</span><span class="p">[:,</span> <span class="n">aa</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">gain</span><span class="p">[:,</span> <span class="n">bb</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

            <span class="c1"># If andata object was input then update the gain</span>
            <span class="c1"># dataset so that we have record of what was done</span>
            <span class="k">if</span> <span class="n">is_obj</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="s2">&quot;gain&quot;</span> <span class="ow">in</span> <span class="n">timestream</span><span class="p">:</span>
                <span class="n">timestream</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">gain</span>

        <span class="c1"># If a copy was requested, then return the</span>
        <span class="c1"># new vis with phase correction applied</span>
        <span class="k">return</span> <span class="n">vis</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="TimingCorrection.predict_x_error">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.predict_x_error">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_x_error</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">input_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">correlator</span><span class="o">=</span><span class="s2">&quot;chime&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate offset in telescope x position of sources due to timing errors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp: np.ndarray[ntime,] of float</span>
<span class="sd">            Calculate the x offset at these unix timestamps.</span>
<span class="sd">        input_map: list of CorrInput</span>
<span class="sd">            The correlator inputs.  If this parameter is not provided,</span>
<span class="sd">            then the `tools.get_correlator_inputs` method will be used</span>
<span class="sd">            to query the layout database for this information.</span>
<span class="sd">        input_flags: np.ndarray[ninput,] or np.ndarray[ninput, ntime] of bool</span>
<span class="sd">            Boolean flag indicating which inputs to include in the calculation.</span>
<span class="sd">            This can either be a single set of input flags that are valid for</span>
<span class="sd">            all timestamps, or a separate set for each timestamp.</span>
<span class="sd">        correlator: str</span>
<span class="sd">            The name of the correlator.  This parameter is only used if the</span>
<span class="sd">            `input_map` parameter is not provided.  Defaults to &#39;chime&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dx: np.ndarray[ntime,] of float</span>
<span class="sd">            The offset in telescope x in degrees at the requested times.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that timestamp is a numpy array</span>
        <span class="n">scalar_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">ntime</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># If the input_map was not provided, then query it from the layout database</span>
        <span class="k">if</span> <span class="n">input_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_map</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_correlator_inputs</span><span class="p">(</span>
                <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_datetime</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">correlator</span><span class="o">=</span><span class="n">correlator</span>
            <span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">inp</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">input_map</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;chan_id&quot;</span><span class="p">,</span> <span class="s2">&quot;u2&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">,</span> <span class="s2">&quot;U32&quot;</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="n">ninput</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Determine the polarisation and position of each input</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_feed_polarisations</span><span class="p">(</span><span class="n">input_map</span><span class="p">)</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_feed_positions</span><span class="p">(</span><span class="n">input_map</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Find valid inputs</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">pol</span> <span class="o">!=</span> <span class="s2">&quot;0&quot;</span>

        <span class="k">if</span> <span class="n">input_flags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">input_flags</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">input_flags</span> <span class="o">=</span> <span class="n">input_flags</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">input_flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ntime</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must provide a single set of input flags, &quot;</span>
                    <span class="s2">&quot;or a set of input flags for every time.&quot;</span>
                <span class="p">)</span>

            <span class="n">valid</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">input_flags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Construct a prod axis that contains all baselines in the upper triangle</span>
        <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">ninput</span><span class="p">)</span>
        <span class="n">dtype_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s2">&quot;input_a&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u2&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;input_b&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u2&quot;</span><span class="p">)])</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">triu</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;&lt;u2&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype_prod</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Find the valid co-polar baselines</span>
        <span class="n">copol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span>
            <span class="p">(</span><span class="n">pol</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span> <span class="o">==</span> <span class="n">pol</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]])</span>
            <span class="o">&amp;</span> <span class="n">valid</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span>
            <span class="o">&amp;</span> <span class="n">valid</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="n">prod</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">copol</span><span class="p">]</span>

        <span class="c1"># Construct a reverse_stack axis for the stack consisting of all co-polar</span>
        <span class="c1"># baselines</span>
        <span class="n">reverse_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">copol</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;u1&quot;</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="c1"># Stack the timing correction</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stacked_tau</span><span class="p">(</span>
            <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">reverse_stack</span><span class="p">,</span> <span class="n">input_flags</span><span class="o">=</span><span class="n">input_flags</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_amplitude</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_coeff_alpha</span><span class="p">:</span>
            <span class="n">tau</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stacked_alpha</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">,</span>
                <span class="n">inputs</span><span class="p">,</span>
                <span class="n">prod</span><span class="p">,</span>
                <span class="n">reverse_stack</span><span class="p">,</span>
                <span class="n">input_flags</span><span class="o">=</span><span class="n">input_flags</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Calculate the effective EW baseline distance</span>
        <span class="n">ew_dist</span> <span class="o">=</span> <span class="n">xpos</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">xpos</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span>
        <span class="n">eff_ew_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ew_dist</span><span class="p">)</span>

        <span class="c1"># Calculate the x offset due to the timing variations</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">speed_of_light</span> <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-12</span> <span class="o">/</span> <span class="n">eff_ew_dist</span>

        <span class="c1"># If the requested time was a scalar, then ensure that</span>
        <span class="c1"># the returned offset is also a scalar.</span>
        <span class="k">if</span> <span class="n">scalar_time</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimingCorrection.summary">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingCorrection.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide a summary of the timing correction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : list of strings</span>
<span class="sd">            Contains useful information about the timing correction.</span>
<span class="sd">            Specifically contains for each noise source input the</span>
<span class="sd">            time averaged  phase offset and delay.  Also contains</span>
<span class="sd">            estimates of the variance in the timing for both the</span>
<span class="sd">            shortest and longest timescale probed by the underlying</span>
<span class="sd">            dataset.  Meant to be joined with new lines and printed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">span</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3600.0</span>
        <span class="n">sig_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="n">sig2_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%-10s</span><span class="s2"> </span><span class="si">%15s</span><span class="s2"> </span><span class="si">%15s</span><span class="s2">&quot;</span>
        <span class="n">dfmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%-10s</span><span class="s2"> </span><span class="si">%15.2f</span><span class="s2"> </span><span class="si">%15.2f</span><span class="s2">&quot;</span>
        <span class="n">llen</span> <span class="o">=</span> <span class="mi">43</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;SIGMA(TAU)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIGMA(TAU)&quot;</span><span class="p">]</span>
        <span class="n">per</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;@ </span><span class="si">{</span><span class="n">step</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> sec&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;@ </span><span class="si">{</span><span class="n">span</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> hr&quot;</span><span class="p">]</span>
        <span class="n">unt</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;INPUT&quot;</span><span class="p">,</span> <span class="s2">&quot;[psec]&quot;</span><span class="p">,</span> <span class="s2">&quot;[psec]&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;static_phi_fit&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%10s</span><span class="s2"> </span><span class="si">%10s</span><span class="s2">&quot;</span>
            <span class="n">dfmt</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%10.2f</span><span class="s2"> </span><span class="si">%10.2f</span><span class="s2">&quot;</span>
            <span class="n">llen</span> <span class="o">+=</span> <span class="mi">22</span>
            <span class="n">hdr</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;PHI0&quot;</span><span class="p">,</span> <span class="s2">&quot;TAU0&quot;</span><span class="p">]</span>
            <span class="n">per</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="n">unt</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;[rad]&quot;</span><span class="p">,</span> <span class="s2">&quot;[nsec]&quot;</span><span class="p">]</span>

        <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;-&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">llen</span><span class="p">)</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">fmt</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hdr</span><span class="p">),</span> <span class="n">fmt</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">per</span><span class="p">),</span> <span class="n">fmt</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unt</span><span class="p">),</span> <span class="n">line</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">inp</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">],</span> <span class="n">sig2_tau</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">sig_tau</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span>

            <span class="k">if</span> <span class="s2">&quot;static_phi_fit&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">static_phi_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_phi_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">]</span>

            <span class="n">summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dfmt</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">summary</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a summary of the timing correction nicely formatted for printing.</span>

<span class="sd">        Calls the method summary and joins the list of strings with new lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span></div>



<div class="viewcode-block" id="TimingData">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TimingData</span><span class="p">(</span><span class="n">andata</span><span class="o">.</span><span class="n">CorrData</span><span class="p">,</span> <span class="n">TimingCorrection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`andata.CorrData` for timing data.</span>

<span class="sd">    Automatically computes the timing correction when data is loaded and</span>
<span class="sd">    inherits the methods of :class:`TimingCorrection` that enable the application</span>
<span class="sd">    of that correction to other datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimingData.from_acq_h5">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingData.from_acq_h5">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_acq_h5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">acq_files</span><span class="p">,</span> <span class="n">only_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load a list of acquisition files and computes the timing correction.</span>

<span class="sd">        Accepts and passes on all keyword arguments for andata.CorrData.from_acq_h5</span>
<span class="sd">        and the construct_delay_template function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        acq_files: str or list of str</span>
<span class="sd">            Path to file(s) containing the timing data.</span>
<span class="sd">        only_correction: bool</span>
<span class="sd">            Only return the timing correction.  Do not return the underlying</span>
<span class="sd">            data from which that correction was derived.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: TimingData or TimingCorrection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Separate the kwargs for construct_delay_template.  This is necessary</span>
        <span class="c1"># because andata will not accept extraneous kwargs.</span>
        <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">construct_delay_template</span><span class="p">)</span>
        <span class="n">cdt_kwargs_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">insp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">insp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">:])</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">cdt_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cdt_kwargs_list</span><span class="p">:</span>
            <span class="n">cdt_kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Change some of the default parameters for CorrData.from_acq_h5 to reflect</span>
        <span class="c1"># the fact that this data will be used to compute a timing correction.</span>
        <span class="n">apply_gain</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;apply_gain&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">datasets</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">&quot;datasets&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;flags/vis_weight&quot;</span><span class="p">,</span> <span class="s2">&quot;flags/frac_lost&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Load the data into an andata.CorrData object</span>
        <span class="n">corr_data</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span>
            <span class="n">acq_files</span><span class="p">,</span> <span class="n">apply_gain</span><span class="o">=</span><span class="n">apply_gain</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="n">datasets</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Instantiate a TimingCorrection or TimingData object</span>
        <span class="n">dist_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;distributed&quot;</span><span class="p">:</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span> <span class="s2">&quot;comm&quot;</span><span class="p">:</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">comm</span><span class="p">}</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">TimingCorrection</span><span class="p">(</span><span class="o">**</span><span class="n">dist_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">only_correction</span>
            <span class="k">else</span> <span class="n">TimingData</span><span class="p">(</span><span class="o">**</span><span class="n">dist_kwargs</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Redefine input axis to contain only noise sources</span>
        <span class="n">isource</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">corr_data</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">noise_source</span> <span class="o">=</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="n">isource</span><span class="p">]</span>
        <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;noise_source&quot;</span><span class="p">,</span> <span class="n">noise_source</span><span class="p">)</span>

        <span class="c1"># Copy over relevant data to the newly instantiated object</span>
        <span class="k">if</span> <span class="n">only_correction</span><span class="p">:</span>
            <span class="c1"># We are only returning a correction, so we only need to</span>
            <span class="c1"># copy over a subset of index_map.</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">]:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">name</span><span class="p">][:])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are returning the data in addition to the correction.</span>
            <span class="c1"># Redefine prod axis to contain only noise sources.</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">corr_data</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">corr_data</span><span class="o">.</span><span class="n">prod</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">_search_array</span><span class="p">(</span><span class="n">isource</span><span class="p">,</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">])</span>
            <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">_search_array</span><span class="p">(</span><span class="n">isource</span><span class="p">,</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">])</span>
            <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>

            <span class="c1"># Copy over remaining index maps</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">index_map</span> <span class="ow">in</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">index_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">index_map</span><span class="p">[:])</span>

            <span class="c1"># Copy over the attributes</span>
            <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span><span class="n">corr_data</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

            <span class="c1"># Iterate over the datasets and copy them over</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">old_dset</span> <span class="ow">in</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">old_dset</span><span class="p">[:],</span> <span class="n">distributed</span><span class="o">=</span><span class="n">old_dset</span><span class="o">.</span><span class="n">distributed</span>
                <span class="p">)</span>
                <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span><span class="n">old_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">new_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

            <span class="c1"># Iterate over the flags and copy them over</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">old_dset</span> <span class="ow">in</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">old_dset</span><span class="p">[:],</span> <span class="n">distributed</span><span class="o">=</span><span class="n">old_dset</span><span class="o">.</span><span class="n">distributed</span>
                <span class="p">)</span>
                <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span><span class="n">old_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span> <span class="n">new_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># Construct delay template</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">construct_delay_template</span><span class="p">(</span><span class="n">corr_data</span><span class="p">,</span> <span class="o">**</span><span class="n">cdt_kwargs</span><span class="p">)</span>

        <span class="c1"># If we are only returning the timing correction, then remove</span>
        <span class="c1"># the amplitude and phase of the noise source</span>
        <span class="k">if</span> <span class="n">only_correction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;amp&quot;</span><span class="p">,</span> <span class="s2">&quot;weight_amp&quot;</span><span class="p">,</span> <span class="s2">&quot;phi&quot;</span><span class="p">,</span> <span class="s2">&quot;weight_phi&quot;</span><span class="p">]:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Create index map containing names of parameters</span>
        <span class="n">param</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">,</span> <span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="s2">&quot;quad&quot;</span><span class="p">,</span> <span class="s2">&quot;cube&quot;</span><span class="p">,</span> <span class="s2">&quot;quart&quot;</span><span class="p">,</span> <span class="s2">&quot;quint&quot;</span><span class="p">]</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;static_phi_fit&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">data</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">))</span>

        <span class="c1"># Create datasets containing the timing correction</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">DSET_SPEC</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">]:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span>

            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">)</span>

        <span class="c1"># Delete the temporary corr_data object</span>
        <span class="k">del</span> <span class="n">corr_data</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="c1"># Return timing data object</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="TimingData.summary">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingData.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide a summary of the timing data and correction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : list of strings</span>
<span class="sd">            Contains useful information about the timing correction</span>
<span class="sd">            and data.  Includes the reduction in the standard deviation</span>
<span class="sd">            of the phase after applying the timing correction.  This is</span>
<span class="sd">            presented as quantiles over frequency for each of the</span>
<span class="sd">            noise source products.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

        <span class="n">vis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_timing_correction</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">[:],</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">prod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">phi_before</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">[:])</span>
        <span class="n">phi_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>

        <span class="n">phi_before</span> <span class="o">=</span> <span class="n">_correct_phase_wrap</span><span class="p">(</span>
            <span class="n">phi_before</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">phi_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">phi_after</span> <span class="o">=</span> <span class="n">_correct_phase_wrap</span><span class="p">(</span>
            <span class="n">phi_after</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">phi_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">sig_before</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">phi_before</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">phi_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sig_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">phi_after</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">phi_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">ratio</span> <span class="o">=</span> <span class="n">sig_before</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sig_after</span><span class="p">)</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%-23s</span><span class="s2"> </span><span class="si">%5s</span><span class="s2"> </span><span class="si">%5s</span><span class="s2"> </span><span class="si">%8s</span><span class="s2"> </span><span class="si">%5s</span><span class="s2"> </span><span class="si">%5s</span><span class="s2">&quot;</span>
        <span class="n">hdr1</span> <span class="o">=</span> <span class="s2">&quot;Factor Reduction in RMS Phase Noise (Quantiles Over Frequency)&quot;</span>
        <span class="n">hdr2</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;PRODUCT&quot;</span><span class="p">,</span> <span class="s2">&quot;MIN&quot;</span><span class="p">,</span> <span class="s2">&quot;25%&quot;</span><span class="p">,</span> <span class="s2">&quot;MEDIAN&quot;</span><span class="p">,</span> <span class="s2">&quot;75%&quot;</span><span class="p">,</span> <span class="s2">&quot;MAX&quot;</span><span class="p">)</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;-&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">65</span><span class="p">)</span>
        <span class="n">summary</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">hdr1</span><span class="p">,</span> <span class="n">hdr2</span><span class="p">,</span> <span class="n">line</span><span class="p">]</span>

        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%-10s</span><span class="s2"> x </span><span class="si">%-10s</span><span class="s2"> </span><span class="si">%5d</span><span class="s2"> </span><span class="si">%5d</span><span class="s2"> </span><span class="si">%8d</span><span class="s2"> </span><span class="si">%5d</span><span class="s2"> </span><span class="si">%5d</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prod</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">summary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">fmt</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">noise_source</span><span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">stats</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span></div>
</div>



<div class="viewcode-block" id="TimingReader">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TimingReader</span><span class="p">(</span><span class="n">andata</span><span class="o">.</span><span class="n">BaseReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`BaseReader` for timing data.&quot;&quot;&quot;</span>

    <span class="n">data_class</span> <span class="o">=</span> <span class="n">TimingData</span></div>



<div class="viewcode-block" id="TimingInterpolator">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.TimingInterpolator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TimingInterpolator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolation that is aware of flagged data and weights.</span>

<span class="sd">    Flagged data is ignored during the interpolation. The weights from</span>
<span class="sd">    the data are propagated to obtain weights for the interpolated points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">extrap_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a callable TimingInterpolator object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : np.ndarray[nsample,]</span>
<span class="sd">            The points where the data was sampled.</span>
<span class="sd">            Must be monotonically increasing.</span>
<span class="sd">        y : np.ndarray[..., nsample]</span>
<span class="sd">            The data to interpolate.</span>
<span class="sd">        weight : np.ndarray[..., nsample]</span>
<span class="sd">            The uncertainty on the data, expressed as an</span>
<span class="sd">            inverse variance.</span>
<span class="sd">        flag : np.ndarray[..., nsample]</span>
<span class="sd">            Boolean indicating if the data is to be</span>
<span class="sd">            included in the interpolation.</span>
<span class="sd">        kind : str</span>
<span class="sd">            String that specifies the kind of interpolation.</span>
<span class="sd">            The value `nearest`, `previous`, `next`, and `linear` will use</span>
<span class="sd">            custom methods that propagate uncertainty to obtain the interpolated</span>
<span class="sd">            weights. The value `zero`, `slinear`, `quadratic`, and `cubic`</span>
<span class="sd">            will use spline interpolation from scipy.interpolation.interp1d</span>
<span class="sd">            and use the weight from the nearest point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolator : TimingInterpolator</span>
<span class="sd">            Callable that will interpolate the data that was provided</span>
<span class="sd">            to a new set of x values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span>

        <span class="k">if</span> <span class="n">extrap_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrap_limit</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrap_limit</span> <span class="o">=</span> <span class="n">extrap_limit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span> <span class="o">=</span> <span class="n">INTERPOLATION_LOOKUP</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">_interpolation_scipy</span><span class="p">(</span><span class="n">kind</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xeval : np.ndarray[neval,]</span>
<span class="sd">            Evaluate the interpolant at these points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yeval : np.ndarray[neval,]</span>
<span class="sd">            Interpolated values.</span>
<span class="sd">        weval : np.ndarray[neval,]</span>
<span class="sd">            Uncertainty on the interpolated values,</span>
<span class="sd">            expressed as an inverse variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure we are not extrapolating too much</span>
        <span class="n">dx_beg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xeval</span><span class="p">)</span>
        <span class="n">dx_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xeval</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dx_beg</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrap_limit</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dx_end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrap_limit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Extrapolating beyond span of data.&quot;</span><span class="p">)</span>

        <span class="c1"># Create arrays to hold interpolation</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">xeval</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">xeval</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span>

        <span class="n">yeval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">weval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Loop over other axes and interpolate along last axis</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">):</span>
            <span class="n">to_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flag</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">to_interp</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yeval</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">weval</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">to_interp</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">to_interp</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">to_interp</span><span class="p">],</span>
                    <span class="n">xeval</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">yeval</span><span class="p">,</span> <span class="n">weval</span></div>



<div class="viewcode-block" id="load_timing_correction">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.load_timing_correction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_timing_correction</span><span class="p">(</span>
    <span class="n">files</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mf">43200.0</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="s2">&quot;chime&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find and load the timing correction for a list of corr acquisition files.</span>

<span class="sd">    For example, if the instrument keyword is set to &#39;chime&#39;,</span>
<span class="sd">    then this function will accept all types of chime corr acquisition files,</span>
<span class="sd">    such as &#39;chimetiming&#39;, &#39;chimepb&#39;, &#39;chimeN2&#39;, &#39;chimecal&#39;, and then find</span>
<span class="sd">    the relevant set of &#39;chimetiming&#39; files to load.</span>

<span class="sd">    Accepts and passes on all keyword arguments for the functions</span>
<span class="sd">    andata.CorrData.from_acq_h5 and construct_delay_template.</span>

<span class="sd">    Should consider modifying this method to use Finder at some point in future.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    files : string or list of strings</span>
<span class="sd">        Absolute path to corr acquisition file(s).</span>
<span class="sd">    start : integer, optional</span>
<span class="sd">        What frame to start at in the full set of files.</span>
<span class="sd">    stop : integer, optional</span>
<span class="sd">        What frame to stop at in the full set of files.</span>
<span class="sd">    window : float</span>
<span class="sd">        Use the timing data -window from start and +window from stop.</span>
<span class="sd">        Default is 12 hours.</span>
<span class="sd">    instrument : string</span>
<span class="sd">        Name of the instrument.  Default is &#39;chime&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data: TimingData</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

    <span class="c1"># Check that a single acquisition was requested</span>
    <span class="n">input_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">input_dirs</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Input files span multiple acquisitions!&quot;</span><span class="p">)</span>

    <span class="c1"># Extract relevant information from the filename</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">input_dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">acq</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">input_dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">acq_date</span><span class="p">,</span> <span class="n">acq_inst</span><span class="p">,</span> <span class="n">acq_type</span> <span class="o">=</span> <span class="n">acq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">acq_inst</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">instrument</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">acq_type</span> <span class="o">!=</span> <span class="s2">&quot;corr&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;This function is only able to parse corr type files &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;from the specified instrument (currently </span><span class="si">{</span><span class="n">instrument</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Search for all timing acquisitions on this node</span>
    <span class="n">tdirs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">instrument</span> <span class="o">+</span> <span class="s2">&quot;timing&quot;</span><span class="p">,</span> <span class="n">acq_type</span><span class="p">])))</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tdirs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No timing acquisitions found on node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># Determine the start time of the requested acquistion and the available</span>
    <span class="c1"># timing acquisitions</span>
    <span class="n">acq_start</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">datetime_to_unix</span><span class="p">(</span><span class="n">ctime</span><span class="o">.</span><span class="n">timestr_to_datetime</span><span class="p">(</span><span class="n">acq_date</span><span class="p">))</span>

    <span class="n">tacq_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">ctime</span><span class="o">.</span><span class="n">timestr_to_datetime</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tdirs</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">tacq_start</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">datetime_to_unix</span><span class="p">(</span><span class="n">tacq_start</span><span class="p">)</span>

    <span class="c1"># Find the closest timing acquisition to the requested acquisition</span>
    <span class="n">iclose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">acq_start</span> <span class="o">-</span> <span class="n">tacq_start</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">acq_start</span> <span class="o">-</span> <span class="n">tacq_start</span><span class="p">[</span><span class="n">iclose</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">60.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find appropriate timing acquisition for </span><span class="si">{</span><span class="n">acq</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># Grab all timing files from this acquisition</span>
    <span class="n">tfiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tdirs</span><span class="p">[</span><span class="n">iclose</span><span class="p">],</span> <span class="s2">&quot;*.h5&quot;</span><span class="p">)))</span>

    <span class="n">tdata</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">CorrData</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span><span class="n">tfiles</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="p">())</span>

    <span class="c1"># Find relevant span of time</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">CorrData</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="p">())</span>

    <span class="n">time_start</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span>
    <span class="n">time_stop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">window</span>

    <span class="n">tstart</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time_start</span> <span class="o">-</span> <span class="n">tdata</span><span class="o">.</span><span class="n">time</span><span class="p">)))</span>
    <span class="n">tstop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">time_stop</span> <span class="o">-</span> <span class="n">tdata</span><span class="o">.</span><span class="n">time</span><span class="p">)))</span>

    <span class="c1"># Load into TimingData object</span>
    <span class="k">return</span> <span class="n">TimingData</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span><span class="n">tfiles</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">tstop</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="c1"># ancillary functions</span>
<span class="c1"># -------------------</span>


<div class="viewcode-block" id="construct_delay_template">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.construct_delay_template">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">construct_delay_template</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">min_frac_kept</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.50</span><span class="p">,</span>
    <span class="n">min_freq</span><span class="o">=</span><span class="mf">420.0</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="o">=</span><span class="mf">780.0</span><span class="p">,</span>
    <span class="n">mask_rfi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_iter_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">check_amp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">nsigma_amp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">check_phi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">nsigma_phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nparam</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">static_phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_static_phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">static_phi_fit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">static_amp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_static_amp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a relative time delay template.</span>

<span class="sd">    Fits the phase of the cross-correlation between noise source inputs</span>
<span class="sd">    to a model that increases linearly with frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: andata.CorrData</span>
<span class="sd">        Correlation data.  Must contain the following attributes:</span>
<span class="sd">            freq: np.ndarray[nfreq, ]</span>
<span class="sd">                Frequency in MHz.</span>
<span class="sd">            vis: np.ndarray[nfreq, nprod, ntime]</span>
<span class="sd">                Upper-triangle, product packed visibility matrix</span>
<span class="sd">                containing ONLY the noise source inputs.</span>
<span class="sd">            weight: np.ndarray[nfreq, nprod, ntime]</span>
<span class="sd">                Flag indicating the data points to fit.</span>
<span class="sd">            flags/frac_lost: np.ndarray[nfreq, ntime]</span>
<span class="sd">                Flag indicating the fraction of data lost.</span>
<span class="sd">                If provided, then data will be weighted by the</span>
<span class="sd">                fraction of data that remains when solving</span>
<span class="sd">                for the delay template.</span>
<span class="sd">    min_frac_kept: float</span>
<span class="sd">        Do not include frequencies and times where the fraction</span>
<span class="sd">        of data that remains is less than this threshold.</span>
<span class="sd">        Default is 0.0.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        A (frequency, input) must pass the checks specified above</span>
<span class="sd">        more than this fraction of the time,  otherwise it will be</span>
<span class="sd">        flaged as bad for all times.  Default is 0.50.</span>
<span class="sd">    min_freq: float</span>
<span class="sd">        Minimum frequency in MHz to include in the fit.</span>
<span class="sd">        Default is 420.</span>
<span class="sd">    max_freq: float</span>
<span class="sd">        Maximum frequency in MHz to include in the fit.</span>
<span class="sd">        Default is 780.</span>
<span class="sd">    mask_rfi: bool</span>
<span class="sd">        Mask frequencies that occur within known RFI bands.  Note that the</span>
<span class="sd">        noise source data does not contain RFI, however the real-time pipeline</span>
<span class="sd">        does not distinguish between noise source inputs and sky inputs, and as</span>
<span class="sd">        a result will discard large amounts of data in these bands.</span>
<span class="sd">    max_iter_weight: int</span>
<span class="sd">        The weight for each frequency is estimated from the variance of the</span>
<span class="sd">        residuals of the template fit from the previous iteration.  Outliers</span>
<span class="sd">        are also flagged at each iteration with an increasingly aggresive threshold.</span>
<span class="sd">        This is the total number of times to iterate.  Setting to 1 corresponds</span>
<span class="sd">        to linear least squares.  Default is 1, unless check_amp or check_phi is True,</span>
<span class="sd">        in which case this defaults to the maximum number of thresholds provided.</span>
<span class="sd">    check_amp: bool</span>
<span class="sd">        Do not fit frequencies and times where the residual amplitude is an outlier.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    nsigma_amp: list of float</span>
<span class="sd">        If check_amp is True, then residuals greater than this number of sigma</span>
<span class="sd">        will be considered an outlier.  Provide a list containing the value to be used</span>
<span class="sd">        at each iteration.  If the length of the list is less than max_iter_weight,</span>
<span class="sd">        then the last value in the list will be repeated for the remaining iterations.</span>
<span class="sd">        Default is [1000, 500, 200, 100, 50, 20, 10, 5].</span>
<span class="sd">    check_phi: bool</span>
<span class="sd">        Do not fit frequencies and times where the residual phase is an outlier.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    nsigma_phi: list of float</span>
<span class="sd">        If check_phi is True, then residuals greater than this number of sigma</span>
<span class="sd">        will be considered an outlier.  Provide a list containing the value to be used</span>
<span class="sd">        at each iteration.  If the length of the list is less than max_iter_weight,</span>
<span class="sd">        then the last value in the list will be repeated for the remaining iterations.</span>
<span class="sd">        Default is [1000, 500, 200, 100, 50, 20, 10, 5].</span>
<span class="sd">    nparam: int</span>
<span class="sd">        Number of parameters for polynomial fit to the</span>
<span class="sd">        time averaged phase versus frequency.  Default is 2.</span>
<span class="sd">    static_phi: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Subtract this quantity from the noise source phase prior to fitting</span>
<span class="sd">        for the timing correction.  If None, then this will be estimated from</span>
<span class="sd">        the median of the noise source phase over time.</span>
<span class="sd">    weight_static_phi: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Inverse variance of the time averaged phased.  Set to zero for</span>
<span class="sd">        frequencies and inputs that are missing or should be ignored.</span>
<span class="sd">        If None, then this will be estimated from the residuals of the fit.</span>
<span class="sd">    static_phi_fit: np.ndarray[nparam, nsource]</span>
<span class="sd">        Polynomial fit to static_phi versus frequency.</span>
<span class="sd">    static_amp: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Subtract this quantity from the noise source amplitude prior to fitting</span>
<span class="sd">        for the amplitude variations.  If None, then this will be estimated from</span>
<span class="sd">        the median of the noise source amplitude over time.</span>
<span class="sd">    weight_static_amp: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Inverse variance of the time averaged amplitude.  Set to zero for</span>
<span class="sd">        frequencies and inputs that are missing or should be ignored.  If None,</span>
<span class="sd">        then this will be estimated from the residuals of the fit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phi: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">        Phase of the signal from the noise source.</span>
<span class="sd">    weight_phi: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">        Inverse variance of the phase of the signal from the noise source.</span>
<span class="sd">    tau: np.ndarray[nsource, ntime]</span>
<span class="sd">        Delay template for each noise source input.</span>
<span class="sd">    weight_tau: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Estimate of the uncertainty on the delay template (inverse variance).</span>
<span class="sd">    static_phi: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Time averaged phase versus frequency.</span>
<span class="sd">    weight_static_phi: np.ndarray[nfreq, nsource]</span>
<span class="sd">       Inverse variance of the time averaged phase.</span>
<span class="sd">    static_phi_fit: np.ndarray[nparam, nsource]</span>
<span class="sd">        Best-fit parameters of the polynomial fit to the</span>
<span class="sd">        time averaged phase versus frequency.</span>
<span class="sd">    amp: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">        Amplitude of the signal from the noise source.</span>
<span class="sd">    weight_amp: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">        Inverse variance of the amplitude of the signal from the noise source.</span>
<span class="sd">    alpha: np.ndarray[nsource, ntime]</span>
<span class="sd">        Amplitude coefficient for each noise source input.</span>
<span class="sd">    weight_alpha: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Estimate of the uncertainty on the amplitude coefficient (inverse variance).</span>
<span class="sd">    static_amp: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Time averaged amplitude versus frequency.</span>
<span class="sd">    weight_static_amp: np.ndarray[nfreq, nsource]</span>
<span class="sd">        Inverse variance of the time averaged amplitude.</span>
<span class="sd">    num_freq: np.ndarray[nsource, ntime]</span>
<span class="sd">        Number of frequencies used to construct the delay and amplitude templates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if we are distributed.  If so make sure we are distributed over time.</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="n">memh5</span><span class="o">.</span><span class="n">MemDatasetDistributed</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">comm</span>

    <span class="c1"># Extract relevant datasets</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>
    <span class="n">vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="c1"># Check dimensions</span>
    <span class="n">nfreq</span><span class="p">,</span> <span class="n">nprod</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nsource</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">nprod</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">ilocal</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsource</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">nfreq</span> <span class="o">==</span> <span class="n">freq</span><span class="o">.</span><span class="n">size</span>
    <span class="k">assert</span> <span class="n">nsource</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">nparam</span> <span class="o">&gt;=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">static_phi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">static_phi</span><span class="p">,</span> <span class="n">sphi_shp</span><span class="p">,</span> <span class="n">sphi_ind</span> <span class="o">=</span> <span class="n">_resolve_distributed</span><span class="p">(</span><span class="n">static_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">sphi_shp</span> <span class="o">==</span> <span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weight_static_phi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight_static_phi</span><span class="p">,</span> <span class="n">wsphi_shp</span><span class="p">,</span> <span class="n">wsphi_ind</span> <span class="o">=</span> <span class="n">_resolve_distributed</span><span class="p">(</span>
            <span class="n">weight_static_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">wsphi_shp</span> <span class="o">==</span> <span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">static_phi_fit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">static_phi_fit</span><span class="p">,</span> <span class="n">sphifit_shp</span><span class="p">,</span> <span class="n">sphifit_ind</span> <span class="o">=</span> <span class="n">_resolve_distributed</span><span class="p">(</span>
            <span class="n">static_phi_fit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">sphifit_shp</span> <span class="o">==</span> <span class="p">(</span><span class="n">nparam</span><span class="p">,</span> <span class="n">nsource</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">static_amp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">static_amp</span><span class="p">,</span> <span class="n">samp_shp</span><span class="p">,</span> <span class="n">samp_ind</span> <span class="o">=</span> <span class="n">_resolve_distributed</span><span class="p">(</span><span class="n">static_amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">samp_shp</span> <span class="o">==</span> <span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weight_static_amp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight_static_amp</span><span class="p">,</span> <span class="n">wsamp_shp</span><span class="p">,</span> <span class="n">wsamp_ind</span> <span class="o">=</span> <span class="n">_resolve_distributed</span><span class="p">(</span>
            <span class="n">weight_static_amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">wsamp_shp</span> <span class="o">==</span> <span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">)</span>

    <span class="c1"># Set default nsigma for flagging outliers</span>
    <span class="k">if</span> <span class="n">nsigma_amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nsigma_amp</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">500.0</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">nsigma_amp</span><span class="p">):</span>
        <span class="n">nsigma_amp</span> <span class="o">=</span> <span class="p">[</span><span class="n">nsigma_amp</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">nsigma_phi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nsigma_phi</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">500.0</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">nsigma_phi</span><span class="p">):</span>
        <span class="n">nsigma_phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">nsigma_phi</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">max_iter_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_iter_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">nsigma_amp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">check_amp</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">nsigma_phi</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">check_phi</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_iter_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_iter_weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">nsigma_amp</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nsigma_amp</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nsigma_amp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter_weight</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">nsigma_phi</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">nsigma_phi</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nsigma_phi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter_weight</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Compute amplitude of noise source signal from autocorrelation</span>
    <span class="n">iauto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nsource</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsource</span><span class="p">)])</span>

    <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">iauto</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="c1"># Determine which data points to fit</span>
    <span class="n">flg</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">flg</span> <span class="o">&amp;=</span> <span class="n">weight</span><span class="p">[:,</span> <span class="n">iauto</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

    <span class="c1"># If requested discard frequencies and times that have high frac_lost</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;frac_lost&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fraction of data kept must be greater than </span><span class="si">{</span><span class="n">min_frac_kept</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">frac_kept</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;frac_lost&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">flg</span> <span class="o">&amp;=</span> <span class="n">frac_kept</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">min_frac_kept</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">frac_kept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Restrict the range of frequencies that are fit to avoid bandpass edges</span>
    <span class="n">limit_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">min_freq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="n">max_freq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask_rfi</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Masking RFI bands.&quot;</span><span class="p">)</span>
        <span class="n">limit_freq</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">freq_width</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">][:]</span>
        <span class="p">)</span>

    <span class="n">flg</span> <span class="o">=</span> <span class="p">(</span><span class="n">flg</span> <span class="o">&amp;</span> <span class="n">limit_freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># If we only have two noise source inputs, then we use the cross-correlation</span>
    <span class="c1"># between them to characterize their relative response to the noise source signal.</span>
    <span class="c1"># If we have more than two noise source inputs, then we perform an eigenvalue</span>
    <span class="c1"># decomposition of the cross-correlation matrix to obtain an improved estimate</span>
    <span class="c1"># of the response of each input to the noise source signal.</span>
    <span class="k">if</span> <span class="n">nsource</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">eigen_decomposition</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">flg</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

        <span class="n">ww</span> <span class="o">=</span> <span class="n">flg</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">,</span> <span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vis</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

        <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">iauto</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

        <span class="n">ww</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">flg</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">flg</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Scale the flag by the fraction of data that was kept</span>
    <span class="n">ww</span> <span class="o">*=</span> <span class="n">frac_kept</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># If parallelized we need to redistribute over inputs for the</span>
    <span class="c1"># operations below, which require full frequency and time coverage.</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">ww</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">ww</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">amp</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ww</span> <span class="o">=</span> <span class="n">ww</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">nsource</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ilocal</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">amp</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nsource</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;I am processing </span><span class="si">{nsource}</span><span class="s2"> noise source inputs.&quot;</span><span class="p">)</span>

        <span class="n">amp</span> <span class="o">=</span> <span class="n">amp</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">ww</span> <span class="o">=</span> <span class="n">ww</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="c1"># If a frequency is flagged more than `threshold` fraction of the time,</span>
    <span class="c1"># then flag it entirely</span>
    <span class="n">ww</span> <span class="o">*=</span> <span class="p">(</span>
        <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="o">&gt;</span> <span class="n">threshold</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">fraction</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mf">100.0</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ww</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fraction</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> percent of frequencies will be used &quot;</span>
        <span class="s2">&quot;to construct timing correction.&quot;</span>
    <span class="p">)</span>

    <span class="c1"># If the starting values for the mean and variance were not provided,</span>
    <span class="c1"># then estimate them from the data.</span>
    <span class="k">if</span> <span class="n">static_phi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">static_phi</span> <span class="o">=</span> <span class="n">_flagged_median</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sphi_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sphi_ind</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ilcl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ilcl</span> <span class="ow">in</span> <span class="n">ilocal</span><span class="p">])</span>
        <span class="n">static_phi</span> <span class="o">=</span> <span class="n">static_phi</span><span class="p">[:,</span> <span class="n">sphi_ind</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">weight_static_phi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight_static_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wsphi_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wsphi_ind</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ilcl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ilcl</span> <span class="ow">in</span> <span class="n">ilocal</span><span class="p">])</span>
        <span class="n">weight_static_phi</span> <span class="o">=</span> <span class="n">weight_static_phi</span><span class="p">[:,</span> <span class="n">wsphi_ind</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">static_amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">static_amp</span> <span class="o">=</span> <span class="n">_flagged_median</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">samp_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">samp_ind</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ilcl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ilcl</span> <span class="ow">in</span> <span class="n">ilocal</span><span class="p">])</span>
        <span class="n">static_amp</span> <span class="o">=</span> <span class="n">static_amp</span><span class="p">[:,</span> <span class="n">samp_ind</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">weight_static_amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight_static_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wsamp_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wsamp_ind</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ilcl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ilcl</span> <span class="ow">in</span> <span class="n">ilocal</span><span class="p">])</span>
        <span class="n">weight_static_amp</span> <span class="o">=</span> <span class="n">weight_static_amp</span><span class="p">[:,</span> <span class="n">wsamp_ind</span><span class="p">]</span>

    <span class="c1"># Fit frequency dependence of amplitude and phase</span>
    <span class="c1"># damp = asc * dalpha    and    dphi = omega * dtau</span>
    <span class="n">asc</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_amplitude_scaling</span><span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="o">*</span> <span class="n">static_amp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Estimate variance of each frequency from residuals</span>
    <span class="k">for</span> <span class="n">iter_weight</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter_weight</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">iter_weight</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">max_iter_weight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>

        <span class="n">dphi</span> <span class="o">=</span> <span class="n">_correct_phase_wrap</span><span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="n">static_phi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">damp</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">-</span> <span class="n">static_amp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">weight_amp</span> <span class="o">=</span> <span class="n">ww</span> <span class="o">*</span> <span class="n">weight_static_amp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">weight_phi</span> <span class="o">=</span> <span class="n">ww</span> <span class="o">*</span> <span class="n">weight_static_phi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Construct alpha template</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_amp</span> <span class="o">*</span> <span class="n">asc</span> <span class="o">*</span> <span class="n">damp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_amp</span> <span class="o">*</span> <span class="n">asc</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Construct delay template</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_phi</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">dphi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_phi</span> <span class="o">*</span> <span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Calculate amplitude residuals</span>
        <span class="n">ramp</span> <span class="o">=</span> <span class="n">damp</span> <span class="o">-</span> <span class="n">asc</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Calculate phase residuals</span>
        <span class="n">rphi</span> <span class="o">=</span> <span class="n">dphi</span> <span class="o">-</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">tau</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Calculate the mean and variance of the amplitude residuals</span>
        <span class="n">inv_num</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">mu_ramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span> <span class="o">*</span> <span class="n">ramp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_num</span>
        <span class="n">var_ramp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span> <span class="o">*</span> <span class="p">(</span><span class="n">ramp</span> <span class="o">-</span> <span class="n">mu_ramp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_num</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the mean and variance of the phase residuals</span>
        <span class="n">mu_rphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span> <span class="o">*</span> <span class="n">rphi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_num</span>
        <span class="n">var_rphi</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ww</span> <span class="o">*</span> <span class="p">(</span><span class="n">rphi</span> <span class="o">-</span> <span class="n">mu_rphi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_num</span>
        <span class="p">)</span>

        <span class="c1"># Update the static quantities</span>
        <span class="n">static_amp</span> <span class="o">=</span> <span class="n">static_amp</span> <span class="o">+</span> <span class="n">mu_ramp</span>
        <span class="n">static_phi</span> <span class="o">=</span> <span class="n">static_phi</span> <span class="o">+</span> <span class="n">mu_rphi</span>

        <span class="n">weight_static_amp</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var_ramp</span><span class="p">)</span>
        <span class="n">weight_static_phi</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var_rphi</span><span class="p">)</span>

        <span class="c1"># Flag outliers</span>
        <span class="n">not_outlier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_amp</span><span class="p">:</span>
            <span class="n">nsigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ramp</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weight_static_amp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="n">not_outlier</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nsigma</span> <span class="o">&lt;</span> <span class="n">nsigma_amp</span><span class="p">[</span><span class="n">iter_weight</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nsigma_amp = </span><span class="si">{</span><span class="n">nsigma_amp</span><span class="p">[</span><span class="n">iter_weight</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_phi</span><span class="p">:</span>
            <span class="n">nsigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rphi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weight_static_phi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="n">not_outlier</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nsigma</span> <span class="o">&lt;</span> <span class="n">nsigma_phi</span><span class="p">[</span><span class="n">iter_weight</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nsigma_phi = </span><span class="si">{</span><span class="n">nsigma_phi</span><span class="p">[</span><span class="n">iter_weight</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_amp</span> <span class="ow">or</span> <span class="n">check_phi</span><span class="p">:</span>
            <span class="n">ww</span> <span class="o">*=</span> <span class="n">not_outlier</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

    <span class="c1"># Calculate the number of frequencies used in the fit</span>
    <span class="n">num_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_amp</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Calculate the uncertainties on the fit parameters</span>
    <span class="n">weight_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_phi</span> <span class="o">*</span> <span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">weight_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_amp</span> <span class="o">*</span> <span class="n">asc</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate the average delay over this period using non-linear</span>
    <span class="c1"># least squares that is insensitive to phase wrapping</span>
    <span class="k">if</span> <span class="n">static_phi_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">err_static_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_static_phi</span><span class="p">))</span>

        <span class="n">static_phi_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nparam</span><span class="p">,</span> <span class="n">nsource</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsource</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err_static_phi</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nparam</span><span class="p">:</span>
                <span class="n">static_phi_fit</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_poly_to_phase</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">static_phi</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">]),</span>
                    <span class="n">err_static_phi</span><span class="p">[:,</span> <span class="n">nn</span><span class="p">],</span>
                    <span class="n">nparam</span><span class="o">=</span><span class="n">nparam</span><span class="p">,</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sphifit_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sphifit_ind</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ilcl</span><span class="p">)</span> <span class="k">for</span> <span class="n">ilcl</span> <span class="ow">in</span> <span class="n">ilocal</span><span class="p">])</span>
        <span class="n">static_phi_fit</span> <span class="o">=</span> <span class="n">static_phi_fit</span><span class="p">[:,</span> <span class="n">sphifit_ind</span><span class="p">]</span>

    <span class="c1"># Convert the outputs to MPIArrays distributed over input</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">weight_tau</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">weight_tau</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">weight_alpha</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">weight_alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">static_phi</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">static_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">static_amp</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">static_amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">weight_static_phi</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">weight_static_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">weight_static_amp</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">weight_static_amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">static_phi_fit</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">static_phi_fit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">num_freq</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">num_freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">weight_phi</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">weight_phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">weight_amp</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">weight_amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="n">tau</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span>
        <span class="s2">&quot;weight_tau&quot;</span><span class="p">:</span> <span class="n">weight_tau</span><span class="p">,</span>
        <span class="s2">&quot;weight_alpha&quot;</span><span class="p">:</span> <span class="n">weight_alpha</span><span class="p">,</span>
        <span class="s2">&quot;static_phi&quot;</span><span class="p">:</span> <span class="n">static_phi</span><span class="p">,</span>
        <span class="s2">&quot;static_amp&quot;</span><span class="p">:</span> <span class="n">static_amp</span><span class="p">,</span>
        <span class="s2">&quot;weight_static_phi&quot;</span><span class="p">:</span> <span class="n">weight_static_phi</span><span class="p">,</span>
        <span class="s2">&quot;weight_static_amp&quot;</span><span class="p">:</span> <span class="n">weight_static_amp</span><span class="p">,</span>
        <span class="s2">&quot;static_phi_fit&quot;</span><span class="p">:</span> <span class="n">static_phi_fit</span><span class="p">,</span>
        <span class="s2">&quot;num_freq&quot;</span><span class="p">:</span> <span class="n">num_freq</span><span class="p">,</span>
        <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span>
        <span class="s2">&quot;amp&quot;</span><span class="p">:</span> <span class="n">amp</span><span class="p">,</span>
        <span class="s2">&quot;weight_phi&quot;</span><span class="p">:</span> <span class="n">weight_phi</span><span class="p">,</span>
        <span class="s2">&quot;weight_amp&quot;</span><span class="p">:</span> <span class="n">weight_amp</span><span class="p">,</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="map_input_to_noise_source">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.map_input_to_noise_source">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_input_to_noise_source</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">noise_sources</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the appropriate noise source to use to correct the phase of each input.</span>

<span class="sd">    Searches for a noise source connected to the same slot,</span>
<span class="sd">    then crate, then hut, then correlator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs:  np.ndarray[ninput, ] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">        The input axis from a data acquisition file.</span>
<span class="sd">    noise_sources: np.ndarray[nsource, ] of dtype=(&#39;chan_id&#39;, &#39;correlator_input&#39;)</span>
<span class="sd">        The noise sources.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define functions</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_serial</span><span class="p">(</span><span class="n">input_serial</span><span class="p">):</span>
        <span class="c1"># Have to distinguish between CHIME WRH and ERH</span>
        <span class="c1"># Otherwise serial numbers already have the</span>
        <span class="c1"># desired hierarchical structure.</span>

        <span class="c1"># Serial from file is often bytes, ensure it is unicode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_serial</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">input_serial</span> <span class="o">=</span> <span class="n">input_serial</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">input_serial</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;FCC&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_serial</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;FCCW&quot;</span> <span class="o">+</span> <span class="n">input_serial</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;FCCE&quot;</span> <span class="o">+</span> <span class="n">input_serial</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">input_serial</span>

        <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count_startswith</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">cnt</span>

    <span class="c1"># Create hierarchical identifier from serial number for the</span>
    <span class="c1"># noise sources and requested inputs</span>
    <span class="n">input_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">parse_serial</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">]))</span>
    <span class="n">source_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">parse_serial</span><span class="p">,</span> <span class="n">noise_sources</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">]))</span>

    <span class="c1"># Map each input to a noise source</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">count_startswith</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">source_names</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">input_names</span>
    <span class="p">]</span></div>



<div class="viewcode-block" id="eigen_decomposition">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.eigen_decomposition">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eigen_decomposition</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Eigenvalue decomposition of the visibility matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vis: np.ndarray[nfreq, nprod, ntime]</span>
<span class="sd">        Upper-triangle, product packed visibility matrix.</span>
<span class="sd">    flag: np.ndarray[nfreq, nsource, ntime] (optional)</span>
<span class="sd">        Array of 1 or 0 indicating the inputs that should be included</span>
<span class="sd">        in the eigenvalue decomposition for each frequency and time.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    resp: np.ndarray[nfreq, nsource, ntime]</span>
<span class="sd">        Eigenvector corresponding to the largest eigenvalue for</span>
<span class="sd">        each frequency and time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nfreq</span><span class="p">,</span> <span class="n">nprod</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nsource</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">nprod</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Do not bother performing the eigen-decomposition for</span>
    <span class="c1"># times and frequencies that are entirely flagged</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Indexing the flag and vis datasets with ind flattens</span>
    <span class="c1"># the frequency and time dimension.  This results in</span>
    <span class="c1"># flg having shape (nfreq x ntime, nsource) and</span>
    <span class="c1"># Q having shape (nfreq x ntime, nsource, nsource).</span>
    <span class="n">flg</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">flg</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="o">*</span> <span class="n">flg</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">unpack_product_array</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Solve for eigenvectors and eigenvalues</span>
    <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

    <span class="c1"># Set phase convention</span>
    <span class="n">sign0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">evecs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="c1"># Determine response of each source</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">,</span> <span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">resp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">flg</span> <span class="o">*</span> <span class="n">sign0</span> <span class="o">*</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">evals</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="k">return</span> <span class="n">resp</span></div>



<div class="viewcode-block" id="fit_poly_to_phase">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.fit_poly_to_phase">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_poly_to_phase</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">resp</span><span class="p">,</span> <span class="n">resp_error</span><span class="p">,</span> <span class="n">nparam</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fit complex data versus frequency to a model consisting of a polynomial in phase.</span>

<span class="sd">    Nonlinear least squares algorithm is applied to the complex data to avoid problems</span>
<span class="sd">    caused by phase wrapping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq: np.ndarray[nfreq, ]</span>
<span class="sd">        Frequency in MHz.</span>
<span class="sd">    resp: np.ndarray[nfreq, ]</span>
<span class="sd">        Complex data with magnitude equal to 1.0.</span>
<span class="sd">    resp_error: np.ndarray[nfreq, ]</span>
<span class="sd">        Uncertainty on the complex data.</span>
<span class="sd">    nparam: int</span>
<span class="sd">        Number of parameters in the polynomial.</span>
<span class="sd">        Default is 2 (i.e, linear).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    popt: np.ndarray[nparam, ]</span>
<span class="sd">        Best-fit parameters.</span>
<span class="sd">    pcov: np.ndarray[nparam, nparam]</span>
<span class="sd">        Covariance of the best-fit parameters.</span>
<span class="sd">        Assumes that it obtained a good fit</span>
<span class="sd">        and returns the errors</span>
<span class="sd">        necessary to achieve that.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">resp_error</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flg</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nparam</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Number of data points must be greater than number of parameters &quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">nparam</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># We will fit the complex data.  Break n-element complex array g(ra)</span>
    <span class="c1"># into 2n-element real array [Re{g(ra)}, Im{g(ra)}] for fit.</span>
    <span class="n">y_complex</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="n">flg</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y_complex</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">y_complex</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="n">flg</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">resp_error</span><span class="p">[</span><span class="n">flg</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Initial guess for parameters</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nparam</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y_complex</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="n">flg</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
        <span class="n">_correct_phase_wrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y_complex</span><span class="p">)</span> <span class="o">-</span> <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[</span><span class="n">flg</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># Try nonlinear least squares fit</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span>
            <span class="n">_func_poly_phase</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sigma</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">excep</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nonlinear phase fit failed with error: </span><span class="si">{</span><span class="n">excep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Fit failed, return the initial parameter estimates</span>
        <span class="n">popt</span> <span class="o">=</span> <span class="n">p0</span>
        <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nparam</span><span class="p">,</span> <span class="n">nparam</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span></div>



<div class="viewcode-block" id="model_poly_phase">
<a class="viewcode-back" href="../../_autosummary/ch_util.timing.html#ch_util.timing.model_poly_phase">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">model_poly_phase</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="o">*</span><span class="n">param</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate a polynomial model for the phase.</span>

<span class="sd">    To be used with the parameters output from fit_poly_to_phase.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq: np.ndarray[nfreq, ]</span>
<span class="sd">        Frequency in MHz.</span>
<span class="sd">    *param: float</span>
<span class="sd">        Coefficients of the polynomial.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phi: np.ndarray[nfreq, ]</span>
<span class="sd">        Phase in radians between -pi and +pi.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span>

    <span class="n">model_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
        <span class="n">model_phase</span> <span class="o">+=</span> <span class="n">par</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">pp</span>

    <span class="n">model_phase</span> <span class="o">=</span> <span class="n">model_phase</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">model_phase</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">model_phase</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">model_phase</span></div>



<span class="c1"># private functions</span>
<span class="c1"># -----------------</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_amplitude_scaling</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">freq</span> <span class="o">/</span> <span class="n">FREQ_PIVOT</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_flagged_median</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">bflag</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">nandata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">nandata</span><span class="p">[</span><span class="n">bflag</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">bflag</span><span class="p">]</span>

    <span class="n">sortdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">nandata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ieval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sortdata</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ieval</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sortdata</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">aind</span><span class="p">,</span> <span class="n">sind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">ieval</span><span class="p">):</span>
        <span class="n">find</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aind</span><span class="p">)</span>
        <span class="n">find</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sind</span>

        <span class="n">sdata</span> <span class="o">=</span> <span class="n">sortdata</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">find</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sdata</span><span class="p">):</span>
            <span class="n">med</span><span class="p">[</span><span class="n">aind</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdata</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">med</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">med</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_func_poly_phase</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="o">*</span><span class="n">param</span><span class="p">):</span>
    <span class="n">nreal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">FREQ_TO_OMEGA</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[:</span><span class="n">nreal</span><span class="p">]</span>

    <span class="n">model_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
        <span class="n">model_phase</span> <span class="o">+=</span> <span class="n">par</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">pp</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">model_phase</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">model_phase</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_correct_phase_wrap</span><span class="p">(</span><span class="n">phi</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">phi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_weight_propagation_addition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">sum_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">sum_variance</span> <span class="o">+=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sum_variance</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_resolve_distributed</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">):</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">global_shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">global_shape</span>
        <span class="n">ilocal</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">arr</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">global_shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">ilocal</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">global_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">arr</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">global_shape</span><span class="p">,</span> <span class="n">ilocal</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_search_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
    <span class="n">index_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="n">index_previous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">index_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index_next</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xeval</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">index_previous</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xeval</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">index_next</span><span class="p">]),</span>
        <span class="n">index_previous</span><span class="p">,</span>
        <span class="n">index_next</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_interpolation_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">)</span>

    <span class="n">yeval</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">weval</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">yeval</span><span class="p">,</span> <span class="n">weval</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_interpolation_previous</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_interpolation_next</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_interpolation_linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="n">ind1</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ind2</span> <span class="o">=</span> <span class="n">index</span>

    <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">ind1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">below</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind1</span><span class="p">[</span><span class="n">below</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ind2</span><span class="p">[</span><span class="n">below</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">ind2</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">above</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind1</span><span class="p">[</span><span class="n">above</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">ind2</span><span class="p">[</span><span class="n">above</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">adx1</span> <span class="o">=</span> <span class="n">xeval</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span>
    <span class="n">adx2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">-</span> <span class="n">xeval</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">adx1</span> <span class="o">+</span> <span class="n">adx2</span><span class="p">)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">adx2</span> <span class="o">*</span> <span class="n">norm</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">adx1</span> <span class="o">*</span> <span class="n">norm</span>

    <span class="n">yeval</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span>
    <span class="n">weval</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">ind2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">yeval</span><span class="p">,</span> <span class="n">weval</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_interpolation_scipy</span><span class="p">(</span><span class="n">kind</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span>
        <span class="p">)</span>
        <span class="n">yeval</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">xeval</span><span class="p">)</span>

        <span class="c1"># For the scipy interpolation, we do not attempt to propagate the errors.</span>
        <span class="c1"># Instead we just use the weight from the nearest point.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">)</span>
        <span class="n">weval</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">yeval</span><span class="p">,</span> <span class="n">weval</span>

    <span class="k">return</span> <span class="n">_interp1d</span>


<span class="n">INTERPOLATION_LOOKUP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;nearest&quot;</span><span class="p">:</span> <span class="n">_interpolation_nearest</span><span class="p">,</span>
    <span class="s2">&quot;previous&quot;</span><span class="p">:</span> <span class="n">_interpolation_previous</span><span class="p">,</span>
    <span class="s2">&quot;next&quot;</span><span class="p">:</span> <span class="n">_interpolation_next</span><span class="p">,</span>
    <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="n">_interpolation_linear</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013–2024, CHIME Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>