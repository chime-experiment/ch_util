

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ch_util.tools &mdash; ch_util 25.3.1.post7+git.a3fec444 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/katex-math.css?v=05624691" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1d928e64"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/katex.min.js?v=5cc8ed51"></script>
      <script src="../../_static/auto-render.min.js?v=af98beb9"></script>
      <script src="../../_static/katex_autorenderer.js?v=bebc588a"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ch_util
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ch_util</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ch_util.tools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ch_util.tools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for CHIME analysis</span>

<span class="sd">A collection of miscellaneous utility routines.</span>


<span class="sd">Correlator Inputs</span>
<span class="sd">=================</span>

<span class="sd">Query the layout database to find out what is ultimately connected at the end</span>
<span class="sd">of correlator inputs. This is done by calling the routine</span>
<span class="sd">:func:`get_correlator_inputs`, which returns a list of the inputs. Routines</span>
<span class="sd">such as :func:`get_feed_positions` operate on this list.</span>

<span class="sd">- :py:meth:`get_correlator_inputs`</span>
<span class="sd">- :py:meth:`get_feed_positions`</span>
<span class="sd">- :py:meth:`get_feed_polarisations`</span>
<span class="sd">- :py:meth:`is_array`</span>
<span class="sd">- :py:meth:`is_array_x`</span>
<span class="sd">- :py:meth:`is_array_y`</span>
<span class="sd">- :py:meth:`is_array_on`</span>
<span class="sd">- :py:meth:`is_chime`</span>
<span class="sd">- :py:meth:`is_pathfinder`</span>
<span class="sd">- :py:meth:`is_holographic`</span>
<span class="sd">- :py:meth:`is_noise_source`</span>
<span class="sd">- :py:meth:`reorder_correlator_inputs`</span>
<span class="sd">- :py:meth:`redefine_stack_index_map`</span>
<span class="sd">- :py:meth:`serial_to_id`</span>
<span class="sd">- :py:meth:`serial_to_location`</span>
<span class="sd">- :py:meth:`parse_chime_serial`</span>
<span class="sd">- :py:meth:`parse_pathfinder_serial`</span>
<span class="sd">- :py:meth:`parse_old_serial`</span>
<span class="sd">- :py:meth:`get_noise_source_index`</span>
<span class="sd">- :py:meth:`get_holographic_index`</span>
<span class="sd">- :py:meth:`change_pathfinder_location`</span>
<span class="sd">- :py:meth:`change_chime_location`</span>
<span class="sd">- :py:meth:`beam_index2number`</span>

<span class="sd">This can determine if we are connected to any of the following:</span>

<span class="sd">- :py:class:`HolographyAntenna`</span>
<span class="sd">- :py:class:`ArrayAntenna`</span>
<span class="sd">- :py:class:`PathfinderAntenna`</span>
<span class="sd">- :py:class:`CHIMEAntenna`</span>
<span class="sd">- :py:class:`RFIAntenna`</span>
<span class="sd">- :py:class:`NoiseSource`</span>
<span class="sd">- :py:class:`Blank`</span>

<span class="sd">Example</span>
<span class="sd">-------</span>

<span class="sd">Fetch the inputs for blanchard during layout 38::</span>

<span class="sd">    &gt;&gt;&gt; from datetime import datetime</span>
<span class="sd">    &gt;&gt;&gt; inputs = get_correlator_inputs(datetime(2016,05,23,00),</span>
<span class="sd">    ... correlator=&#39;pathfinder&#39;)</span>
<span class="sd">    &gt;&gt;&gt; inputs[1]</span>
<span class="sd">    CHIMEAntenna(id=1, reflector=u&#39;W_cylinder&#39;, antenna=u&#39;ANT0123B&#39;,</span>
<span class="sd">    powered=True, pos=9.071800000000001, input_sn=u&#39;K7BP16-00040401&#39;,</span>
<span class="sd">    pol=u&#39;S&#39;, corr=u&#39;K7BP16-0004&#39;, cyl=0)</span>
<span class="sd">    &gt;&gt;&gt; print &quot;NS position:&quot;, inputs[1].pos</span>
<span class="sd">    NS position: 9.0718</span>
<span class="sd">    &gt;&gt;&gt; print &quot;Polarisation:&quot;, inputs[1].pol</span>
<span class="sd">    Polarisation: S</span>
<span class="sd">    &gt;&gt;&gt; inputs[3]</span>
<span class="sd">    CHIMEAntenna(id=3, reflector=u&#39;W_cylinder&#39;, antenna=u&#39;ANT0128B&#39;,</span>
<span class="sd">    powered=True, pos=9.681400000000002, input_sn=u&#39;K7BP16-00040403&#39;,</span>
<span class="sd">    pol=u&#39;S&#39;, corr=u&#39;K7BP16-0004&#39;, cyl=0)</span>

<span class="sd">Housekeeping Inputs</span>
<span class="sd">===================</span>

<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">- :py:meth:`antenna_to_lna`</span>
<span class="sd">- :py:meth:`calibrate_temperature`</span>
<span class="sd">- :py:meth:`hk_to_sensor`</span>
<span class="sd">- :py:meth:`lna_to_antenna`</span>
<span class="sd">- :py:meth:`sensor_to_hk`</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">- :py:class:`HKInput`</span>


<span class="sd">Product Array Mapping</span>
<span class="sd">=====================</span>

<span class="sd">Tools for mapping between products stored in upper triangular format, and the</span>
<span class="sd">underlying pairs of inputs.</span>

<span class="sd">- :py:meth:`cmap`</span>
<span class="sd">- :py:meth:`icmap`</span>
<span class="sd">- :py:meth:`fast_pack_product_array`</span>
<span class="sd">- :py:meth:`pack_product_array`</span>
<span class="sd">- :py:meth:`unpack_product_array`</span>


<span class="sd">Matrix Factorisation</span>
<span class="sd">====================</span>

<span class="sd">A few useful routines for factorising matrices, usually for calibration.</span>

<span class="sd">- :py:meth:`eigh_no_diagonal`</span>
<span class="sd">- :py:meth:`rankN_approx`</span>
<span class="sd">- :py:meth:`normalise_correlations`</span>
<span class="sd">- :py:meth:`apply_gain`</span>
<span class="sd">- :py:meth:`subtract_rank1_signal`</span>


<span class="sd">Fringestopping</span>
<span class="sd">==============</span>

<span class="sd">Routines for undoing the phase rotation of a fixed celestial source. The</span>
<span class="sd">routine :func:`fringestop` is an easy to use routine for fringestopping data</span>
<span class="sd">given a list of the feeds in the data. For more advanced usage</span>
<span class="sd">:func:`fringestop_phase` can be used.</span>

<span class="sd">- :py:meth:`fringestop_phase`</span>
<span class="sd">- :py:meth:`fringestop`</span>

<span class="sd">Miscellaneous</span>
<span class="sd">=============</span>

<span class="sd">- :py:meth:`ensure_list`</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">la</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">pfb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.interferometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">projected_distance</span><span class="p">,</span>
    <span class="n">fringestop_phase</span> <span class="k">as</span> <span class="n">fringestop_phase</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ch_ephem.observers</span>

<span class="c1"># All telescope geometry (rotation, roll, offsets) moved to</span>
<span class="c1"># ch_ephem/instruments.yaml</span>
<span class="c1">#</span>
<span class="c1"># To access them:</span>
<span class="c1">#</span>
<span class="c1"># &gt;&gt;&gt; from ch_ephem.observers import pathfinder</span>
<span class="c1"># &gt;&gt;&gt; PF_POS = pathfinder.offset</span>
<span class="c1"># &gt;&gt;&gt; PF_ROT = pathfinder.rotation</span>
<span class="c1"># &gt;&gt;&gt; PF_ROLL = pathfinder.roll</span>
<span class="c1">#</span>
<span class="c1"># etc.</span>

<span class="c1"># Data</span>
<span class="c1"># ====</span>

<span class="n">PF_SPACE</span> <span class="o">=</span> <span class="mf">22.0</span>  <span class="c1"># Pathfinder cylinder spacing</span>


<span class="c1"># Classes</span>
<span class="c1"># =======</span>


<div class="viewcode-block" id="HKInput">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.HKInput">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HKInput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A housekeeping input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    atmel : :obj:`layout.component`</span>
<span class="sd">       The ATMEL board.</span>
<span class="sd">    chan : int</span>
<span class="sd">        The channel number.</span>
<span class="sd">    mux : int</span>
<span class="sd">        The mux number; if this HK stream has no multiplexer, this will simply</span>
<span class="sd">        remain as :obj:`Null`</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    atmel : :obj:`layout.component`</span>
<span class="sd">       The ATMEL board.</span>
<span class="sd">    chan : int</span>
<span class="sd">        The channel number.</span>
<span class="sd">    mux : int</span>
<span class="sd">        The mux number; if this HK stream has no multiplexer, this will simply</span>
<span class="sd">        remain as :obj:`Null`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">atmel</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">chan</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mux</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atmel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mux</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atmel</span> <span class="o">=</span> <span class="n">atmel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chan</span> <span class="o">=</span> <span class="n">chan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mux</span> <span class="o">=</span> <span class="n">mux</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;HKInput atmel=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">atmel</span><span class="o">.</span><span class="n">sn</span><span class="si">}</span><span class="s2"> chan=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chan</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mux</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;mux=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mux</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;(no mux)&gt;&quot;</span>
        <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="CorrInput">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.CorrInput">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrInput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for describing a correlator input.</span>

<span class="sd">    Meant to be subclassed by actual types of inputs.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    input_sn : str</span>
<span class="sd">        Unique serial number of input.</span>
<span class="sd">    corr : str</span>
<span class="sd">        Unique serial number of correlator.</span>
<span class="sd">        Set to `None` if no correlator is connected.</span>
<span class="sd">    corr_order : int</span>
<span class="sd">        Order of input for correlator internal datastream.</span>
<span class="sd">    crate : int</span>
<span class="sd">        Crate number within the correlator.</span>
<span class="sd">        Set to `None` if correlator consists of single crate.</span>
<span class="sd">    slot : int</span>
<span class="sd">        Slot number of the fpga motherboard within the crate.</span>
<span class="sd">        Ranges from 0 to 15, left to right.</span>
<span class="sd">        Set to `None` if correlator consists of single slot.</span>
<span class="sd">    sma : int</span>
<span class="sd">        SMA number on the fpga motherboard within the slot.</span>
<span class="sd">        Ranges from 0 to 15, bottom to top.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">input_dict</span><span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>

        <span class="k">for</span> <span class="n">basecls</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmro</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">basecls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">fset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">attr</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_attribute_strings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;crate&quot;</span><span class="p">,</span> <span class="s2">&quot;slot&quot;</span><span class="p">,</span> <span class="s2">&quot;sma&quot;</span><span class="p">,</span> <span class="s2">&quot;corr_order&quot;</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">prop</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span>
        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_strings</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Channel ID. Automatically calculated from the serial number</span>
<span class="sd">        if id is not explicitly set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        id : int</span>
<span class="sd">            Channel id. Calculated from the serial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>

        <span class="k">return</span> <span class="n">serial_to_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)</span>

    <span class="nd">@id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">corr_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">serial_to_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">crate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">serial_to_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">slot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">serial_to_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">serial_to_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The delay along the signal chain in seconds.</span>

<span class="sd">        Postive delay values mean signals arriving later than the nominal value.</span>

<span class="sd">        Note that these are always relative. Here CHIME inputs are chosen as</span>
<span class="sd">        the delay=0 reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_delay&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">input_sn</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="Blank">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.Blank">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Blank</span><span class="p">(</span><span class="n">CorrInput</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unconnected input.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<div class="viewcode-block" id="Antenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.Antenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Antenna</span><span class="p">(</span><span class="n">CorrInput</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An antenna input.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    reflector : str</span>
<span class="sd">        The name of the reflector the antenna is on.</span>
<span class="sd">    antenna : str</span>
<span class="sd">        Serial number of the antenna.</span>
<span class="sd">    rf_thru : str</span>
<span class="sd">        Serial number of the RF room thru that</span>
<span class="sd">        the connection passes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">reflector</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">antenna</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">rf_thru</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="RFIAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.RFIAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIAntenna</span><span class="p">(</span><span class="n">Antenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;RFI monitoring antenna&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<div class="viewcode-block" id="NoiseSource">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.NoiseSource">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NoiseSource</span><span class="p">(</span><span class="n">CorrInput</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Broad band noise calibration source.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<div class="viewcode-block" id="ArrayAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.ArrayAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ArrayAntenna</span><span class="p">(</span><span class="n">Antenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Antenna that is part of a cylindrical interferometric array.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    cyl : int</span>
<span class="sd">        Index of the cylinder.</span>
<span class="sd">    pos : [x, y, z]</span>
<span class="sd">        Position of the antenna in meters in right-handed coordinates</span>
<span class="sd">        where x is eastward, y is northward, and z is upward.</span>
<span class="sd">    pol : str</span>
<span class="sd">        Orientation of the polarisation.</span>
<span class="sd">    flag : bool</span>
<span class="sd">        Flag indicating whether or not the antenna is good.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">_roll</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="n">cyl</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_attribute_strings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kv</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_attribute_strings</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pp</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">kv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pos=[</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kv</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_pos&quot;</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">)</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

                <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">):</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)]</span>

            <span class="k">return</span> <span class="n">pos</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@pos</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">vv</span></div>



<div class="viewcode-block" id="PathfinderAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.PathfinderAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PathfinderAntenna</span><span class="p">(</span><span class="n">ArrayAntenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Antenna that is part of the Pathfinder.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    powered : bool</span>
<span class="sd">        Flag indicating that the antenna is powered.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">pathfinder</span> <span class="k">as</span> <span class="n">_pathfinder</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="n">_pathfinder</span><span class="o">.</span><span class="n">rotation</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="n">_pathfinder</span><span class="o">.</span><span class="n">offset</span>

    <span class="c1"># The delay relative to other inputs isn&#39;t really known. Set to NaN so we</span>
    <span class="c1"># don&#39;t make any mistakes</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">powered</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="CHIMEAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.CHIMEAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CHIMEAntenna</span><span class="p">(</span><span class="n">ArrayAntenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Antenna that is part of CHIME.&quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">chime</span> <span class="k">as</span> <span class="n">_chime</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="n">_chime</span><span class="o">.</span><span class="n">rotation</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="n">_chime</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Treat CHIME antennas as defining the delay zero point</span></div>



<div class="viewcode-block" id="KKOAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.KKOAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">KKOAntenna</span><span class="p">(</span><span class="n">ArrayAntenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;KKO outrigger antenna for the CHIME/FRB project.&quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">kko</span> <span class="k">as</span> <span class="n">_kko</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="n">_kko</span><span class="o">.</span><span class="n">rotation</span>
    <span class="n">_roll</span> <span class="o">=</span> <span class="n">_kko</span><span class="o">.</span><span class="n">roll</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="n">_kko</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>



<span class="n">PCOAntenna</span> <span class="o">=</span> <span class="n">KKOAntenna</span>  <span class="c1"># Alias for backwards-compatibility</span>


<div class="viewcode-block" id="GBOAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.GBOAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GBOAntenna</span><span class="p">(</span><span class="n">ArrayAntenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;GBO outrigger antenna for the CHIME/FRB project.&quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">gbo</span> <span class="k">as</span> <span class="n">_gbo</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="n">_gbo</span><span class="o">.</span><span class="n">rotation</span>
    <span class="n">_roll</span> <span class="o">=</span> <span class="n">_gbo</span><span class="o">.</span><span class="n">roll</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="n">_gbo</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>



<div class="viewcode-block" id="HCOAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.HCOAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HCOAntenna</span><span class="p">(</span><span class="n">ArrayAntenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;HCRO outrigger antenna for the CHIME/FRB project.&quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">hco</span> <span class="k">as</span> <span class="n">_hco</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="n">_hco</span><span class="o">.</span><span class="n">rotation</span>
    <span class="n">_roll</span> <span class="o">=</span> <span class="n">_hco</span><span class="o">.</span><span class="n">roll</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="n">_hco</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>



<div class="viewcode-block" id="TONEAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.TONEAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TONEAntenna</span><span class="p">(</span><span class="n">ArrayAntenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Antenna that is part of GBO/TONE Outrigger.</span>
<span class="sd">    Let&#39;s allow for a global rotation and offset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">tone</span> <span class="k">as</span> <span class="n">_tone</span>

    <span class="n">_rotation</span> <span class="o">=</span> <span class="n">_tone</span><span class="o">.</span><span class="n">rotation</span>
    <span class="n">_offset</span> <span class="o">=</span> <span class="n">_tone</span><span class="o">.</span><span class="n">offset</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>



<div class="viewcode-block" id="HolographyAntenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.HolographyAntenna">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HolographyAntenna</span><span class="p">(</span><span class="n">Antenna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Antenna used for holography.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pos : [x, y, z]</span>
<span class="sd">        Position of the antenna in meters in right-handed coordinates</span>
<span class="sd">        where x is eastward, y is northward, and z is upward.</span>
<span class="sd">    pol : str</span>
<span class="sd">        Orientation of the polarisation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_delay</span> <span class="o">=</span> <span class="mf">1.475e-6</span>  <span class="c1"># From doclib:1093</span></div>



<span class="c1"># Private Functions</span>
<span class="c1"># =================</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">layout</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">layout</span><span class="o">.</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">layout</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_feed_position</span><span class="p">(</span><span class="n">lay</span><span class="p">,</span> <span class="n">rfl</span><span class="p">,</span> <span class="n">foc</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">slt</span><span class="p">,</span> <span class="n">slot_factor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate feed position from node properties.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lay : layout.graph</span>
<span class="sd">        Layout instance to search from.</span>
<span class="sd">    rfl : layout.component</span>
<span class="sd">        Reflector.</span>
<span class="sd">    foc : layout.component</span>
<span class="sd">        Focal line slot.</span>
<span class="sd">    cas : layout.component</span>
<span class="sd">        Cassette.</span>
<span class="sd">    slt : layout.component</span>
<span class="sd">        Cassette slot.</span>
<span class="sd">    slot_factor : float</span>
<span class="sd">        1.5 for CHIME, 0.5 for Outriggers</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pos : list</span>
<span class="sd">        x,y,z coordinates of the feed relative to the centre of the focal line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">[</span><span class="n">rfl</span><span class="p">,</span> <span class="n">foc</span><span class="p">,</span> <span class="n">cas</span><span class="p">,</span> <span class="n">slt</span><span class="p">]:</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;x_offset&quot;</span><span class="p">,</span> <span class="s2">&quot;y_offset&quot;</span><span class="p">,</span> <span class="s2">&quot;z_offset&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">:</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># in metres</span>

    <span class="k">if</span> <span class="s2">&quot;y_offset&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">slt</span><span class="p">):</span>
        <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">slt</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">slot_factor</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.3048</span>

    <span class="k">return</span> <span class="n">pos</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_input_props</span><span class="p">(</span><span class="n">lay</span><span class="p">,</span> <span class="n">corr_input</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">rfl_path</span><span class="p">,</span> <span class="n">rfi_antenna</span><span class="p">,</span> <span class="n">noise_source</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fetch all the required properties of an ADC channel or correlator input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lay : layout.graph</span>
<span class="sd">        Layout instance to search from.</span>
<span class="sd">    corr_input : layout.component</span>
<span class="sd">        ADC channel or correlator input.</span>
<span class="sd">    corr : layout.component</span>
<span class="sd">        Correlator.</span>
<span class="sd">    rfl_path : [layout.component]</span>
<span class="sd">        Path from input to reflector, or None.</span>
<span class="sd">    rfi_antenna : layout.component</span>
<span class="sd">        Closest RFI antenna</span>
<span class="sd">    noise_source : layout.component</span>
<span class="sd">        Closest noise source.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    channel : CorrInput</span>
<span class="sd">        An instance of `CorrInput` containing the channel properties.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">corr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">corr_sn</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">sn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">corr_sn</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Check if the correlator input component contains a chan_id property</span>
    <span class="n">corr_prop</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">corr_input</span><span class="p">)</span>
    <span class="n">chan_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">corr_prop</span><span class="p">[</span><span class="s2">&quot;chan_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;chan_id&quot;</span> <span class="ow">in</span> <span class="n">corr_prop</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">rfl</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cas</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">slt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ant</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">rft</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">rfl_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rfl</span> <span class="o">=</span> <span class="n">rfl_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">rfl_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">foc</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;focal line slot&quot;</span><span class="p">)</span>
        <span class="n">cas</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;cassette&quot;</span><span class="p">)</span>
        <span class="n">slt</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;cassette slot&quot;</span><span class="p">)</span>
        <span class="n">ant</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;antenna&quot;</span><span class="p">)</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;polarisation&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">rft_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;rf room thru&quot;</span><span class="p">,</span> <span class="s2">&quot;RFT thru&quot;</span><span class="p">]:</span>
            <span class="n">rft</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">rft_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># If the antenna does not exist, it might be the RFI antenna,</span>
    <span class="c1"># the noise source, or empty</span>
    <span class="k">if</span> <span class="n">ant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rfi_antenna</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rfl</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
                <span class="n">rfi_antenna</span><span class="p">,</span>
                <span class="s2">&quot;reflector&quot;</span><span class="p">,</span>
                <span class="n">type_exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;correlator card slot&quot;</span><span class="p">,</span> <span class="s2">&quot;ADC board&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">rfl_sn</span> <span class="o">=</span> <span class="n">rfl</span><span class="o">.</span><span class="n">sn</span> <span class="k">if</span> <span class="n">rfl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">RFIAntenna</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
                <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
                <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
                <span class="n">reflector</span><span class="o">=</span><span class="n">rfl_sn</span><span class="p">,</span>
                <span class="n">antenna</span><span class="o">=</span><span class="n">rfi_antenna</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Check to see if it is a noise source</span>
        <span class="k">if</span> <span class="n">noise_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NoiseSource</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span> <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">)</span>

        <span class="c1"># If we get to here, it&#39;s probably a blank input</span>
        <span class="k">return</span> <span class="n">Blank</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span> <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">)</span>

    <span class="c1"># Determine polarization from antenna properties</span>
    <span class="n">keydict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="s2">&quot;hpol_orient&quot;</span><span class="p">,</span>
        <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="s2">&quot;vpol_orient&quot;</span><span class="p">,</span>
        <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;pol1_orient&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;pol2_orient&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">pkey</span> <span class="o">=</span> <span class="n">keydict</span><span class="p">[</span><span class="n">pol</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pdir</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">ant</span><span class="p">)[</span><span class="n">pkey</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">pdir</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Determine serial number of RF thru</span>
    <span class="n">rft_sn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rft</span><span class="p">,</span> <span class="s2">&quot;sn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># If the cassette does not exist, must be holography antenna</span>
    <span class="k">if</span> <span class="n">slt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">galt</span>

        <span class="k">return</span> <span class="n">HolographyAntenna</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
            <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
            <span class="n">reflector</span><span class="o">=</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="n">pdir</span><span class="p">,</span>
            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">rf_thru</span><span class="o">=</span><span class="n">rft_sn</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">galt</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># If we are still here, we are a CHIME/Pathfinder feed</span>

    <span class="c1"># Determine if the correlator input has been manually flagged as good or bad</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">corr_prop</span><span class="p">[</span><span class="s2">&quot;manual_flag&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;manual_flag&quot;</span> <span class="ow">in</span> <span class="n">corr_prop</span>
        <span class="k">else</span> <span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Map the cylinder name in the database into a number. This might</span>
    <span class="c1"># be worth changing, such that we could also map into letters</span>
    <span class="c1"># (i.e. A, B, C, D) to save confusion.</span>
    <span class="n">pos_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;W_cylinder&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;E_cylinder&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;cylinder_A&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;cylinder_B&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;cylinder_C&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;cylinder_D&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s2">&quot;pco_cylinder&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s2">&quot;gbo_cylinder&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s2">&quot;hco_cylinder&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">cyl</span> <span class="o">=</span> <span class="n">pos_dict</span><span class="p">[</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">]</span>

    <span class="c1"># Different conventions for CHIME, PCO, GBO, HCO, and Pathfinder</span>
    <span class="k">if</span> <span class="n">cyl</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">cyl</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># Dealing with a CHIME feed</span>

        <span class="c1"># Determine position</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_feed_position</span><span class="p">(</span>
            <span class="n">lay</span><span class="o">=</span><span class="n">lay</span><span class="p">,</span> <span class="n">rfl</span><span class="o">=</span><span class="n">rfl</span><span class="p">,</span> <span class="n">foc</span><span class="o">=</span><span class="n">foc</span><span class="p">,</span> <span class="n">cas</span><span class="o">=</span><span class="n">cas</span><span class="p">,</span> <span class="n">slt</span><span class="o">=</span><span class="n">slt</span><span class="p">,</span> <span class="n">slot_factor</span><span class="o">=</span><span class="mf">1.5</span>
        <span class="p">)</span>

        <span class="c1"># Return CHIMEAntenna object</span>
        <span class="k">return</span> <span class="n">CHIMEAntenna</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
            <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
            <span class="n">reflector</span><span class="o">=</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">cyl</span><span class="o">=</span><span class="n">cyl</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="n">pdir</span><span class="p">,</span>
            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">rf_thru</span><span class="o">=</span><span class="n">rft_sn</span><span class="p">,</span>
            <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">cyl</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cyl</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Dealing with a pathfinder feed</span>

        <span class="c1"># Determine y_offset</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyl</span> <span class="o">*</span> <span class="n">PF_SPACE</span>

        <span class="n">cas_prop</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">cas</span><span class="p">)</span>
        <span class="n">slt_prop</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">slt</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cas_prop</span><span class="p">[</span><span class="s2">&quot;dist_to_n_end&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>  <span class="c1"># in metres</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">slt_prop</span><span class="p">[</span><span class="s2">&quot;dist_to_edge&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>  <span class="c1"># in metres</span>
            <span class="n">orient</span> <span class="o">=</span> <span class="n">cas_prop</span><span class="p">[</span><span class="s2">&quot;slot_zero_pos&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

            <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span> <span class="k">if</span> <span class="n">orient</span> <span class="o">==</span> <span class="s2">&quot;N&quot;</span> <span class="k">else</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>

            <span class="c1"># Turn into distance increasing from South to North.</span>
            <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.0</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Try and determine if the FLA is powered or not. Paths without an</span>
        <span class="c1"># FLA (e.g. RFoF paths) are assumed to be powered on.</span>
        <span class="n">pwd</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">rft</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rft_prop</span> <span class="o">=</span> <span class="n">lay</span><span class="o">.</span><span class="n">node_property</span><span class="p">(</span><span class="n">rft</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;powered&quot;</span> <span class="ow">in</span> <span class="n">rft_prop</span><span class="p">:</span>
                <span class="n">pwd</span> <span class="o">=</span> <span class="n">rft_prop</span><span class="p">[</span><span class="s2">&quot;powered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="n">pwd</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pwd</span><span class="p">))</span>

        <span class="c1"># Return PathfinderAntenna object</span>
        <span class="k">return</span> <span class="n">PathfinderAntenna</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
            <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
            <span class="n">reflector</span><span class="o">=</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">cyl</span><span class="o">=</span><span class="n">cyl</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="n">pdir</span><span class="p">,</span>
            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">rf_thru</span><span class="o">=</span><span class="n">rft_sn</span><span class="p">,</span>
            <span class="n">powered</span><span class="o">=</span><span class="n">pwd</span><span class="p">,</span>
            <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">cyl</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="c1"># Dealing with an KKO feed</span>

        <span class="c1"># Determine position</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_feed_position</span><span class="p">(</span>
            <span class="n">lay</span><span class="o">=</span><span class="n">lay</span><span class="p">,</span> <span class="n">rfl</span><span class="o">=</span><span class="n">rfl</span><span class="p">,</span> <span class="n">foc</span><span class="o">=</span><span class="n">foc</span><span class="p">,</span> <span class="n">cas</span><span class="o">=</span><span class="n">cas</span><span class="p">,</span> <span class="n">slt</span><span class="o">=</span><span class="n">slt</span><span class="p">,</span> <span class="n">slot_factor</span><span class="o">=</span><span class="mf">0.5</span>
        <span class="p">)</span>

        <span class="c1"># Return KKOAntenna object</span>
        <span class="k">return</span> <span class="n">KKOAntenna</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
            <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
            <span class="n">reflector</span><span class="o">=</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">cyl</span><span class="o">=</span><span class="n">cyl</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="n">pdir</span><span class="p">,</span>
            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">rf_thru</span><span class="o">=</span><span class="n">rft_sn</span><span class="p">,</span>
            <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">cyl</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="c1"># Dealing with a GBO feed</span>

        <span class="c1"># Determine position</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_feed_position</span><span class="p">(</span>
            <span class="n">lay</span><span class="o">=</span><span class="n">lay</span><span class="p">,</span> <span class="n">rfl</span><span class="o">=</span><span class="n">rfl</span><span class="p">,</span> <span class="n">foc</span><span class="o">=</span><span class="n">foc</span><span class="p">,</span> <span class="n">cas</span><span class="o">=</span><span class="n">cas</span><span class="p">,</span> <span class="n">slt</span><span class="o">=</span><span class="n">slt</span><span class="p">,</span> <span class="n">slot_factor</span><span class="o">=</span><span class="mf">0.5</span>
        <span class="p">)</span>

        <span class="c1"># Return GBOAntenna object</span>
        <span class="k">return</span> <span class="n">GBOAntenna</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
            <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
            <span class="n">reflector</span><span class="o">=</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">cyl</span><span class="o">=</span><span class="n">cyl</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="n">pdir</span><span class="p">,</span>
            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">rf_thru</span><span class="o">=</span><span class="n">rft_sn</span><span class="p">,</span>
            <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">cyl</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># Dealing with a HCO feed</span>

        <span class="c1"># Determine position</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_feed_position</span><span class="p">(</span>
            <span class="n">lay</span><span class="o">=</span><span class="n">lay</span><span class="p">,</span> <span class="n">rfl</span><span class="o">=</span><span class="n">rfl</span><span class="p">,</span> <span class="n">foc</span><span class="o">=</span><span class="n">foc</span><span class="p">,</span> <span class="n">cas</span><span class="o">=</span><span class="n">cas</span><span class="p">,</span> <span class="n">slt</span><span class="o">=</span><span class="n">slt</span><span class="p">,</span> <span class="n">slot_factor</span><span class="o">=</span><span class="mf">0.5</span>
        <span class="p">)</span>

        <span class="c1"># Return HCOAntenna object</span>
        <span class="k">return</span> <span class="n">HCOAntenna</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">chan_id</span><span class="p">,</span>
            <span class="n">input_sn</span><span class="o">=</span><span class="n">corr_input</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">corr_sn</span><span class="p">,</span>
            <span class="n">reflector</span><span class="o">=</span><span class="n">rfl</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">cyl</span><span class="o">=</span><span class="n">cyl</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="n">pdir</span><span class="p">,</span>
            <span class="n">antenna</span><span class="o">=</span><span class="n">ant</span><span class="o">.</span><span class="n">sn</span><span class="p">,</span>
            <span class="n">rf_thru</span><span class="o">=</span><span class="n">rft_sn</span><span class="p">,</span>
            <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Fell out of the bottom of _get_input_props!&quot;</span><span class="p">)</span>


<span class="c1"># Public Functions</span>
<span class="c1"># ================</span>


<div class="viewcode-block" id="calibrate_temperature">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.calibrate_temperature">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calibrate_temperature</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calibrate housekeeping temperatures.</span>

<span class="sd">    The offset used here is rough; the results are therefore not absolutely</span>
<span class="sd">    precise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw : numpy array</span>
<span class="sd">        The raw values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t : numpy array</span>
<span class="sd">        The temperature in degrees Kelvin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">off</span> <span class="o">=</span> <span class="mf">150.0</span>
    <span class="n">r_t</span> <span class="o">=</span> <span class="mf">2000.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">8320.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">raw</span> <span class="o">-</span> <span class="n">off</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">298.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">r_t</span> <span class="o">/</span> <span class="mf">1.0e4</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3950.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="antenna_to_lna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.antenna_to_lna">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">antenna_to_lna</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ant</span><span class="p">,</span> <span class="n">pol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find an LNA connected to an antenna.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : obj:`layout.graph` or :obj:`datetime.datetime`</span>
<span class="sd">        The graph in which to do the search. If you pass a time, then the graph</span>
<span class="sd">        will be constructed internally. (Note that the latter option will be</span>
<span class="sd">        quite slow if you do repeated calls!)</span>
<span class="sd">    ant : :obj:`layout.component`</span>
<span class="sd">        The antenna.</span>
<span class="sd">    pol : integer</span>
<span class="sd">        There can be up to two LNA&#39;s connected to the two polarisation outputs</span>
<span class="sd">        of an antenna. Select which by passing :obj:`1` or :obj:`2`. (Note that</span>
<span class="sd">        conversion to old-style naming &#39;A&#39; and &#39;B&#39; is done automatically.)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lna : :obj:`layout.component` or string</span>
<span class="sd">        The LNA.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    :exc:`layout.NotFound`</span>
<span class="sd">        Raised if the polarisation connector could not be found in the graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">layout</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">_ensure_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">pol_obj</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">comp</span><span class="o">=</span><span class="n">ant</span><span class="p">),</span> <span class="s2">&quot;polarisation&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pol</span><span class="p">):</span>
            <span class="n">pol_obj</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pol_obj</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">layout</span><span class="o">.</span><span class="n">NotFound</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">pol_obj</span><span class="p">,</span> <span class="s2">&quot;LNA&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="lna_to_antenna">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.lna_to_antenna">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lna_to_antenna</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">lna</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find an antenna connected to an LNA.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : obj:`layout.graph` or :obj:`datetime.datetime`</span>
<span class="sd">        The graph in which to do the search. If you pass a time, then the graph</span>
<span class="sd">        will be constructed internally. (Note that the latter option will be</span>
<span class="sd">        quite slow if you do repeated calls!)</span>
<span class="sd">    lna : :obj:`layout.component` or string</span>
<span class="sd">        The LNA.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    antenna : :obj:`layout.component`</span>
<span class="sd">        The antenna.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">_ensure_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">comp</span><span class="o">=</span><span class="n">lna</span><span class="p">),</span> <span class="s2">&quot;antenna&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="s2">&quot;60m coax&quot;</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="sensor_to_hk">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.sensor_to_hk">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sensor_to_hk</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find what housekeeping channel a component is connected to.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : obj:`layout.graph` or :obj:`datetime.datetime`</span>
<span class="sd">        The graph in which to do the search. If you pass a time, then the graph</span>
<span class="sd">        will be constructed internally. (Note that the latter option will be</span>
<span class="sd">        quite slow if you do repeated calls!)</span>
<span class="sd">    comp : :obj:`layout.component` or string</span>
<span class="sd">        The component to search for (you can pass by serial number if you wish).</span>
<span class="sd">        Currently, only components of type LNA, FLA and RFT thru are accepted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inp : :obj:`HKInput`</span>
<span class="sd">        The housekeeping input channel the sensor is connected to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">_ensure_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">comp</span><span class="o">=</span><span class="n">comp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;LNA&quot;</span><span class="p">:</span>
        <span class="c1"># Find the closest mux.</span>
        <span class="n">mux</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
            <span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;HK mux&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;polarisation&quot;</span><span class="p">,</span> <span class="s2">&quot;cassette&quot;</span><span class="p">,</span> <span class="s2">&quot;60m coax&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mux</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hydra</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;HK hydra&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hydra</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mux</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span>
            <span class="n">chan</span> <span class="o">+=</span> <span class="mi">8</span>

        <span class="c1"># Find the ATMEL board.</span>
        <span class="n">atmel</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
            <span class="n">hydra</span><span class="p">,</span> <span class="s2">&quot;HK ATMega&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cassette&quot;</span><span class="p">,</span> <span class="s2">&quot;antenna&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">HKInput</span><span class="p">(</span><span class="n">atmel</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">mux</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;FLA&quot;</span> <span class="ow">or</span> <span class="n">comp</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;RFT thru&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;FLA&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;RFT thru&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hydra</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;HK hydra&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Find the ATMEL board.</span>
        <span class="n">atmel</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
            <span class="n">hydra</span><span class="p">,</span> <span class="s2">&quot;HK ATMega&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;RFT thru&quot;</span><span class="p">,</span> <span class="s2">&quot;FLA&quot;</span><span class="p">,</span> <span class="s2">&quot;SMA coax&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">HKInput</span><span class="p">(</span><span class="n">atmel</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">hydra</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You can only pass components of type LNA, FLA or RFT thru.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="hk_to_sensor">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.hk_to_sensor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hk_to_sensor</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find what component a housekeeping channel is connected to.</span>

<span class="sd">    This method is for finding either LNA or FLA&#39;s that your housekeeping</span>
<span class="sd">    channel is connected to. (It currently cannot find accelerometers, other</span>
<span class="sd">    novel housekeeping instruments that may later exist; nor will it work if the</span>
<span class="sd">    FLA/LNA is connected via a very non-standard chain of components.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : obj:`layout.graph` or :obj:`datetime.datetime`</span>
<span class="sd">        The graph in which to do the search. If you pass a time, then the graph</span>
<span class="sd">        will be constructed internally. (Note that the latter option will be</span>
<span class="sd">        quite slow if you do repeated calls!)</span>
<span class="sd">    inp : :obj:`HKInput`</span>
<span class="sd">        The housekeeping input to search.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    comp : :obj:`layout.component`</span>
<span class="sd">        The LNA/FLA connected to the specified channel; :obj:`None` is returned</span>
<span class="sd">        if none is found.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    :exc:`ValueError`</span>
<span class="sd">        Raised if one of the channels or muxes passed in **hk_chan** is out of</span>
<span class="sd">        range.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">layout</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">_ensure_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Figure out what it is connected to.</span>
    <span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">comp</span><span class="o">=</span><span class="n">inp</span><span class="o">.</span><span class="n">atmel</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">thing</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;HK preamp&quot;</span><span class="p">:</span>
            <span class="c1"># OK, this is a preamp going to FLA&#39;s.</span>
            <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inp</span><span class="o">.</span><span class="n">chan</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;For FLA housekeeping, the channel number &quot;</span>
                    <span class="s2">&quot;must be in the range [0, 7].&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">hydra</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="s2">&quot;HK hydra&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">hydra</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">chan</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span><span class="n">hydra</span><span class="p">,</span> <span class="s2">&quot;FLA&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="s2">&quot;HK preamp&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">thing</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;HK mux box&quot;</span><span class="p">:</span>
            <span class="c1"># OK, this is a mux box going to LNA&#39;s.</span>
            <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">mux</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inp</span><span class="o">.</span><span class="n">mux</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;For LNA housekeeping, the mux number must be &quot;</span>
                    <span class="s2">&quot;in the range [0, 7].&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inp</span><span class="o">.</span><span class="n">chan</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;For LNA housekeeping, the channel number &quot;</span>
                    <span class="s2">&quot;must be in the range [0, 15].&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Construct the S/N of the mux connector and get it.</span>
            <span class="n">sn</span> <span class="o">=</span> <span class="n">thing</span><span class="o">.</span><span class="n">sn</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">mux</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;A&quot;</span> <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">chan</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="k">else</span> <span class="s2">&quot;B&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mux_card</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">comp</span><span class="o">=</span><span class="n">sn</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">layout</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Find the closest preamp and the hydra cable corresponding to the</span>
            <span class="c1"># channel requested.</span>
            <span class="n">preamp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
                <span class="n">mux_card</span><span class="p">,</span> <span class="s2">&quot;HK preamp&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="s2">&quot;HK mux box&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">preamp</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">hydra</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">preamp</span><span class="p">,</span> <span class="s2">&quot;HK hydra&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">hydra</span><span class="o">.</span><span class="n">sn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">chan</span> <span class="o">%</span> <span class="mi">8</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbour_of_type</span><span class="p">(</span><span class="n">hydra</span><span class="p">,</span> <span class="s2">&quot;LNA&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="parse_chime_serial">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.parse_chime_serial">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_chime_serial</span><span class="p">(</span><span class="n">sn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a serial number into crate, slot, and SMA number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sn: str</span>
<span class="sd">        Serial number to parse</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    crate: int</span>
<span class="sd">        Crate number</span>
<span class="sd">    slot: int</span>
<span class="sd">        Slot number</span>
<span class="sd">    sma: int</span>
<span class="sd">        SMA number</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError:</span>
<span class="sd">        `sn` did not have the correct format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mo</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;FCC(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Serial number </span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s2"> does not match expected CHIME format.&quot;</span><span class="p">)</span>

    <span class="n">crate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">slot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">sma</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">crate</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">sma</span></div>



<div class="viewcode-block" id="parse_pathfinder_serial">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.parse_pathfinder_serial">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_pathfinder_serial</span><span class="p">(</span><span class="n">sn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a pathfinder serial number into crate, slot, and SMA number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sn: str</span>
<span class="sd">        Serial number to parse</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    crate: int</span>
<span class="sd">        Crate number</span>
<span class="sd">    slot: int</span>
<span class="sd">        Slot number</span>
<span class="sd">    sma: int</span>
<span class="sd">        SMA number</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError:</span>
<span class="sd">        `sn` did not have the correct format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mo</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;(\w</span><span class="si">{6}</span><span class="s2">\-\d</span><span class="si">{4}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Serial number </span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s2"> does not match expected Pathfinder format.&quot;</span>
        <span class="p">)</span>

    <span class="n">crate</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">slot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">sma</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">crate</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">sma</span></div>



<div class="viewcode-block" id="parse_old_serial">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.parse_old_serial">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_old_serial</span><span class="p">(</span><span class="n">sn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse an old 8/16-channel serial number into slot, and SMA number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sn: str</span>
<span class="sd">        Serial number to parse</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slot: int</span>
<span class="sd">        Slot number</span>
<span class="sd">    sma: int</span>
<span class="sd">        SMA number</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError:</span>
<span class="sd">        `sn` did not have the correct format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mo</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;(\d</span><span class="si">{5}</span><span class="s2">\-\d</span><span class="si">{4}</span><span class="s2">\-\d</span><span class="si">{4}</span><span class="s2">)\-C(\d{1,2})&quot;</span><span class="p">,</span> <span class="n">sn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Serial number </span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s2"> does not match expected 8/16 channel format.&quot;</span>
        <span class="p">)</span>

    <span class="n">slot</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sma</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">slot</span><span class="p">,</span> <span class="n">sma</span></div>



<div class="viewcode-block" id="serial_to_id">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.serial_to_id">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">serial_to_id</span><span class="p">(</span><span class="n">serial</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the channel ID corresponding to a correlator input serial number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    serial : string</span>
<span class="sd">        Correlator input serial number.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    id : int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Map a slot and SMA to channel id for Pathfinder</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pathfinder_channel</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">sma</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="mi">80</span><span class="p">,</span>
            <span class="mi">16</span><span class="p">,</span>
            <span class="mi">64</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">208</span><span class="p">,</span>
            <span class="mi">144</span><span class="p">,</span>
            <span class="mi">192</span><span class="p">,</span>
            <span class="mi">128</span><span class="p">,</span>
            <span class="mi">240</span><span class="p">,</span>
            <span class="mi">176</span><span class="p">,</span>
            <span class="mi">224</span><span class="p">,</span>
            <span class="mi">160</span><span class="p">,</span>
            <span class="mi">112</span><span class="p">,</span>
            <span class="mi">48</span><span class="p">,</span>
            <span class="mi">96</span><span class="p">,</span>
            <span class="mi">32</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">+</span> <span class="n">sma</span> <span class="k">if</span> <span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">sma</span>

    <span class="c1"># Determine ID</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">parse_chime_serial</span><span class="p">(</span><span class="n">serial</span><span class="p">)</span>
        <span class="c1"># CHIME chan_id is defined in layout database</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">parse_pathfinder_serial</span><span class="p">(</span><span class="n">serial</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_pathfinder_channel</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">parse_old_serial</span><span class="p">(</span><span class="n">serial</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>



<div class="viewcode-block" id="serial_to_location">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.serial_to_location">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">serial_to_location</span><span class="p">(</span><span class="n">serial</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the internal correlator ordering and the</span>
<span class="sd">    crate, slot, and sma number from a correlator input serial number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    serial : string</span>
<span class="sd">        Correlator input serial number.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    location : 4-tuple</span>
<span class="sd">        (corr_order, crate, slot, sma)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">default</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="n">serial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="c1"># Map slot and sma to position within</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_crate_channel</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">sma</span><span class="p">):</span>
        <span class="n">sma_to_adc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">slot</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">sma_to_adc</span><span class="p">[</span><span class="n">sma</span><span class="p">]</span>

    <span class="c1"># Determine ID</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">parse_chime_serial</span><span class="p">(</span><span class="n">serial</span><span class="p">)</span>
        <span class="n">corr_id</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">get_crate_channel</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">corr_id</span><span class="p">,)</span> <span class="o">+</span> <span class="n">res</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parse_pathfinder_serial</span><span class="p">(</span><span class="n">serial</span><span class="p">))</span>
        <span class="c1"># Use convention that slot number starts at 0 for consistency with CHIME</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">corr_id</span> <span class="o">=</span> <span class="n">get_crate_channel</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">corr_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">parse_old_serial</span><span class="p">(</span><span class="n">serial</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">default</span></div>



<div class="viewcode-block" id="get_default_frequency_map_stream">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_default_frequency_map_stream">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_default_frequency_map_stream</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the default CHIME frequency map stream.</span>

<span class="sd">    Level order is [shuffle, crate, slot, link].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stream</span>
<span class="sd">        [shuffle, crate, slot, link] for each frequency bin</span>
<span class="sd">    stream_id</span>
<span class="sd">        stream_id for each map combination</span>
<span class="sd">        shuffle*2**12 + crate*2**8 + slot*2**4 + link</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># shuffle</span>
    <span class="n">stream</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="c1"># crate</span>
    <span class="n">stream</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="mi">32</span><span class="p">)</span>
    <span class="c1"># slot</span>
    <span class="n">stream</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="mi">64</span><span class="p">)</span>
    <span class="c1"># link</span>
    <span class="n">stream</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">stream_id</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">stream</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">12</span> <span class="o">+</span> <span class="n">stream</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">12</span> <span class="o">+</span> <span class="n">stream</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">stream</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stream</span><span class="p">,</span> <span class="n">stream_id</span></div>



<div class="viewcode-block" id="order_frequency_map_stream">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.order_frequency_map_stream">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">order_frequency_map_stream</span><span class="p">(</span><span class="n">fmap</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">stream_id</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Order stream_id components based on a frequency map.</span>

<span class="sd">    Level order is [shuffle, crate, slot, link]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fmap</span>
<span class="sd">        frequency map</span>
<span class="sd">    stream_id</span>
<span class="sd">        1-D array of stream_ids associated with each row in fmap</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stream</span>
<span class="sd">        shuffle, crate, slot, link for each frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decode_stream_id</span><span class="p">(</span><span class="n">sid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">sid</span> <span class="o">&amp;</span> <span class="mi">15</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span>
        <span class="n">crate</span> <span class="o">=</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span>
        <span class="n">shuffle</span> <span class="o">=</span> <span class="p">(</span><span class="n">sid</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">crate</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>

    <span class="n">decoded_stream</span> <span class="o">=</span> <span class="p">[</span><span class="n">decode_stream_id</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stream_id</span><span class="p">[:]]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stream_id</span><span class="p">))]</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">freqs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fmap</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decoded_stream</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>

    <span class="c1"># TODO: maybe implement some checks here</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_correlator_inputs">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_correlator_inputs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_correlator_inputs</span><span class="p">(</span><span class="n">lay_time</span><span class="p">,</span> <span class="n">correlator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the information for all channels in a layout.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lay_time : layout.graph or datetime</span>
<span class="sd">        layout.graph object, layout tag id, or datetime.</span>
<span class="sd">    correlator : str, optional</span>
<span class="sd">        Fetch only for specified correlator. Use the serial number in database,</span>
<span class="sd">        or `pathfinder` or `chime`, which will substitute the correct serial.</span>
<span class="sd">        If `None` return for all correlators.</span>
<span class="sd">        Option `tone` added for GBO 12 dish outrigger prototype array.</span>
<span class="sd">    connect : bool, optional</span>
<span class="sd">        Connect to database and set the user to Jrs65 prior to query.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    channels : list</span>
<span class="sd">        List of :class:`CorrInput` instances. Returns `None` for MPI ranks</span>
<span class="sd">        other than zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_util</span><span class="w"> </span><span class="kn">import</span> <span class="n">layout</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">chimedb.core.connectdb</span><span class="w"> </span><span class="kn">import</span> <span class="n">connect_this_rank</span>

    <span class="n">coax_type</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SMA coax&quot;</span><span class="p">,</span> <span class="s2">&quot;3.25m SMA coax&quot;</span><span class="p">]</span>

    <span class="n">block</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;correlator card slot&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ADC board&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rf room bulkhead&quot;</span><span class="p">,</span>
        <span class="s2">&quot;c-can bulkhead&quot;</span><span class="p">,</span>
        <span class="s2">&quot;50m coax bundle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HK hydra&quot;</span><span class="p">,</span>
        <span class="s2">&quot;connector plate pol 1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;connector plate pol 2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;thermometer&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># Replace &#39;pathfinder&#39; or &#39;chime&#39; with serial number</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">correlator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">correlator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pathfinder&quot;</span><span class="p">:</span>
            <span class="n">correlator</span> <span class="o">=</span> <span class="s2">&quot;K7BP16-0004&quot;</span>
        <span class="k">elif</span> <span class="n">correlator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;chime&quot;</span><span class="p">:</span>
            <span class="n">correlator</span> <span class="o">=</span> <span class="s2">&quot;FCC&quot;</span>
        <span class="k">elif</span> <span class="n">correlator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pco&quot;</span><span class="p">:</span>
            <span class="n">correlator</span> <span class="o">=</span> <span class="s2">&quot;FCA&quot;</span>
        <span class="k">elif</span> <span class="n">correlator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;kko&quot;</span><span class="p">:</span>
            <span class="n">correlator</span> <span class="o">=</span> <span class="s2">&quot;FCA&quot;</span>
        <span class="k">elif</span> <span class="n">correlator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;gbo&quot;</span><span class="p">:</span>
            <span class="n">correlator</span> <span class="o">=</span> <span class="s2">&quot;FCG&quot;</span>
        <span class="k">elif</span> <span class="n">correlator</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;tone&quot;</span><span class="p">:</span>
            <span class="c1"># A hack to return GBO correlator inputs</span>
            <span class="k">return</span> <span class="n">fake_tone_database</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">connect_this_rank</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">connect</span><span class="p">:</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">connect_database</span><span class="p">(</span><span class="n">read_write</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">set_user</span><span class="p">(</span><span class="s2">&quot;Jrs65&quot;</span><span class="p">)</span>

    <span class="c1"># Fetch layout_tag start time if we received a layout num</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lay_time</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Layout IDs are no longer supported.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lay_time</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="n">layout_graph</span> <span class="o">=</span> <span class="n">layout</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">from_db</span><span class="p">(</span><span class="n">lay_time</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lay_time</span><span class="p">,</span> <span class="n">layout</span><span class="o">.</span><span class="n">graph</span><span class="p">):</span>
        <span class="n">layout_graph</span> <span class="o">=</span> <span class="n">lay_time</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported argument lay_time=</span><span class="si">{</span><span class="n">lay_time</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Fetch all the input components</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">+=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;ADC channel&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">layout</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">+=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;correlator input&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">layout</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Restrict the inputs processed to only those directly connected to the</span>
    <span class="c1"># specified correlator</span>
    <span class="k">if</span> <span class="n">correlator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">correlator</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">layout</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown correlator: &quot;</span> <span class="o">+</span> <span class="n">correlator</span><span class="p">)</span>

        <span class="c1"># Cut out SMA coaxes so we don&#39;t go outside of the correlator</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">layout_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">coty</span> <span class="ow">in</span> <span class="n">coax_type</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">comp_coty</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">coty</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">layout</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sg</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">comp_coty</span><span class="p">)</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>

        <span class="c1"># Use only inputs that are connected to the correlator</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">node_connected_component</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">adc</span><span class="p">:</span> <span class="n">adc</span><span class="o">.</span><span class="n">sn</span><span class="p">)</span>

    <span class="c1"># Perform nearly all the graph queries in one huge batcn to speed things up,</span>
    <span class="c1"># and pass the results into _get_input_props for further processing</span>
    <span class="n">corrs</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;correlator&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="n">coax_type</span><span class="p">)</span>

    <span class="n">rfls</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">shortest_path_to_type</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;reflector&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

    <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;reflector&quot;</span><span class="p">)</span>
    <span class="n">rfi_ants</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;RFI antenna&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
    <span class="n">noise_sources</span> <span class="o">=</span> <span class="n">layout_graph</span><span class="o">.</span><span class="n">closest_of_type</span><span class="p">(</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;noise source&quot;</span><span class="p">,</span> <span class="n">type_exclude</span><span class="o">=</span><span class="n">block</span>
    <span class="p">)</span>

    <span class="n">inputlist</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_get_input_props</span><span class="p">(</span><span class="n">layout_graph</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <span class="n">rfls</span><span class="p">,</span> <span class="n">rfi_ants</span><span class="p">,</span> <span class="n">noise_sources</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Filter to include only inputs attached to the given correlator. In theory</span>
    <span class="c1"># this shouldn&#39;t be necessary if the earlier filtering worked, but I think</span>
    <span class="c1"># it&#39;ll help catch some odd cases</span>
    <span class="k">if</span> <span class="n">correlator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inputlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_</span> <span class="k">for</span> <span class="n">input_</span> <span class="ow">in</span> <span class="n">inputlist</span> <span class="k">if</span> <span class="n">input_</span><span class="o">.</span><span class="n">corr</span> <span class="o">==</span> <span class="n">correlator</span><span class="p">]</span>

    <span class="c1"># Sort by channel ID</span>
    <span class="n">inputlist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">input_</span><span class="p">:</span> <span class="n">input_</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inputlist</span></div>



<div class="viewcode-block" id="change_pathfinder_location">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.change_pathfinder_location">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">change_pathfinder_location</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Change the orientation or location of Pathfinder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rotation : float</span>
<span class="sd">        Rotation of the telescope from true north in degrees.</span>
<span class="sd">    location: list</span>
<span class="sd">        [x, y, z] of the telescope in meters,</span>
<span class="sd">        where x is eastward, y is northward, and z is upward.</span>
<span class="sd">    default:  bool</span>
<span class="sd">        Set parameters back to default value.  Overides other keywords.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">default</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">pathfinder</span>

        <span class="n">rotation</span> <span class="o">=</span> <span class="n">pathfinder</span><span class="o">.</span><span class="n">rotation</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">pathfinder</span><span class="o">.</span><span class="n">offset</span>

    <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">PathfinderAntenna</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="n">rotation</span>

    <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">PathfinderAntenna</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span></div>



<div class="viewcode-block" id="change_chime_location">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.change_chime_location">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">change_chime_location</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Change the orientation or location of CHIME.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rotation : float</span>
<span class="sd">        Rotation of the telescope from true north in degrees.</span>
<span class="sd">    location: list</span>
<span class="sd">        [x, y, z] of the telescope in meters,</span>
<span class="sd">        where x is eastward, y is northward, and z is upward.</span>
<span class="sd">    default: bool</span>
<span class="sd">        Set parameters back to default value.  Overides other keywords.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">default</span><span class="p">:</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">ch_ephem</span><span class="o">.</span><span class="n">observers</span><span class="o">.</span><span class="n">chime</span><span class="o">.</span><span class="n">rotation</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">ch_ephem</span><span class="o">.</span><span class="n">observers</span><span class="o">.</span><span class="n">chime</span><span class="o">.</span><span class="n">offset</span>

    <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">CHIMEAntenna</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="n">rotation</span>

    <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">CHIMEAntenna</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span></div>



<div class="viewcode-block" id="get_feed_positions">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_feed_positions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_feed_positions</span><span class="p">(</span><span class="n">feeds</span><span class="p">,</span> <span class="n">get_zpos</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the positions of the CHIME antennas.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feeds : list of CorrInput</span>
<span class="sd">        List of feeds to compute positions of.</span>
<span class="sd">    get_zpos: bool</span>
<span class="sd">        Return a third column with elevation information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    positions : np.ndarray[nfeed, 2]</span>
<span class="sd">        Array of feed positions. The first column is the E-W position</span>
<span class="sd">        (increasing to the E), and the second is the N-S position (increasing</span>
<span class="sd">        to the N). Non CHIME feeds get set to `NaN`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Extract positions for all array antennas or holographic antennas, fill other</span>
    <span class="c1"># inputs with NaNs</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">feed</span><span class="o">.</span><span class="n">pos</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_array</span><span class="p">(</span><span class="n">feed</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_holographic</span><span class="p">(</span><span class="n">feed</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="k">for</span> <span class="n">feed</span> <span class="ow">in</span> <span class="n">feeds</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Drop z coordinate if not explicitely requested</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">get_zpos</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">pos</span></div>



<div class="viewcode-block" id="fake_tone_database">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.fake_tone_database">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fake_tone_database</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A fake correlator input database for GBO/TONE.&quot;&quot;&quot;</span>
    <span class="n">positions_and_polarizations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">15.08</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.61</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">15.08</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.61</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">9.19</span><span class="p">,</span> <span class="o">-</span><span class="mf">15.24</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">9.19</span><span class="p">,</span> <span class="o">-</span><span class="mf">15.24</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">7.02</span><span class="p">,</span> <span class="mf">14.93</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">7.02</span><span class="p">,</span> <span class="mf">14.93</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">9.01</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.02</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">9.01</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.02</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.8</span><span class="p">,</span> <span class="mf">2.67</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.8</span><span class="p">,</span> <span class="mf">2.67</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.66</span><span class="p">,</span> <span class="mf">10.38</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.66</span><span class="p">,</span> <span class="mf">10.38</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">7.63</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.79</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">7.63</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.79</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">15.43</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.33</span><span class="p">]),</span>
        <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">15.43</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.33</span><span class="p">]),</span>
    <span class="p">]</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span> <span class="n">pol_ns_ew</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions_and_polarizations</span><span class="p">):</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">TONEAntenna</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
                <span class="n">crate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">slot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">sma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">corr_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">input_sn</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;TONE</span><span class="si">{</span><span class="nb">id</span><span class="si">:</span><span class="s2">04</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">corr</span><span class="o">=</span><span class="s2">&quot;tone&quot;</span><span class="p">,</span>
                <span class="n">reflector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">antenna</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ANT</span><span class="si">{</span><span class="nb">id</span><span class="o">//</span><span class="mi">2</span><span class="si">:</span><span class="s2">04</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">rf_thru</span><span class="o">=</span><span class="s2">&quot;N/A&quot;</span><span class="p">,</span>
                <span class="n">cyl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">pol</span><span class="o">=</span><span class="n">pol_ns_ew</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">pos</span><span class="o">=</span><span class="p">[</span><span class="n">pol_ns_ew</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pol_ns_ew</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">inputs</span></div>



<div class="viewcode-block" id="get_feed_polarisations">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_feed_polarisations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_feed_polarisations</span><span class="p">(</span><span class="n">feeds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get an array of the feed polarisations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feeds : list of CorrInput</span>
<span class="sd">        List of feeds to compute positions of.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pol : np.ndarray</span>
<span class="sd">        Array of characters giving polarisation. If not an array feed returns</span>
<span class="sd">        &#39;0&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">f</span><span class="o">.</span><span class="n">pol</span> <span class="k">if</span> <span class="n">is_array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feeds</span><span class="p">])</span></div>



<div class="viewcode-block" id="is_array">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_array</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this feed part of an array?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feed : CorrInput</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    isarr : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">ArrayAntenna</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_array_x">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_array_x">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_array_x</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this an X-polarisation antenna in an array?&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_array</span><span class="p">(</span><span class="n">feed</span><span class="p">)</span> <span class="ow">and</span> <span class="n">feed</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s2">&quot;E&quot;</span></div>



<div class="viewcode-block" id="is_array_y">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_array_y">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_array_y</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this a Y-polarisation antenna in an array?&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_array</span><span class="p">(</span><span class="n">feed</span><span class="p">)</span> <span class="ow">and</span> <span class="n">feed</span><span class="o">.</span><span class="n">pol</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span></div>



<div class="viewcode-block" id="is_chime">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_chime">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_chime</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this feed a CHIME antenna?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feed : CorrInput</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ischime : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">CHIMEAntenna</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_pathfinder">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_pathfinder">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_pathfinder</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this feed a Pathfinder antenna?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feed : CorrInput</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ispathfinder : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">PathfinderAntenna</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_holographic">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_holographic">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_holographic</span><span class="p">(</span><span class="n">feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this feed a holographic antenna?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feed : CorrInput</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    isholo : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">HolographyAntenna</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_holographic_index">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_holographic_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_holographic_index</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the indices of the holography antennas.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : list of :class:`CorrInput`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ixholo : list of int</span>
<span class="sd">        Returns None if holographic antenna not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ixholo</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_holographic</span><span class="p">(</span><span class="n">inp</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">ixholo</span> <span class="ow">or</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="is_noise_source">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_noise_source">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_noise_source</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Is this correlator input connected to a noise source?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inp : CorrInput</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    isnoise : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">NoiseSource</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_noise_source_index">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_noise_source_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_noise_source_index</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the indices of the noise sources.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : list of :class:`CorrInput`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ixns : list of int</span>
<span class="sd">        Returns None if noise source not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ixns</span> <span class="o">=</span> <span class="p">[</span><span class="n">ix</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_noise_source</span><span class="p">(</span><span class="n">inp</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">ixns</span> <span class="ow">or</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="get_noise_channel">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.get_noise_channel">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_noise_channel</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the index of the noise source with</span>
<span class="sd">    the lowest chan id (for backwards compatability).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">noise_sources</span> <span class="o">=</span> <span class="n">get_noise_source_index</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">noise_sources</span> <span class="ow">or</span> <span class="p">[</span><span class="kc">None</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="is_array_on">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.is_array_on">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_array_on</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if inputs are on.</span>

<span class="sd">    Input are on if they are attached to an array antenna AND powered on AND</span>
<span class="sd">    flagged as good.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : CorrInput or list of CorrInput objects</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pwds : boolean or list of bools.</span>
<span class="sd">        If list, it is the same length as inputs. Value is True if input is</span>
<span class="sd">        attached to a ArrayAntenna *and* powered-on and False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This routine no longer accepts a layout time argument.&quot;</span><span class="p">)</span>

    <span class="c1"># Treat scalar case</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">CorrInput</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">is_array</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;powered&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="s2">&quot;flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Assume that the argument is a sequence otherwise</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">is_array_on</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span></div>



<span class="c1"># Create an is_chime_on alias for backwards compatibility</span>
<span class="n">is_chime_on</span> <span class="o">=</span> <span class="n">is_array_on</span>


<div class="viewcode-block" id="reorder_correlator_inputs">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.reorder_correlator_inputs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reorder_correlator_inputs</span><span class="p">(</span><span class="n">input_map</span><span class="p">,</span> <span class="n">corr_inputs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort a list of correlator inputs into the order given in input map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_map : np.ndarray</span>
<span class="sd">        Index map of correlator inputs.</span>
<span class="sd">    corr_inputs : list</span>
<span class="sd">        List of :class:`CorrInput` objects, e.g. the output from</span>
<span class="sd">        :func:`get_correlator_inputs`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corr_input_list: list</span>
<span class="sd">        List of :class:`CorrInput` instances in the new order. Returns `None`</span>
<span class="sd">        where the serial number had no matching entry in parameter ``corr_inputs``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">serials</span> <span class="o">=</span> <span class="n">input_map</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">]</span>

    <span class="n">sorted_inputs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">serial</span> <span class="ow">in</span> <span class="n">serials</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">corr_input</span> <span class="ow">in</span> <span class="n">corr_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">serial</span> <span class="o">==</span> <span class="n">corr_input</span><span class="o">.</span><span class="n">input_sn</span><span class="p">:</span>
                <span class="n">sorted_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_input</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sorted_inputs</span></div>



<div class="viewcode-block" id="redefine_stack_index_map">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.redefine_stack_index_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">redefine_stack_index_map</span><span class="p">(</span><span class="n">input_map</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">reverse_stack</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure only baselines between array antennas are used to represent the stack.</span>

<span class="sd">    The correlator will have inputs that are not connected to array antennas.</span>
<span class="sd">    These inputs are flagged as bad and are not included in the stack, however,</span>
<span class="sd">    products that contain their `chan_id` can still be used to represent a</span>
<span class="sd">    characteristic baseline in the `stack` index map.  This method creates a new</span>
<span class="sd">    `stack` index map that, if possible, only contains products between two</span>
<span class="sd">    array antennas.  This new `stack` index map should be used when calculating</span>
<span class="sd">    baseline distances to fringestop stacked data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_map : list of :class:`CorrInput`</span>
<span class="sd">        List describing the inputs as they are in the file, output from</span>
<span class="sd">        `tools.get_correlator_inputs`</span>
<span class="sd">    prod : np.ndarray[nprod,] of dtype=(&#39;input_a&#39;, &#39;input_b&#39;)</span>
<span class="sd">        The correlation products as pairs of inputs.</span>
<span class="sd">    stack : np.ndarray[nstack,] of dtype=(&#39;prod&#39;, &#39;conjugate&#39;)</span>
<span class="sd">        The index into the `prod` axis of a characteristic baseline included</span>
<span class="sd">        in the stack.</span>
<span class="sd">    reverse_stack :  np.ndarray[nprod,] of dtype=(&#39;stack&#39;, &#39;conjugate&#39;)</span>
<span class="sd">        The index into the `stack` axis that each `prod` belongs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stack_new : np.ndarray[nstack,] of dtype=(&#39;prod&#39;, &#39;conjugate&#39;)</span>
<span class="sd">        The updated `stack` index map, where each element is an index to a product</span>
<span class="sd">        consisting of a pair of array antennas.</span>
<span class="sd">    stack_flag : np.ndarray[nstack,] of dtype=bool</span>
<span class="sd">        Boolean flag that is True if this element of the stack index map is now valid,</span>
<span class="sd">        and False if none of the baselines that were stacked contained array antennas.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">feed_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">is_array</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">input_map</span><span class="p">])</span>
    <span class="n">example_prod</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>
    <span class="n">stack_flag</span> <span class="o">=</span> <span class="n">feed_flag</span><span class="p">[</span><span class="n">example_prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="n">feed_flag</span><span class="p">[</span><span class="n">example_prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span>

    <span class="n">stack_new</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">bad_stack_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="o">~</span><span class="n">stack_flag</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">bad_stack_index</span><span class="p">:</span>
        <span class="n">this_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">reverse_stack</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">this_stack</span><span class="p">:</span>
            <span class="n">tp</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">feed_flag</span><span class="p">[</span><span class="n">tp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">feed_flag</span><span class="p">[</span><span class="n">tp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">stack_new</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s2">&quot;prod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span>
                <span class="n">stack_new</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reverse_stack</span><span class="p">[</span><span class="n">ts</span><span class="p">][</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span>
                <span class="n">stack_flag</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">stack_new</span><span class="p">,</span> <span class="n">stack_flag</span></div>



<div class="viewcode-block" id="cmap">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.cmap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a pair of feed indices, return the pair index.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i, j : integer</span>
<span class="sd">        Feed index.</span>
<span class="sd">    n : integer</span>
<span class="sd">        Total number of feeds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pi : integer</span>
<span class="sd">        Pair index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cmap</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>



<div class="viewcode-block" id="icmap">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.icmap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">icmap</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inverse feed map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ix : integer</span>
<span class="sd">        Pair index.</span>
<span class="sd">    n : integer</span>
<span class="sd">        Total number of feeds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fi, fj : integer</span>
<span class="sd">        Feed indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmap</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ix</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">ii</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="n">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>



<div class="viewcode-block" id="unpack_product_array">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.unpack_product_array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unpack_product_array</span><span class="p">(</span><span class="n">prod_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">feeds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expand packed products to correlation matrices.</span>

<span class="sd">    This turns an axis of the packed upper triangle set of products into the</span>
<span class="sd">    full correlation matrices. It replaces the specified product axis with two</span>
<span class="sd">    axes, one for each feed. By setting `feeds` this routine can also</span>
<span class="sd">    pull out a subset of feeds.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prod_arr : np.ndarray[..., nprod, :]</span>
<span class="sd">        Array containing products packed in upper triangle format.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis the products are contained on.</span>
<span class="sd">    feeds : list of int, optional</span>
<span class="sd">        Indices of feeds to include. If :obj:`None` (default) use all feeds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corr_arr : np.ndarray[..., nfeed, nfeed, ...]</span>
<span class="sd">        Expanded array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nprod</span> <span class="o">=</span> <span class="n">prod_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">nfeed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nprod</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nprod</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;Product axis size does not look correct (not exactly n(n+1)/2).&quot;</span>
        <span class="p">)</span>

    <span class="n">shape0</span> <span class="o">=</span> <span class="n">prod_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">shape1</span> <span class="o">=</span> <span class="n">prod_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:]</span>

    <span class="c1"># Construct slice objects representing the axes before and after the product axis</span>
    <span class="n">slice0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span>

    <span class="c1"># If no feeds specified use all of them</span>
    <span class="n">feeds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nfeed</span><span class="p">))</span> <span class="k">if</span> <span class="n">feeds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">feeds</span>

    <span class="n">outfeeds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">feeds</span><span class="p">)</span>

    <span class="n">exp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape0</span> <span class="o">+</span> <span class="p">(</span><span class="n">outfeeds</span><span class="p">,</span> <span class="n">outfeeds</span><span class="p">)</span> <span class="o">+</span> <span class="n">shape1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">prod_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Iterate over products and copy into correct location of expanded array</span>
    <span class="c1"># Use a python loop, but should be fast if other axes are large</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feeds</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">fj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feeds</span><span class="p">):</span>
            <span class="n">pi</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">fj</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fi</span> <span class="o">&lt;=</span> <span class="n">fj</span><span class="p">:</span>
                <span class="n">exp_arr</span><span class="p">[</span><span class="n">slice0</span> <span class="o">+</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">ij</span><span class="p">)</span> <span class="o">+</span> <span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_arr</span><span class="p">[</span><span class="n">slice0</span> <span class="o">+</span> <span class="p">(</span><span class="n">pi</span><span class="p">,)</span> <span class="o">+</span> <span class="n">slice1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exp_arr</span><span class="p">[</span><span class="n">slice0</span> <span class="o">+</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">ij</span><span class="p">)</span> <span class="o">+</span> <span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_arr</span><span class="p">[</span>
                    <span class="n">slice0</span> <span class="o">+</span> <span class="p">(</span><span class="n">pi</span><span class="p">,)</span> <span class="o">+</span> <span class="n">slice1</span>
                <span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">exp_arr</span></div>



<div class="viewcode-block" id="pack_product_array">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.pack_product_array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pack_product_array</span><span class="p">(</span><span class="n">exp_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pack full correlation matrices into upper triangular form.</span>

<span class="sd">    It replaces the two feed axes of the matrix, with a single upper</span>
<span class="sd">    triangle product axis.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    exp_arr : np.ndarray[..., nfeed, nfeed, ...]</span>
<span class="sd">        Array of full correlation matrices.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Index of the first feed axis. The second feed axis must be the next one.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    prod_arr : np.ndarray[..., nprod, ...]</span>
<span class="sd">        Array containing products packed in upper triangle format.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nfeed</span> <span class="o">=</span> <span class="n">exp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="n">nfeed</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">nfeed</span> <span class="o">!=</span> <span class="n">exp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Does not look like correlation matrices (axes must be equal).&quot;</span><span class="p">)</span>

    <span class="n">shape0</span> <span class="o">=</span> <span class="n">exp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">shape1</span> <span class="o">=</span> <span class="n">exp_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:]</span>

    <span class="n">slice0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span>

    <span class="n">prod_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape0</span> <span class="o">+</span> <span class="p">(</span><span class="n">nprod</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">exp_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Iterate over products and copy from correct location of expanded array</span>
    <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">):</span>
        <span class="n">fi</span><span class="p">,</span> <span class="n">fj</span> <span class="o">=</span> <span class="n">icmap</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">)</span>

        <span class="n">prod_arr</span><span class="p">[</span><span class="n">slice0</span> <span class="o">+</span> <span class="p">(</span><span class="n">pi</span><span class="p">,)</span> <span class="o">+</span> <span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp_arr</span><span class="p">[</span><span class="n">slice0</span> <span class="o">+</span> <span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">fj</span><span class="p">)</span> <span class="o">+</span> <span class="n">slice1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">prod_arr</span></div>



<div class="viewcode-block" id="fast_pack_product_array">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.fast_pack_product_array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fast_pack_product_array</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equivalent to ch_util.tools.pack_product_array(arr, axis=-1),</span>
<span class="sd">    but 10^5 times faster for full CHIME!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : np.ndarray[..., nfeed, nfeed]</span>
<span class="sd">        Array of full correlation matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : np.ndarray[..., nprod]</span>
<span class="sd">        Array containing products packed in upper triangle format</span>
<span class="sd">        with nprod = nfeed*(nfeed+1))/2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">nfeed</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">shp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nprod</span><span class="p">,)</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">iout</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfeed</span><span class="p">):</span>
        <span class="n">ret</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">iout</span> <span class="p">:</span> <span class="p">(</span><span class="n">iout</span> <span class="o">+</span> <span class="n">nfeed</span> <span class="o">-</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span>
        <span class="n">iout</span> <span class="o">+=</span> <span class="n">nfeed</span> <span class="o">-</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="rankN_approx">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.rankN_approx">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rankN_approx</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the rank-N approximation to the matrix A.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        Matrix to approximate</span>
<span class="sd">    rank : int, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : np.ndarray</span>
<span class="sd">        Low rank approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eigvals</span><span class="o">=</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">rank</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evecs</span><span class="p">,</span> <span class="n">evals</span> <span class="o">*</span> <span class="n">evecs</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span></div>



<div class="viewcode-block" id="eigh_no_diagonal">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.eigh_no_diagonal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eigh_no_diagonal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">eigvals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Eigenvalue decomposition ignoring the diagonal elements.</span>

<span class="sd">    The diagonal elements are iteratively replaced with those from a rank=1</span>
<span class="sd">    approximation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray[:, :]</span>
<span class="sd">        Matrix to decompose.</span>
<span class="sd">    niter : int, optional</span>
<span class="sd">        Number of iterations to perform.</span>
<span class="sd">    eigvals : (lo, hi), optional</span>
<span class="sd">        Indices of eigenvalues to select (inclusive).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    evals : np.ndarray[:]</span>
<span class="sd">    evecs : np.ndarray[:, :]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">niter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
            <span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">rankN_approx</span><span class="p">(</span><span class="n">Ac</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">la</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">eigvals</span><span class="o">=</span><span class="n">eigvals</span><span class="p">)</span></div>



<div class="viewcode-block" id="normalise_correlations">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.normalise_correlations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalise_correlations</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalise to make a correlation matrix from a covariance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray[:, :]</span>
<span class="sd">        Matrix to normalise.</span>
<span class="sd">    norm : np.ndarray[:,:]</span>
<span class="sd">        Normalize by diagonals of norm.</span>
<span class="sd">        If None, then normalize by diagonals of A.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : np.ndarray[:, :]</span>
<span class="sd">        Normalised correlation matrix.</span>
<span class="sd">    ach : np.ndarray[:]</span>
<span class="sd">        Array of the square root diagonal elements that normalise the matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ach</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ach</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">aci</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ach</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">aci</span><span class="p">,</span> <span class="n">aci</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">ach</span></div>



<div class="viewcode-block" id="apply_gain">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.apply_gain">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_gain</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prod_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply per input gains to a set of visibilities packed in upper</span>
<span class="sd">    triangular format.</span>

<span class="sd">    This allows us to apply the gains while minimising the intermediate</span>
<span class="sd">    products created.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vis : np.ndarray[..., nprod, ...]</span>
<span class="sd">        Array of visibility products.</span>
<span class="sd">    gain : np.ndarray[..., ninput, ...]</span>
<span class="sd">        Array of gains. One gain per input.</span>
<span class="sd">    axis : integer, optional</span>
<span class="sd">        The axis along which the inputs (or visibilities) are</span>
<span class="sd">        contained. Currently only supports axis=1.</span>
<span class="sd">    out : np.ndarray</span>
<span class="sd">        Array to place output in. If :obj:`None` create a new</span>
<span class="sd">        array. This routine can safely use `out = vis`.</span>
<span class="sd">    prod_map : ndarray of integer pairs</span>
<span class="sd">        Gives the mapping from product axis to input pairs. If not supplied,</span>
<span class="sd">        :func:`icmap` is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : np.ndarray</span>
<span class="sd">        Visibility array with gains applied. Same shape as :obj:`vis`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nprod</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">ninput</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nprod</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ninput</span> <span class="o">*</span> <span class="p">(</span><span class="n">ninput</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of inputs does not match the number of products.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprod</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Length of *prod_map* does not match number of input products.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Could check prod_map contents as well, but the loop should give a</span>
        <span class="c1"># sensible error if this is wrong, and checking is expensive.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prod_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">icmap</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">ninput</span><span class="p">)</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Output array is wrong shape.&quot;</span><span class="p">)</span>

    <span class="c1"># Iterate over input pairs and set gains</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">):</span>
        <span class="c1"># Determine the inputs.</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">ij</span> <span class="o">=</span> <span class="n">prod_map</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>

        <span class="c1"># Fetch the gains</span>
        <span class="n">gi</span> <span class="o">=</span> <span class="n">gain</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
        <span class="n">gj</span> <span class="o">=</span> <span class="n">gain</span><span class="p">[:,</span> <span class="n">ij</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="c1"># Apply the gains and save into the output array.</span>
        <span class="n">out</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">*</span> <span class="n">gi</span> <span class="o">*</span> <span class="n">gj</span>

    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="subtract_rank1_signal">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.subtract_rank1_signal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subtract_rank1_signal</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prod_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subtract a rank 1 signal from a set of visibilities packed in upper</span>
<span class="sd">    triangular format.</span>

<span class="sd">    This allows us to subtract the noise injection solutions</span>
<span class="sd">    while minimising the intermediate products created.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vis : np.ndarray[..., nprod, ...]</span>
<span class="sd">        Array of visibility products.</span>
<span class="sd">    signal : np.ndarray[..., ninput, ...]</span>
<span class="sd">        Array of underlying signals. One signal per input.</span>
<span class="sd">    axis : integer, optional</span>
<span class="sd">        The axis along which the inputs (or visibilities) are</span>
<span class="sd">        contained. Currently only supports axis=1.</span>
<span class="sd">    out : np.ndarray</span>
<span class="sd">        Array to place output in. If :obj:`None` create a new</span>
<span class="sd">        array. This routine can safely use `out = vis`.</span>
<span class="sd">    prod_map : ndarray of integer pairs</span>
<span class="sd">        Gives the mapping from product axis to input pairs. If not supplied,</span>
<span class="sd">        :func:`icmap` is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : np.ndarray</span>
<span class="sd">        Visibility array with signal subtracted. Same shape as :obj:`vis`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nprod</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">ninput</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nprod</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ninput</span> <span class="o">*</span> <span class="p">(</span><span class="n">ninput</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of inputs does not match the number of products.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprod</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Length of *prod_map* does not match number of input products.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Could check prod_map contents as well, but the loop should give a</span>
        <span class="c1"># sensible error if this is wrong, and checking is expensive.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prod_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">icmap</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">ninput</span><span class="p">)</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Output array is wrong shape.&quot;</span><span class="p">)</span>

    <span class="c1"># Iterate over input pairs and set signals</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprod</span><span class="p">):</span>
        <span class="c1"># Determine the inputs.</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">ij</span> <span class="o">=</span> <span class="n">prod_map</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>

        <span class="c1"># Fetch the signals</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="n">ij</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="c1"># Apply the signals and save into the output array.</span>
        <span class="n">out</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">-</span> <span class="n">si</span> <span class="o">*</span> <span class="n">sj</span>

    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="fringestop_time">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.fringestop_time">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fringestop_time</span><span class="p">(</span>
    <span class="n">timestream</span><span class="p">,</span>
    <span class="n">times</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">,</span>
    <span class="n">feeds</span><span class="p">,</span>
    <span class="n">src</span><span class="p">,</span>
    <span class="n">wterm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">bterm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prod_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">csd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">static_delays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fringestop timestream data to a fixed source.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timestream : np.ndarray[nfreq, nprod, times]</span>
<span class="sd">        Array containing the visibility timestream.</span>
<span class="sd">    times : np.ndarray[times]</span>
<span class="sd">        The UNIX time of each sample, or (if csd=True), the CSD of each sample.</span>
<span class="sd">    freq : np.ndarray[nfreq]</span>
<span class="sd">        The frequencies in the array (in MHz).</span>
<span class="sd">    feeds : list of CorrInputs</span>
<span class="sd">        The feeds in the timestream.</span>
<span class="sd">    src : skyfield source</span>
<span class="sd">        skyfield.starlib.Star or skyfield.vectorlib.VectorSum or</span>
<span class="sd">        skyfield.jpllib.ChebyshevPosition body representing the source.</span>
<span class="sd">    wterm: bool, optional</span>
<span class="sd">        Include elevation information in the calculation.</span>
<span class="sd">    bterm: bool, optional</span>
<span class="sd">        Include a correction for baselines including the 26m Galt telescope.</span>
<span class="sd">    prod_map: np.ndarray[nprod]</span>
<span class="sd">        The products in the `timestream` array.</span>
<span class="sd">    csd: bool, optional</span>
<span class="sd">        Interpret the times parameter as CSDs.</span>
<span class="sd">    inplace: bool, optional</span>
<span class="sd">        Fringestop the visibilities in place. If not set, leave the originals intact.</span>
<span class="sd">    static_delays: bool, optional</span>
<span class="sd">        Correct for static cable delays in the system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fringestopped_timestream : np.ndarray[nfreq, nprod, times]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">chime</span> <span class="k">as</span> <span class="n">obs</span>

    <span class="c1"># Check the shapes match</span>
    <span class="n">nfeed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">feeds</span><span class="p">)</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_map</span><span class="p">)</span> <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nfeed</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">expected_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">nprod</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">timestream</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The shape of the timestream (</span><span class="si">{</span><span class="n">timestream</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;does not match the expected shape: </span><span class="si">{</span><span class="n">expected_shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">delays</span> <span class="o">=</span> <span class="n">delay</span><span class="p">(</span>
        <span class="n">times</span><span class="p">,</span>
        <span class="n">feeds</span><span class="p">,</span>
        <span class="n">src</span><span class="p">,</span>
        <span class="n">wterm</span><span class="o">=</span><span class="n">wterm</span><span class="p">,</span>
        <span class="n">bterm</span><span class="o">=</span><span class="n">bterm</span><span class="p">,</span>
        <span class="n">prod_map</span><span class="o">=</span><span class="n">prod_map</span><span class="p">,</span>
        <span class="n">csd</span><span class="o">=</span><span class="n">csd</span><span class="p">,</span>
        <span class="n">static_delays</span><span class="o">=</span><span class="n">static_delays</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Set any non CHIME feeds to have zero phase</span>
    <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">delays</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># If modifying inplace, loop to try and save some memory on large datasets</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">fr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">fs_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">delays</span> <span class="o">*</span> <span class="n">fr</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>
            <span class="n">timestream</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fs_phase</span>
        <span class="n">fs_timestream</span> <span class="o">=</span> <span class="n">timestream</span>
    <span class="c1"># Otherwise we might as well generate the entire phase array in onestop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_timestream</span> <span class="o">=</span> <span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">delays</span> <span class="o">*</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">fs_timestream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">fs_timestream</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">fs_timestream</span><span class="p">)</span>
        <span class="n">fs_timestream</span> <span class="o">*=</span> <span class="n">timestream</span>

    <span class="k">return</span> <span class="n">fs_timestream</span></div>



<span class="c1"># Cache the PFB object</span>
<span class="n">_chime_pfb</span> <span class="o">=</span> <span class="n">pfb</span><span class="o">.</span><span class="n">PFB</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span>


<div class="viewcode-block" id="decorrelation">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.decorrelation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decorrelation</span><span class="p">(</span>
    <span class="n">timestream</span><span class="p">,</span>
    <span class="n">times</span><span class="p">,</span>
    <span class="n">feeds</span><span class="p">,</span>
    <span class="n">src</span><span class="p">,</span>
    <span class="n">wterm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bterm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prod_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">csd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">static_delays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply the decorrelation corrections to a timestream from observing a source.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timestream : np.ndarray[nfreq, nprod, times]</span>
<span class="sd">        Array containing the timestream.</span>
<span class="sd">    times : np.ndarray[times]</span>
<span class="sd">        The UNIX time of each sample, or (if csd=True), the CSD of each sample.</span>
<span class="sd">    feeds : list of CorrInputs</span>
<span class="sd">        The feeds in the timestream.</span>
<span class="sd">    src : skyfield source</span>
<span class="sd">        skyfield.starlib.Star or skyfield.vectorlib.VectorSum or</span>
<span class="sd">        skyfield.jpllib.ChebyshevPosition body representing the source.</span>
<span class="sd">    wterm: bool, optional</span>
<span class="sd">        Include elevation information in the calculation.</span>
<span class="sd">    bterm: bool, optional</span>
<span class="sd">        Include a correction for baselines including the 26m Galt telescope.</span>
<span class="sd">    prod_map: np.ndarray[nprod]</span>
<span class="sd">        The products in the `timestream` array.</span>
<span class="sd">    csd: bool, optional</span>
<span class="sd">        Interpret the times parameter as CSDs.</span>
<span class="sd">    inplace: bool, optional</span>
<span class="sd">        Fringestop the visibilities in place. If not set, leave the originals intact.</span>
<span class="sd">    static_delays: bool, optional</span>
<span class="sd">        Correct for static cable delays in the system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corrected_timestream : np.ndarray[nfreq, nprod, times]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check the shapes match</span>
    <span class="n">nfeed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">feeds</span><span class="p">)</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_map</span><span class="p">)</span> <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nfeed</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">expected_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nprod</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">timestream</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The shape of the timestream (</span><span class="si">{</span><span class="n">timestream</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;does not match the expected shape: </span><span class="si">{</span><span class="n">expected_shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">delays</span> <span class="o">=</span> <span class="n">delay</span><span class="p">(</span>
        <span class="n">times</span><span class="p">,</span>
        <span class="n">feeds</span><span class="p">,</span>
        <span class="n">src</span><span class="p">,</span>
        <span class="n">wterm</span><span class="o">=</span><span class="n">wterm</span><span class="p">,</span>
        <span class="n">bterm</span><span class="o">=</span><span class="n">bterm</span><span class="p">,</span>
        <span class="n">prod_map</span><span class="o">=</span><span class="n">prod_map</span><span class="p">,</span>
        <span class="n">csd</span><span class="o">=</span><span class="n">csd</span><span class="p">,</span>
        <span class="n">static_delays</span><span class="o">=</span><span class="n">static_delays</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Set any non CHIME feeds to have zero delay</span>
    <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">delays</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">ratio_correction</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span>
        <span class="n">_chime_pfb</span><span class="o">.</span><span class="n">decorrelation_ratio</span><span class="p">(</span><span class="n">delays</span> <span class="o">*</span> <span class="mf">800e6</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">timestream</span> <span class="o">*=</span> <span class="n">ratio_correction</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">timestream</span> <span class="o">=</span> <span class="n">timestream</span> <span class="o">*</span> <span class="n">ratio_correction</span>

    <span class="k">return</span> <span class="n">timestream</span></div>



<div class="viewcode-block" id="delay">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.delay">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delay</span><span class="p">(</span>
    <span class="n">times</span><span class="p">,</span>
    <span class="n">feeds</span><span class="p">,</span>
    <span class="n">src</span><span class="p">,</span>
    <span class="n">wterm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bterm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">prod_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">csd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">static_delays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the delay in a visibilities observing a given source.</span>

<span class="sd">    This includes both the geometric delay and static (cable) delays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : np.ndarray[times]</span>
<span class="sd">        The UNIX time of each sample, or (if csd=True), the CSD of each sample.</span>
<span class="sd">    feeds : list of CorrInputs</span>
<span class="sd">        The feeds in the timestream.</span>
<span class="sd">    src : skyfield source</span>
<span class="sd">        skyfield.starlib.Star or skyfield.vectorlib.VectorSum or</span>
<span class="sd">        skyfield.jpllib.ChebyshevPosition body representing the source.</span>
<span class="sd">    wterm: bool, optional</span>
<span class="sd">        Include elevation information in the calculation.</span>
<span class="sd">    bterm: bool, optional</span>
<span class="sd">        Include a correction for baselines which include the 26m Galt telescope.</span>
<span class="sd">    prod_map: np.ndarray[nprod]</span>
<span class="sd">        The products in the `timestream` array.</span>
<span class="sd">    csd: bool, optional</span>
<span class="sd">        Interpret the times parameter as CSDs.</span>
<span class="sd">    static_delays: bool, optional</span>
<span class="sd">        If set the returned value includes both geometric and static delays.</span>
<span class="sd">        If `False` only geometric delays are included.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    delay : np.ndarray[nprod, nra]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.constants</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">object_coords</span>

    <span class="k">if</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">chime</span> <span class="k">as</span> <span class="n">obs</span>

    <span class="n">ra</span> <span class="o">=</span> <span class="p">(</span><span class="n">times</span> <span class="o">%</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">360.0</span> <span class="k">if</span> <span class="n">csd</span> <span class="k">else</span> <span class="n">obs</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>
    <span class="n">ha</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span> <span class="o">-</span> <span class="n">src_ra</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
    <span class="c1"># Get feed positions / c</span>
    <span class="n">feedpos</span> <span class="o">=</span> <span class="n">get_feed_positions</span><span class="p">(</span><span class="n">feeds</span><span class="p">,</span> <span class="n">get_zpos</span><span class="o">=</span><span class="n">wterm</span><span class="p">)</span> <span class="o">/</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span>
    <span class="n">feed_delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">delay</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feeds</span><span class="p">])</span>
    <span class="c1"># Calculate the geometric delay between the feed and the reference position</span>
    <span class="n">delay_ref</span> <span class="o">=</span> <span class="o">-</span><span class="n">projected_distance</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="o">*</span><span class="n">feedpos</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="c1"># Add in the static delays</span>
    <span class="k">if</span> <span class="n">static_delays</span><span class="p">:</span>
        <span class="n">delay_ref</span> <span class="o">+=</span> <span class="n">feed_delays</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Calculate baseline separations and pack into product array</span>
    <span class="k">if</span> <span class="n">prod_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">delays</span> <span class="o">=</span> <span class="n">fast_pack_product_array</span><span class="p">(</span>
            <span class="n">delay_ref</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">delay_ref</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">delays</span> <span class="o">=</span> <span class="n">delay_ref</span><span class="p">[</span><span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">delay_ref</span><span class="p">[</span><span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span>

    <span class="c1"># Add the b-term for baselines including the 26m Galt telescope</span>
    <span class="k">if</span> <span class="n">bterm</span><span class="p">:</span>
        <span class="n">_26M_B</span> <span class="o">=</span> <span class="mf">2.14</span>  <span class="c1"># m</span>
        <span class="n">b_delay</span> <span class="o">=</span> <span class="n">_26M_B</span> <span class="o">/</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">src_dec</span><span class="p">)</span>

        <span class="n">galt_feeds</span> <span class="o">=</span> <span class="n">get_holographic_index</span><span class="p">(</span><span class="n">feeds</span><span class="p">)</span>

        <span class="n">galt_conj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">],</span> <span class="n">galt_feeds</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">galt_noconj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">prod_map</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">],</span> <span class="n">galt_feeds</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">conj_flag</span> <span class="o">=</span> <span class="n">galt_conj</span> <span class="o">+</span> <span class="n">galt_noconj</span>

        <span class="n">delays</span> <span class="o">+=</span> <span class="n">conj_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">b_delay</span>

    <span class="k">return</span> <span class="n">delays</span></div>



<div class="viewcode-block" id="beam_index2number">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.beam_index2number">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">beam_index2number</span><span class="p">(</span><span class="n">beam_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert beam &quot;index&quot; (0-1023) to beam &quot;number&quot; (0-255, 1000-1255, etc.)</span>

<span class="sd">    The beam &quot;number&quot;, with 1000s indicating the beam&#39;s East-West index and the</span>
<span class="sd">    remainder going from 0 through 255 indicating the beam&#39;s North-South index,</span>
<span class="sd">    is used in the CHIME/FRB beam_model package.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beam_index : int or np.ndarray of int</span>
<span class="sd">        The beam index or indices to be converted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    beam_number : same as beam_index</span>
<span class="sd">        The corresponding beam number or numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">beam_ew_index</span> <span class="o">=</span> <span class="n">beam_index</span> <span class="o">//</span> <span class="mi">256</span>
    <span class="n">beam_ns_index</span> <span class="o">=</span> <span class="n">beam_index</span> <span class="o">%</span> <span class="mi">256</span>
    <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">beam_ew_index</span> <span class="o">+</span> <span class="n">beam_ns_index</span></div>



<div class="viewcode-block" id="invert_no_zero">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.invert_no_zero">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">invert_no_zero</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated - use &#39;caput.tools.invert_no_zero&#39;&quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;Function invert_no_zero is deprecated - use &#39;caput.tools.invert_no_zero&#39;&quot;</span><span class="p">,</span>
        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="ensure_list">
<a class="viewcode-back" href="../../_autosummary/ch_util.tools.html#ch_util.tools.ensure_list">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_list</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure `obj` is list-like, optionally with the length `num`.</span>

<span class="sd">    If `obj` not a string but is iterable, it is returned as-is,</span>
<span class="sd">    although a length different than `num`, if given, will result in a</span>
<span class="sd">    `ValueError`.</span>

<span class="sd">    If `obj` is a string or non-iterable, a new list is created with</span>
<span class="sd">    `num` copies of `obj` as elements.  In this case, if `num` is not</span>
<span class="sd">    given, it is taken to be 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj</span>
<span class="sd">        The object to check.</span>
<span class="sd">    num: int, optional</span>
<span class="sd">        If given, also ensure that the list has `num` elements.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj</span>
<span class="sd">        The input object, or the newly created list</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError:</span>
<span class="sd">        `obj` was iterable but did not have a length of `num`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">nnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nnum</span> <span class="o">!=</span> <span class="n">num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input list has wrong size.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">*</span> <span class="n">num</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">obj</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013–2024, CHIME Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>